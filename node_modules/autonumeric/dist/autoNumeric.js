(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AutoNumeric"] = factory();
	else
		root["AutoNumeric"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(8);
	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               AutoNumeric.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version      4.0.0-beta.16\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @date         2017-04-19 UTC 09:00\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author       Bob Knothe\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @contributors Alexandre Bonneau, Sokolov Yura and others, cf. AUTHORS.md\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since        2009-08-09\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @summary      autoNumeric is a standalone Javascript library\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               that provides live *as-you-type* formatting for\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               international numbers and currencies.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               Note : Some functions are borrowed from big.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link         https://github.com/MikeMcl/big.js/\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Please report any bugs to https://github.com/autoNumeric/autoNumeric\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license      Released under the MIT License\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link         http://www.opensource.org/licenses/mit-license.php\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * obtaining a copy of this software and associated documentation\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * files (the \"Software\"), to deal in the Software without\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * restriction, including without limitation the rights to use,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copy, modify, merge, publish, distribute, sub license, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Software is furnished to do so, subject to the following\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * included in all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OTHER DEALINGS IN THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n/* global module */\n\n//TODO Prevent having to enter relative path in the js files (ie. using `./AutoNumericHelper` instead of just `AutoNumericHelper`) (cf. http://moduscreate.com/es6-es2015-import-no-relative-path-webpack/)\n\n\nvar _AutoNumericHelper = __webpack_require__(3);\n\nvar _AutoNumericHelper2 = _interopRequireDefault(_AutoNumericHelper);\n\nvar _AutoNumericEnum = __webpack_require__(2);\n\nvar _AutoNumericEnum2 = _interopRequireDefault(_AutoNumericEnum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Class declaration for the AutoNumeric object.\n *\n * An AutoNumeric element is an object wrapper that keeps a reference to the DOM element it manages (usually an <input> one), and provides autoNumeric-specific variables and functions.\n */\nvar AutoNumeric = function () {\n    //TODO Use the better notation `export default class` when webpack and babel will allow it (cf. https://github.com/webpack/webpack/issues/706)\n    /**\n     * Initialize the AutoNumeric object onto the given DOM element, and attach the settings and related event listeners to it.\n     * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\n     *\n     * @example\n     * anElement = new AutoNumeric(domElement); // With the default options\n     * anElement = new AutoNumeric(domElement, { options }); // With one option object\n     * anElement = new AutoNumeric(domElement, null, { options }); // With one option object, and a failed initial value\n     * anElement = new AutoNumeric(domElement).french(); // With one pre-defined language object\n     * anElement = new AutoNumeric(domElement).french({ options });// With one pre-defined language object and additional options that will override the defaults\n     *\n     * // ...or init and set the value in one call :\n     * anElement = new AutoNumeric(domElement, 12345.789); // With the default options, and an initial value\n     * anElement = new AutoNumeric(domElement, 12345.789, { options });\n     * anElement = new AutoNumeric(domElement, '12345.789', { options });\n     * anElement = new AutoNumeric(domElement, 12345.789).french({ options });\n     * anElement = new AutoNumeric(domElement, 12345.789, { options }).french({ options }); // Not really helpful, but possible\n     *\n     * // The AutoNumeric constructor class can also accept a string as a css selector. Under the hood this use `QuerySelector` and limit itself to only the first element it finds.\n     * anElement = new AutoNumeric('.myCssClass > input');\n     * anElement = new AutoNumeric('.myCssClass > input', { options });\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789);\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789, { options });\n     * anElement = new AutoNumeric('.myCssClass > input', null, { options }); // With a failed initial value\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789).french({ options });\n     *\n     * @param {object|Array|number|string} arg1\n     * @param {object|Array|number|string|null} arg2\n     * @param {object|Array|number|string|null} arg3\n     * @throws\n     */\n    function AutoNumeric() {\n        var arg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        var _this = this;\n\n        var arg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var arg3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        _classCallCheck(this, AutoNumeric);\n\n        // --------------------------------------------------------\n        // -------------- Initialization\n        // Initialize the arguments\n        var _AutoNumeric$_setArgu = AutoNumeric._setArgumentsValues(arg1, arg2, arg3),\n            domElement = _AutoNumeric$_setArgu.domElement,\n            initialValue = _AutoNumeric$_setArgu.initialValue,\n            userOptions = _AutoNumeric$_setArgu.userOptions;\n\n        // Initialize the element\n\n\n        this.domElement = domElement;\n\n        // Generate the settings\n        this._setSettings(userOptions, false);\n        //TODO If `styleRules` is not null, add by default a class 'autoNumeric' that adds transition to color, background-color, border-color properties\n        // Check if the DOM element is supported\n        this._checkElement();\n\n        // Store the additional attributes inside the AutoNumeric object\n        // Note: This variable is needed and not a duplicate of `initialValueOnKeydown` nor `valueOnFocus` since it serves a different purpose and has a different lifecycle\n        this.savedCancellableValue = null;\n\n        // Initialize the undo/redo variables\n        this.historyTable = []; // Keep track of *all* valid states of the element value\n        this.historyTableIndex = -1; // Pointer to the current undo/redo state. This will be set to '0' during initialization since it first adds itself.\n        this.onGoingRedo = false; // Variable that keeps track if a 'redo' is ongoing (in order to prevent an 'undo' to be launch when releasing the shift key before the ctrl key after a 'redo' shortcut)\n\n        // Set the initial value if it exists and if the `formatOnPageLoad` option will allow it\n        if (!this.runOnce && this.settings.formatOnPageLoad) {\n            // Format the element value if needed\n            this._formatDefaultValueOnPageLoad(initialValue);\n        }\n\n        this.runOnce = true;\n\n        // Add the events listeners only on input elements\n        if (this.isInputElement || this.isContentEditable) {\n            if (!this.settings.noEventListeners) {\n                //XXX Here we make sure the global list is created after creating the event listeners, to only create the event listeners on `document` once\n                this._createEventListeners();\n            }\n\n            this._setReadOnly();\n        }\n\n        // Save the initial values (html attribute + element.value) for the pristine test\n        this._saveInitialValues(initialValue);\n\n        // --------------------------------------------------------\n        // -------------- Tracking\n        // Keep track if the element is currently focused\n        this.isFocused = false;\n\n        if (this.settings.createLocalList) {\n            // Keep track of every AutoNumeric elements that this object initialized\n            this._createLocalList();\n        }\n\n        // Keep track of all AutoNumeric elements in the current web page\n        this.constructor._addToGlobalList(this);\n\n        // --------------------------------------------------------\n        // -------------- Methods\n        // Create the global functions\n        this.global = {\n            /**\n             * Set the same given element value for each elements in the local AutoNumeric element list, and format those elements immediately\n             *\n             * @param {number|string} newValue The value must be a number or a numeric string\n             * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.\n             */\n            set: function set(newValue) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.set(newValue, options);\n                });\n            },\n\n            /**\n             * Set the value given value directly as the DOM element value, without formatting it beforehand.\n             * This sets the same unformatted value for each elements in the local AutoNumeric element list.\n             *\n             * @param {number|string} value\n             * @param {object} options\n             */\n            setUnformatted: function setUnformatted(value) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.setUnformatted(value, options);\n                });\n            },\n\n            /**\n             * This is an alias of the `getNumericString()` function, and should not be used anymore.\n             *\n             * @returns {Array<string>}\n             * @deprecated\n             */\n            get: function get() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.get());\n                });\n\n                return result;\n            },\n\n            /**\n             * Return an array of the unformatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list\n             *\n             * @returns {Array<string>}\n             */\n            getNumericString: function getNumericString() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getNumericString());\n                });\n\n                return result;\n            },\n\n            /**\n             * Return an array of the current formatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list\n             *\n             * @returns {Array<string>}\n             */\n            getFormatted: function getFormatted() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getFormatted());\n                });\n\n                return result;\n            },\n\n            /**\n             * Return an array of the element unformatted values (as a real Javascript number), for each element of the local AutoNumeric element list\n             *\n             * @returns {Array<number>}\n             */\n            getNumber: function getNumber() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getNumber());\n                });\n\n                return result;\n            },\n\n            /**\n             * Returns the unformatted values (following the `outputFormat` setting) of each element of the local AutoNumeric element list into an array\n             *\n             * @returns {Array<string>}\n             */\n            getLocalized: function getLocalized() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getLocalized());\n                });\n\n                return result;\n            },\n\n            /**\n             * Force each element of the local AutoNumeric element list to reformat its value\n             */\n            reformat: function reformat() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.reformat();\n                });\n            },\n\n            /**\n             * Remove the formatting and keep only the raw unformatted value (as a numericString) in each elements of the local AutoNumeric element list\n             */\n            unformat: function unformat() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.unformat();\n                });\n            },\n\n            /**\n             * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed\n             *\n             * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n             */\n            unformatLocalized: function unformatLocalized() {\n                var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.unformatLocalized(forcedOutputFormat);\n                });\n            },\n\n            /**\n             * Updates the AutoNumeric settings, and immediately format the elements accordingly, for each elements of the local AutoNumeric element list\n             *\n             * @param {object} newOptions This can be either one or more option objects\n             */\n            update: function update() {\n                for (var _len = arguments.length, newOptions = Array(_len), _key = 0; _key < _len; _key++) {\n                    newOptions[_key] = arguments[_key];\n                }\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.update.apply(aNObject, newOptions);\n                });\n            },\n\n            /**\n             * Return `true` is *all* the autoNumeric-managed elements are pristine, if their raw value hasn't changed.\n             * By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).\n             *\n             * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one. If set to `false`, this also checks that the formatted value hasn't changed.\n             * @returns {boolean}\n             */\n            isPristine: function isPristine() {\n                var checkOnlyRawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n                var isPristine = true;\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    if (isPristine && !aNObject.isPristine(checkOnlyRawValue)) {\n                        isPristine = false;\n                    }\n                });\n\n                return isPristine;\n            },\n\n            /**\n             * Execute the `clear()` method on each AutoNumeric object in the local AutoNumeric element list\n             *\n             * @param {boolean} forceClearAll\n             */\n            clear: function clear() {\n                var forceClearAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.clear(forceClearAll);\n                });\n            },\n\n            /**\n             * Execute the `remove()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            remove: function remove() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.remove();\n                });\n            },\n\n            /**\n             * Execute the `wipe()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            wipe: function wipe() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.wipe();\n                });\n            },\n\n            /**\n             * Execute the `nuke()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            nuke: function nuke() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.nuke();\n                });\n            },\n\n            /**\n             * Return `true` if the given AutoNumeric object (or DOM element) is in the local AutoNumeric element list\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             * @returns {*}\n             */\n            has: function has(domElementOrAutoNumericObject) {\n                var result = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    result = _this.autoNumericLocalList.has(domElementOrAutoNumericObject.node());\n                } else {\n                    result = _this.autoNumericLocalList.has(domElementOrAutoNumericObject);\n                }\n\n                return result;\n            },\n\n            /**\n             * Add an existing AutoNumeric object (or DOM element) to the local AutoNumeric element list, using the DOM element as the key.\n             * This manages the case where `addObject` is used on an AutoNumeric object that already has multiple elements in its local list.\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             */\n            addObject: function addObject(domElementOrAutoNumericObject) {\n                // Start with the same data, whatever the user passed as arguments\n                var domElement = void 0;\n                var otherAutoNumericObject = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    domElement = domElementOrAutoNumericObject.node();\n                    otherAutoNumericObject = domElementOrAutoNumericObject;\n                } else {\n                    domElement = domElementOrAutoNumericObject;\n                    otherAutoNumericObject = AutoNumeric.getAutoNumericElement(domElementOrAutoNumericObject);\n                }\n\n                // Check if the current autoNumeric object has a local list\n                if (!_this._hasLocalList()) {\n                    _this._createLocalList();\n                }\n\n                // Check if the other autoNumeric object has a local list...\n                var otherANLocalList = otherAutoNumericObject._getLocalList();\n                if (otherANLocalList.size === 0) {\n                    // Special case if the other AutoNumeric object has an empty local list, then populate itself to it\n                    otherAutoNumericObject._createLocalList();\n                    otherANLocalList = otherAutoNumericObject._getLocalList(); // Update the other local list\n                }\n\n                var mergedLocalLists = void 0;\n                if (otherANLocalList instanceof Map) {\n                    // ...If it does, merge the local lists together\n                    mergedLocalLists = _AutoNumericHelper2.default.mergeMaps(_this._getLocalList(), otherANLocalList);\n                } else {\n                    // ...If not, just set the current local list onto the other AutoNumeric object\n                    // We need to specify the AutoNumeric object, otherwise the `_addToLocalList` function would not correctly add the AutoNumeric object since we would not have a reference to it, but a reference to the current AutoNumeric object on which is called this method.\n                    _this._addToLocalList(domElement, otherAutoNumericObject);\n                    mergedLocalLists = _this._getLocalList();\n                }\n\n                // Update the resulting list, on all the objects of that local list (so that we can indifferently use `init()` on any object belonging to that list)\n                mergedLocalLists.forEach(function (aNObject) {\n                    aNObject._setLocalList(mergedLocalLists);\n                });\n            },\n\n            /**\n             * Remove the given AutoNumeric object (or DOM element) from the local AutoNumeric element list, using the DOM element as the key.\n             * If this function attempts to remove the current AutoNumeric object from the local list, a warning is shown, but the deletion is still done.\n             *\n             * Special cases :\n             * - If the current object removes itself, then it's removed from the shared local list, then a new empty local list is used/created\n             * - If another object remove this object, then a local list with only this object is used/created\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             * @param {boolean} keepCurrentANObject If set to `false`, then the function will also remove the current AutoNumeric object if asked, otherwise it will ignore it and print a warning message\n             */\n            removeObject: function removeObject(domElementOrAutoNumericObject) {\n                var keepCurrentANObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n                // Start with the same data, whatever the user passed as arguments\n                var domElement = void 0;\n                var otherAutoNumericObject = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    domElement = domElementOrAutoNumericObject.node();\n                    otherAutoNumericObject = domElementOrAutoNumericObject;\n                } else {\n                    domElement = domElementOrAutoNumericObject;\n                    otherAutoNumericObject = AutoNumeric.getAutoNumericElement(domElementOrAutoNumericObject);\n                }\n\n                // Remove the other object from the local list\n                var initialCompleteLocalList = _this.autoNumericLocalList;\n                _this.autoNumericLocalList.delete(domElement);\n\n                // Update the local list for all objects in it\n                initialCompleteLocalList.forEach(function (aNObject) {\n                    aNObject._setLocalList(_this.autoNumericLocalList);\n                });\n\n                if (!keepCurrentANObject && domElement === _this.node()) {\n                    // This object is removed by itself\n                    // Empty the object local list\n                    otherAutoNumericObject._setLocalList(new Map());\n                } else {\n                    // This object is removed by another object\n                    // Set the local list for the removed object, with only this object in it\n                    otherAutoNumericObject._createLocalList();\n                }\n            },\n\n            /**\n             * Remove all elements from the shared list, effectively emptying it.\n             * This is the equivalent of calling `detach()` on each of its elements.\n             *\n             * @param {boolean} keepEachANObjectInItsOwnList If set to `true`, then instead of completely emptying the local list of each AutoNumeric objects, each one of those keeps itself in its own local list\n             */\n            empty: function empty() {\n                var keepEachANObjectInItsOwnList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n                var initialCompleteLocalList = _this.autoNumericLocalList;\n\n                // Update the local list for all objects in it\n                initialCompleteLocalList.forEach(function (aNObject) {\n                    if (keepEachANObjectInItsOwnList) {\n                        aNObject._createLocalList();\n                    } else {\n                        aNObject._setLocalList(new Map());\n                    }\n                });\n            },\n\n            /**\n             * Return an array containing all the AutoNumeric DOM elements that have been initialized by each other\n             *\n             * @returns {Array<HTMLElement>}\n             */\n            elements: function elements() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.node());\n                });\n\n                return result;\n            },\n\n            /**\n             * Return the `Map` object directly\n             * @returns {Map}\n             */\n            getList: function getList() {\n                return _this.autoNumericLocalList;\n            },\n\n            /**\n             * Return the number of element in the local AutoNumeric element list\n             * @returns {number}\n             */\n            size: function size() {\n                return _this.autoNumericLocalList.size;\n            }\n        };\n\n        // Create the functions that will allow to change each setting one by one\n        /**\n         * For each options, we define if we need to reformat the element content (does changing the options should change the way its value is displayed?).\n         * If yes, then we use the `update()` for force a reformat, otherwise, we just update the `settings` object.\n         */\n        this.options = {\n            /**\n             * Reset any options set previously, by overwriting them with the default settings\n             *\n             * @returns {AutoNumeric}\n             */\n            reset: function reset() {\n                delete _this.settings;\n                _this.settings = {};\n                _this.update(AutoNumeric.defaultSettings);\n\n                return _this;\n            },\n            allowDecimalPadding: function allowDecimalPadding(_allowDecimalPadding) {\n                _this.update({ allowDecimalPadding: _allowDecimalPadding });\n\n                return _this;\n            },\n            caretPositionOnFocus: function caretPositionOnFocus(_caretPositionOnFocus) {\n                //FIXME à tester\n                _this.settings.caretPositionOnFocus = _caretPositionOnFocus;\n\n                return _this;\n            },\n            createLocalList: function createLocalList(_createLocalList2) {\n                _this.settings.createLocalList = _createLocalList2;\n\n                // Delete the local list when this is set to `false`, create it if this is set to `true` and there is not pre-existing list\n                if (_this.settings.createLocalList) {\n                    if (!_this._hasLocalList()) {\n                        _this._createLocalList();\n                    }\n                } else {\n                    _this._deleteLocalList();\n                }\n\n                return _this;\n            },\n            currencySymbol: function currencySymbol(_currencySymbol) {\n                _this.update({ currencySymbol: _currencySymbol });\n\n                return _this;\n            },\n            currencySymbolPlacement: function currencySymbolPlacement(_currencySymbolPlacement) {\n                _this.update({ currencySymbolPlacement: _currencySymbolPlacement });\n\n                return _this;\n            },\n            decimalCharacter: function decimalCharacter(_decimalCharacter) {\n                _this.update({ decimalCharacter: _decimalCharacter });\n\n                return _this;\n            },\n            decimalCharacterAlternative: function decimalCharacterAlternative(_decimalCharacterAlternative) {\n                _this.settings.decimalCharacterAlternative = _decimalCharacterAlternative;\n\n                return _this;\n            },\n            decimalPlacesOverride: function decimalPlacesOverride(_decimalPlacesOverride) {\n                _this.update({ decimalPlacesOverride: _decimalPlacesOverride });\n\n                return _this;\n            },\n            decimalPlacesShownOnFocus: function decimalPlacesShownOnFocus(_decimalPlacesShownOnFocus) {\n                _this.update({ decimalPlacesShownOnFocus: _decimalPlacesShownOnFocus });\n\n                return _this;\n            },\n            defaultValueOverride: function defaultValueOverride(_defaultValueOverride) {\n                _this.update({ defaultValueOverride: _defaultValueOverride });\n\n                return _this;\n            },\n            digitalGroupSpacing: function digitalGroupSpacing(_digitalGroupSpacing) {\n                _this.update({ digitalGroupSpacing: _digitalGroupSpacing });\n\n                return _this;\n            },\n            digitGroupSeparator: function digitGroupSeparator(_digitGroupSeparator) {\n                _this.update({ digitGroupSeparator: _digitGroupSeparator });\n\n                return _this;\n            },\n            emptyInputBehavior: function emptyInputBehavior(_emptyInputBehavior) {\n                _this.update({ emptyInputBehavior: _emptyInputBehavior });\n\n                return _this;\n            },\n            failOnUnknownOption: function failOnUnknownOption(_failOnUnknownOption) {\n                _this.settings.failOnUnknownOption = _failOnUnknownOption; //FIXME à tester\n\n                return _this;\n            },\n            formatOnPageLoad: function formatOnPageLoad(_formatOnPageLoad) {\n                _this.settings.formatOnPageLoad = _formatOnPageLoad; //FIXME à tester\n\n                return _this;\n            },\n            isCancellable: function isCancellable(_isCancellable) {\n                _this.settings.isCancellable = _isCancellable; //FIXME à tester\n\n                return _this;\n            },\n            leadingZero: function leadingZero(_leadingZero) {\n                _this.update({ leadingZero: _leadingZero });\n\n                return _this;\n            },\n            maximumValue: function maximumValue(_maximumValue) {\n                _this.update({ maximumValue: _maximumValue });\n\n                return _this;\n            },\n            minimumValue: function minimumValue(_minimumValue) {\n                _this.update({ minimumValue: _minimumValue });\n\n                return _this;\n            },\n            modifyValueOnWheel: function modifyValueOnWheel(_modifyValueOnWheel) {\n                _this.settings.modifyValueOnWheel = _modifyValueOnWheel; //FIXME à tester\n\n                return _this;\n            },\n            negativeBracketsTypeOnBlur: function negativeBracketsTypeOnBlur(_negativeBracketsTypeOnBlur) {\n                _this.update({ negativeBracketsTypeOnBlur: _negativeBracketsTypeOnBlur });\n\n                return _this;\n            },\n            negativePositiveSignPlacement: function negativePositiveSignPlacement(_negativePositiveSignPlacement) {\n                _this.update({ negativePositiveSignPlacement: _negativePositiveSignPlacement });\n\n                return _this;\n            },\n            noEventListeners: function noEventListeners(_noEventListeners) {\n                //FIXME à tester\n                if (_noEventListeners === AutoNumeric.options.noEventListeners.noEvents && _this.settings.noEventListeners === AutoNumeric.options.noEventListeners.addEvents) {\n                    // Remove the events once\n                    _this._removeEventListeners();\n                }\n\n                _this.update({ noEventListeners: _noEventListeners });\n\n                return _this;\n            },\n            noSeparatorOnFocus: function noSeparatorOnFocus(_noSeparatorOnFocus) {\n                _this.update({ noSeparatorOnFocus: _noSeparatorOnFocus });\n\n                return _this;\n            },\n            onInvalidPaste: function onInvalidPaste(_onInvalidPaste) {\n                _this.settings.onInvalidPaste = _onInvalidPaste; //FIXME à tester\n\n                return _this;\n            },\n            outputFormat: function outputFormat(_outputFormat) {\n                _this.settings.outputFormat = _outputFormat;\n\n                return _this;\n            },\n            overrideMinMaxLimits: function overrideMinMaxLimits(_overrideMinMaxLimits) {\n                _this.update({ overrideMinMaxLimits: _overrideMinMaxLimits });\n\n                return _this;\n            },\n            readOnly: function readOnly(_readOnly) {\n                //FIXME à tester\n                _this.settings.readOnly = _readOnly;\n                _this._setReadOnly();\n\n                return _this;\n            },\n            roundingMethod: function roundingMethod(_roundingMethod) {\n                _this.update({ roundingMethod: _roundingMethod });\n\n                return _this;\n            },\n            saveValueToSessionStorage: function saveValueToSessionStorage(_saveValueToSessionStorage) {\n                _this.update({ saveValueToSessionStorage: _saveValueToSessionStorage });\n\n                return _this;\n            },\n            scaleDecimalPlaces: function scaleDecimalPlaces(_scaleDecimalPlaces) {\n                _this.update({ scaleDecimalPlaces: _scaleDecimalPlaces });\n\n                return _this;\n            },\n            scaleDivisor: function scaleDivisor(_scaleDivisor) {\n                _this.update({ scaleDivisor: _scaleDivisor });\n\n                return _this;\n            },\n            scaleSymbol: function scaleSymbol(_scaleSymbol) {\n                _this.update({ scaleSymbol: _scaleSymbol });\n\n                return _this;\n            },\n            selectNumberOnly: function selectNumberOnly(_selectNumberOnly) {\n                _this.settings.selectNumberOnly = _selectNumberOnly; //FIXME à tester\n\n                return _this;\n            },\n            selectOnFocus: function selectOnFocus(_selectOnFocus) {\n                _this.settings.selectOnFocus = _selectOnFocus; //FIXME à tester\n\n                return _this;\n            },\n            serializeSpaces: function serializeSpaces(_serializeSpaces) {\n                _this.settings.serializeSpaces = _serializeSpaces; //FIXME à tester\n\n                return _this;\n            },\n            showPositiveSign: function showPositiveSign(_showPositiveSign) {\n                _this.update({ showPositiveSign: _showPositiveSign });\n\n                return _this;\n            },\n            showWarnings: function showWarnings(_showWarnings) {\n                _this.settings.showWarnings = _showWarnings; //FIXME à tester\n\n                return _this;\n            },\n            styleRules: function styleRules(_styleRules) {\n                _this.update({ styleRules: _styleRules });\n\n                return _this;\n            },\n            suffixText: function suffixText(_suffixText) {\n                _this.update({ suffixText: _suffixText });\n\n                return _this;\n            },\n            unformatOnHover: function unformatOnHover(_unformatOnHover) {\n                _this.settings.unformatOnHover = _unformatOnHover; //FIXME à tester\n\n                return _this;\n            },\n            unformatOnSubmit: function unformatOnSubmit(_unformatOnSubmit) {\n                _this.settings.unformatOnSubmit = _unformatOnSubmit; //FIXME à tester\n\n                return _this;\n            },\n            wheelStep: function wheelStep(_wheelStep) {\n                _this.settings.wheelStep = _wheelStep; //FIXME à tester\n\n                return _this;\n            }\n        };\n    }\n\n    /**\n     * Return the autoNumeric version number (for debugging purpose)\n     *\n     * @returns {string}\n     */\n\n\n    _createClass(AutoNumeric, [{\n        key: '_saveInitialValues',\n\n\n        /**\n         * Save the initial element values for later use in the pristine test.\n         * Those values are :\n         * - the html attribute (ie. <input value='42'>), and\n         * - the script `value` (ie. `let domElement.value`)\n         *\n         * @param {null|number|string} initialValue\n         * @private\n         */\n        value: function _saveInitialValues(initialValue) {\n            // Keep the very first initial values (in the html attribute and set by the script). This is needed to check if the element is pristine.\n            // Save the html attribute 'value'\n            this.initialValueHtmlAttribute = this.domElement.getAttribute('value');\n            if (_AutoNumericHelper2.default.isNull(this.initialValueHtmlAttribute)) {\n                // Set the default empty value attribute instead of `null`, since if the initial value is null, the empty string is used\n                this.initialValueHtmlAttribute = '';\n            }\n\n            // Save the 'script' value\n            this.initialValue = initialValue;\n            if (_AutoNumericHelper2.default.isNull(this.initialValue)) {\n                // Same as above\n                this.initialValue = '';\n            }\n        }\n\n        /**\n         * Generate all the event listeners for the given DOM element\n         * @private\n         */\n\n    }, {\n        key: '_createEventListeners',\n        value: function _createEventListeners() {\n            var _this2 = this;\n\n            // Create references to the event handler functions, so we can then cleanly removes those listeners if needed\n            // That would not be possible if we used closures directly in the event handler declarations\n            this._onFocusInFunc = function (e) {\n                _this2._onFocusIn(e);\n            };\n            this._onFocusInAndMouseEnterFunc = function (e) {\n                _this2._onFocusInAndMouseEnter(e);\n            };\n            this._onFocusFunc = function () {\n                _this2._onFocus();\n            };\n            this._onKeydownFunc = function (e) {\n                _this2._onKeydown(e);\n            };\n            this._onKeypressFunc = function (e) {\n                _this2._onKeypress(e);\n            };\n            this._onInputFunc = function (e) {\n                _this2._onInput(e);\n            };\n            this._onKeyupFunc = function (e) {\n                _this2._onKeyup(e);\n            };\n            this._onBlurFunc = function (e) {\n                _this2._onBlur(e);\n            };\n            this._onFocusOutAndMouseLeaveFunc = function (e) {\n                _this2._onFocusOutAndMouseLeave(e);\n            };\n            this._onPasteFunc = function (e) {\n                _this2._onPaste(e);\n            };\n            this._onWheelFunc = function (e) {\n                _this2._onWheel(e);\n            };\n            this._onFormSubmitFunc = function (e) {\n                _this2._onFormSubmit(e);\n            };\n            this._onKeydownGlobalFunc = function (e) {\n                _this2._onKeydownGlobal(e);\n            };\n            this._onKeyupGlobalFunc = function (e) {\n                _this2._onKeyupGlobal(e);\n            };\n            this._onDropFunc = function (e) {\n                _this2._onDrop(e);\n            };\n\n            // Add the event listeners\n            this.domElement.addEventListener('focusin', this._onFocusInFunc, false);\n            this.domElement.addEventListener('focus', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.addEventListener('focus', this._onFocusFunc, false);\n            this.domElement.addEventListener('mouseenter', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.addEventListener('keydown', this._onKeydownFunc, false);\n            this.domElement.addEventListener('keypress', this._onKeypressFunc, false);\n            this.domElement.addEventListener('input', this._onInputFunc, false);\n            this.domElement.addEventListener('keyup', this._onKeyupFunc, false);\n            this.domElement.addEventListener('blur', this._onBlurFunc, false);\n            this.domElement.addEventListener('blur', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.addEventListener('mouseleave', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.addEventListener('paste', this._onPasteFunc, false);\n            this.domElement.addEventListener('wheel', this._onWheelFunc, false);\n            this.domElement.addEventListener('drop', this._onDropFunc, false);\n\n            var parentForm = this.form();\n            if (!_AutoNumericHelper2.default.isNull(parentForm)) {\n                parentForm.addEventListener('submit.autoNumeric', this._onFormSubmitFunc, false); //FIXME à tester\n            }\n\n            // Create one global event listener for the keyup event on the document object, which will be shared by all the autoNumeric elements\n            if (!AutoNumeric._doesGlobalListExists()) {\n                document.addEventListener('keydown', this._onKeydownGlobalFunc, false);\n                document.addEventListener('keyup', this._onKeyupGlobalFunc, false);\n            }\n        }\n\n        /**\n         * Remove all the autoNumeric-related event listeners for the given DOM element\n         * @private\n         */\n\n    }, {\n        key: '_removeEventListeners',\n        value: function _removeEventListeners() {\n            //FIXME à tester\n            this.domElement.removeEventListener('focusin', this._onFocusInFunc, false);\n            this.domElement.removeEventListener('focus', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.removeEventListener('focus', this._onFocusFunc, false);\n            this.domElement.removeEventListener('mouseenter', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.removeEventListener('blur', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.removeEventListener('mouseleave', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.removeEventListener('keydown', this._onKeydownFunc, false);\n            this.domElement.removeEventListener('keypress', this._onKeypressFunc, false);\n            this.domElement.removeEventListener('input', this._onInputFunc, false);\n            this.domElement.removeEventListener('keyup', this._onKeyupFunc, false);\n            this.domElement.removeEventListener('blur', this._onBlurFunc, false);\n            this.domElement.removeEventListener('paste', this._onPasteFunc, false);\n            this.domElement.removeEventListener('wheel', this._onWheelFunc, false);\n\n            document.removeEventListener('keydown', this._onKeydownGlobalFunc, false);\n            document.removeEventListener('keyup', this._onKeyupGlobalFunc, false);\n\n            var parentForm = this.form();\n            if (!_AutoNumericHelper2.default.isNull(parentForm)) {\n                parentForm.removeEventListener('submit.autoNumeric', this._onFormSubmitFunc, false);\n            }\n        }\n\n        /**\n         * Set the element attribute 'readonly' according to the current settings.\n         *\n         * @private\n         */\n\n    }, {\n        key: '_setReadOnly',\n        value: function _setReadOnly() {\n            if (this.isInputElement && this.settings.readOnly) {\n                this.domElement.readOnly = true;\n            }\n        }\n\n        /**\n         * Save the current raw value into the history table, along with the selection information.\n         *\n         * If the user has done some undos and tries to enter:\n         * - a new and different number than the 'next' state, this drops the rest of the history table\n         * - the very same number that result in the same rawValue than the 'next' state, we only move the history table pointer to the next state\n         *\n         * @private\n         */\n\n    }, {\n        key: '_historyTableAdd',\n        value: function _historyTableAdd() {\n            //TODO Add a `this.settings.saveSelectionsIntoHistory` option to prevent saving the selections (in order to gain performance)\n            var isEmptyHistoryTable = this.historyTable.length === 0;\n            // Only add a new value if it's different than the previous one (to prevent infinitely adding values on mouseover for instance)\n            if (isEmptyHistoryTable || this.settings.rawValue !== this._historyTableCurrentValueUsed()) {\n                // Trim the history table if the user changed the value of an intermediary state\n                var addNewHistoryState = true;\n                if (!isEmptyHistoryTable) {\n                    // If some undo has been done and the user type the exact same data than the next entry after the current history pointer, do no drop the rest of the 'redo' list, and just advance the historyTableIndex\n                    var nextHistoryStateIndex = this.historyTableIndex + 1;\n                    if (nextHistoryStateIndex < this.historyTable.length && this.settings.rawValue === this.historyTable[nextHistoryStateIndex].value) {\n                        // If the character input result in the same state than the next one, do not remove the next history states nor add a new one\n                        addNewHistoryState = false;\n                    } else {\n                        // First remove anything that is after the current index\n                        _AutoNumericHelper2.default.arrayTrim(this.historyTable, this.historyTableIndex + 1);\n                    }\n                }\n\n                // Update the history pointer\n                this.historyTableIndex++;\n\n                // Add the new history state, if needed\n                if (addNewHistoryState) {\n                    // Save the selection info\n                    var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                    this.selectionStart = selection.start;\n                    this.selectionEnd = selection.end;\n\n                    // Then add the new raw value\n                    this.historyTable.push({\n                        // Save the rawValue and selection start/end\n                        value: this.settings.rawValue,\n                        // The selection for this element is temporary, and will be updated when the next history state will be recorded.\n                        // That way, we are always sure we save the last caret or selection positions just before the value is changed. Otherwise we would only save those positions when the value is first changed, and would not take into account that the user could move the caret around afterward.\n                        // For instance, this is needed if the user change the element value, and immediately undo it ; if he then does a redo, he'll see the value and the right selection\n                        // To sum up; The selection position are not always +1 character, since it could also be '2' if a group separator is added when entering one character. That's why the current history state caret/selection position is updated on each `keyup` event.\n                        start: this.selectionStart + 1, // Here we add one since the user added one character too\n                        end: this.selectionEnd + 1\n                    });\n\n                    // Update the selection in the previous entry, in order to keep track of the updated caret/selection positions\n                    if (this.historyTable.length > 1) {\n                        this.historyTable[this.historyTableIndex - 1].start = this.selectionStart;\n                        this.historyTable[this.historyTableIndex - 1].end = this.selectionEnd;\n                    }\n                }\n\n                // Limit the history table size according to the `historySize` option\n                if (this.historyTable.length > this.settings.historySize) {\n                    this._historyTableForget();\n                }\n            }\n        }\n\n        /**\n         * Debug function for the history table\n         * @private\n         */\n        /*\n        _debugHistoryTable() {\n            let i = 0;\n            let mark;\n            this.historyTable.forEach(history => {\n                if (this.historyTableIndex === i) {\n                    mark = '> ';\n                } else {\n                    mark = '';\n                }\n                console.log(`${mark}${i++}: ${history.value} ${history.start}|${history.end} [onGoingRedo: ${this.onGoingRedo}]`); //DEBUG\n            });\n        }\n        */\n\n        /**\n         * 'Undo' or 'Redo' the last/next user entry in the history table.\n         * This does not modify the history table, only the pointer to the current state.\n         *\n         * @param {boolean} undo If set to `true`, then this function does an 'Undo', otherwise it does a 'Redo'\n         * @private\n         */\n\n    }, {\n        key: '_historyTableUndoOrRedo',\n        value: function _historyTableUndoOrRedo() {\n            var undo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            var check = void 0;\n            if (undo) {\n                // Only 'undo' if there are some info to undo\n                check = this.historyTableIndex > 0;\n                if (check) {\n                    this.historyTableIndex--;\n                }\n            } else {\n                // Only 'redo' if there are some info to redo at the end of the history table\n                check = this.historyTableIndex + 1 < this.historyTable.length;\n                if (check) {\n                    this.historyTableIndex++;\n                }\n            }\n\n            if (check) {\n                // Set the value back\n                var undoInfo = this.historyTable[this.historyTableIndex];\n                this.set(undoInfo.value, null, false); // next or previous raw value\n\n                // Set the selection back\n                _AutoNumericHelper2.default.setElementSelection(this.domElement, undoInfo.start, undoInfo.end);\n            }\n        }\n\n        /**\n         * 'Undo' the last user entry by going back one entry in the history table.\n         * This keeps the following entries in order to allow for a 'redo'.\n         * This does not modify the history table, only the pointer to the current state.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableUndo',\n        value: function _historyTableUndo() {\n            this._historyTableUndoOrRedo(true);\n        }\n\n        /**\n         * 'Redo' the next user entry in the history table.\n         * This does not modify the history table, only the pointer to the current state.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableRedo',\n        value: function _historyTableRedo() {\n            this._historyTableUndoOrRedo(false);\n        }\n\n        /**\n         * Reset the history table to its initial state, and select the value.\n         * @private\n         */\n        /*\n        resetHistoryTable() { //FIXME Test this\n            this.set(this.settings.rawValue, null, false);\n            this.select();\n            const selection = AutoNumericHelper.getElementSelection(this.domElement);\n            this.historyTableIndex = 0;\n            this.historyTable = [{\n                // Save the rawValue and selection start/end\n                value: this.settings.rawValue,\n                start: selection.start,\n                end  : selection.end,\n            }];\n        }\n        */\n\n        /**\n         * Make the history table forget its first N elements, shifting its indexes in the process.\n         * `N` being given as the `numberOfEntriesToForget` parameter.\n         *\n         * @param {Number} numberOfEntriesToForget\n         * @returns {object|Array<object>} The discarded objects, in an Array.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableForget',\n        value: function _historyTableForget() {\n            var numberOfEntriesToForget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            var shiftedAway = [];\n            for (var i = 0; i < numberOfEntriesToForget; i++) {\n                shiftedAway.push(this.historyTable.shift());\n                // Update the history table index accordingly\n                this.historyTableIndex--;\n                if (this.historyTableIndex < 0) {\n                    // In case this function is called more times than there is states in the history table\n                    this.historyTableIndex = 0;\n                }\n            }\n\n            if (shiftedAway.length === 1) {\n                return shiftedAway[0];\n            }\n\n            return shiftedAway;\n        }\n\n        /**\n         * Return the currently used value from the history table.\n         *\n         * @returns {string|number}\n         * @private\n         */\n\n    }, {\n        key: '_historyTableCurrentValueUsed',\n        value: function _historyTableCurrentValueUsed() {\n            var indexToUse = this.historyTableIndex;\n            if (indexToUse < 0) {\n                indexToUse = 0;\n            }\n\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.historyTable[indexToUse])) {\n                result = '';\n            } else {\n                result = this.historyTable[indexToUse].value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Parse the `styleRules` option and run the test for each given rules, either pre-defined ones like `positive`, `negative` and `ranges`, or user defined callbacks within the `userDefined` attribute.\n         * @private\n         */\n\n    }, {\n        key: '_parseStyleRules',\n        value: function _parseStyleRules() {\n            var _this3 = this;\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules) || this.settings.rawValue === '') {\n                return;\n            }\n\n            // 'positive' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.positive)) {\n                if (this.settings.rawValue >= 0) {\n                    this._addCSSClass(this.settings.styleRules.positive);\n                } else {\n                    this._removeCSSClass(this.settings.styleRules.positive);\n                }\n            }\n\n            // 'negative' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.negative)) {\n                if (this.settings.rawValue < 0) {\n                    this._addCSSClass(this.settings.styleRules.negative);\n                } else {\n                    this._removeCSSClass(this.settings.styleRules.negative);\n                }\n            }\n\n            // 'ranges' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.ranges) && this.settings.styleRules.ranges.length !== 0) {\n                this.settings.styleRules.ranges.forEach(function (range) {\n                    if (_this3.settings.rawValue >= range.min && _this3.settings.rawValue < range.max) {\n                        _this3._addCSSClass(range.class);\n                    } else {\n                        _this3._removeCSSClass(range.class);\n                    }\n                });\n            }\n\n            // 'userDefined' attribute\n            //TODO Also pass the old raw value as a parameter, and not only the new raw value\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.userDefined) && this.settings.styleRules.userDefined.length !== 0) {\n                this.settings.styleRules.userDefined.forEach(function (userObject) {\n                    if (_AutoNumericHelper2.default.isFunction(userObject.callback)) {\n                        // Test for the type of the `classes` attribute, which changes the function behavior\n                        if (_AutoNumericHelper2.default.isString(userObject.classes)) {\n                            // If 'classes' is a string, set it if `true`, remove it if `false`\n                            if (userObject.callback(_this3.settings.rawValue)) {\n                                _this3._addCSSClass(userObject.classes);\n                            } else {\n                                _this3._removeCSSClass(userObject.classes);\n                            }\n                        } else if (_AutoNumericHelper2.default.isArray(userObject.classes)) {\n                            if (userObject.classes.length === 2) {\n                                // If 'classes' is an array with only 2 elements, set the first class if `true`, the second if `false`\n                                if (userObject.callback(_this3.settings.rawValue)) {\n                                    _this3._addCSSClass(userObject.classes[0]);\n                                    _this3._removeCSSClass(userObject.classes[1]);\n                                } else {\n                                    _this3._removeCSSClass(userObject.classes[0]);\n                                    _this3._addCSSClass(userObject.classes[1]);\n                                }\n                            } else if (userObject.classes.length > 2) {\n                                (function () {\n                                    // The callback returns an array of indexes to use on the `classes` array\n                                    var callbackResult = userObject.callback(_this3.settings.rawValue);\n                                    if (_AutoNumericHelper2.default.isArray(callbackResult)) {\n                                        // If multiple indexes are returned\n                                        userObject.classes.forEach(function (userClass, index) {\n                                            if (_AutoNumericHelper2.default.isInArray(index, callbackResult)) {\n                                                _this3._addCSSClass(userClass);\n                                            } else {\n                                                _this3._removeCSSClass(userClass);\n                                            }\n                                        });\n                                    } else if (_AutoNumericHelper2.default.isInt(callbackResult)) {\n                                        // If only one index is returned\n                                        userObject.classes.forEach(function (userClass, index) {\n                                            if (index === callbackResult) {\n                                                _this3._addCSSClass(userClass);\n                                            } else {\n                                                _this3._removeCSSClass(userClass);\n                                            }\n                                        });\n                                    } else if (_AutoNumericHelper2.default.isNull(callbackResult)) {\n                                        // Remove all the classes\n                                        userObject.classes.forEach(function (userClass) {\n                                            _this3._removeCSSClass(userClass);\n                                        });\n                                    } else {\n                                        _AutoNumericHelper2.default.throwError('The callback result is not an array nor a valid array index, ' + (typeof callbackResult === 'undefined' ? 'undefined' : _typeof(callbackResult)) + ' given.');\n                                    }\n                                })();\n                            } else {\n                                _AutoNumericHelper2.default.throwError('The classes attribute is not valid for the `styleRules` option.');\n                            }\n                        } else if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(userObject.classes)) {\n                            // If 'classes' is `undefined` or `null`, then the callback is called with the AutoNumeric object passed as a parameter\n                            userObject.callback(_this3);\n                        } else {\n                            _AutoNumericHelper2.default.throwError('The callback/classes structure is not valid for the `styleRules` option.');\n                        }\n                    } else {\n                        _AutoNumericHelper2.default.warning('The given `styleRules` callback is not a function, ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) + ' given.');\n                    }\n                });\n            }\n        }\n\n        /**\n         * Add the given CSS class to the DOM element.\n         *\n         * @param {string} cssClassName\n         * @private\n         */\n\n    }, {\n        key: '_addCSSClass',\n        value: function _addCSSClass(cssClassName) {\n            this.domElement.classList.add(cssClassName);\n        }\n\n        /**\n         * Remove the given CSS class from the DOM element.\n         *\n         * @param {string} cssClassName\n         * @private\n         */\n\n    }, {\n        key: '_removeCSSClass',\n        value: function _removeCSSClass(cssClassName) {\n            this.domElement.classList.remove(cssClassName);\n        }\n\n        // This are the public function available on each autoNumeric-managed element\n\n        /**\n         * Method that updates the AutoNumeric settings, and immediately format the element accordingly.\n         * The options passed as parameter(s) is either one or many objects that each contains some settings, ie. :\n         * {\n         *     digitGroupSeparator: \".\",\n         *     decimalCharacter: \",\",\n         *     currencySymbol: '€ ',\n         * }\n         * If multiple options are passed, the latter overwrite the previous ones.\n         *\n         * @example anElement.update({ options }) // Updates the settings\n         * @example anElement.update({ options1 }, { options2 }) // Updates the settings with multiple option objects\n         *\n         * @param {object} newOptions\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'update',\n        value: function update() {\n            // Store the current unformatted input value\n            var numericString = this.settings.rawValue;\n\n            // Generate a single option object with the settings from the latter overwriting those from the former\n            var optionsToUse = {};\n\n            for (var _len2 = arguments.length, newOptions = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                newOptions[_key2] = arguments[_key2];\n            }\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(newOptions) || newOptions.length === 0) {\n                optionsToUse = null;\n            } else if (newOptions.length >= 1) {\n                newOptions.forEach(function (optionObject) {\n                    _extends(optionsToUse, optionObject);\n                });\n            }\n\n            // Update the settings\n            try {\n                this._setSettings(optionsToUse, true);\n            } catch (error) {\n                _AutoNumericHelper2.default.throwError('Unable to update the settings, those are invalid.');\n\n                return this;\n            }\n\n            // Reformat the input value with the new settings\n            // Note: we always `set`, even when `numericString` is the empty string '', since `emptyInputBehavior` (set to `always` or `zero`) can change how the empty input is formatted\n            this.set(numericString);\n\n            return this;\n        }\n\n        /**\n         * Return the options object containing all the current autoNumeric settings in effect.\n         * You can then directly access each option by using its name : `anElement.getSettings().optionNameAutoCompleted`.\n         *\n         * @example\n         * anElement.getSettings()\n         * anElement.getSettings().decimalCharacter // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getSettings',\n        value: function getSettings() {\n            return this.settings;\n        }\n\n        /**\n         * Set the given element value, and format it immediately.\n         * Additionally, this `set()` method can accept options that will be merged into the current AutoNumeric element, taking precedence over any previous settings.\n         *\n         * @example anElement.set('12345.67') // Formats the value\n         * @example anElement.set(12345.67) // Formats the value\n         * @example anElement.set(12345.67, { decimalCharacter : ',' }) // Update the settings and formats the value in one go\n         *\n         * @param {number|string} newValue The value must be a number or a numeric string\n         * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history table\n         * @returns {AutoNumeric}\n         * @throws\n         */\n\n    }, {\n        key: 'set',\n        value: function set(newValue) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var saveChangeToHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            //TODO Add the `saveSettings` options. If `true`, then when `options` is passed, then it overwrite the current `this.settings`. If `false` the `options` are only used once and `this.settings` is not modified\n            if (newValue === null || _AutoNumericHelper2.default.isUndefined(newValue)) {\n                return this;\n            }\n\n            // The options update is done only if the `newValue` is not null\n            if (!_AutoNumericHelper2.default.isNull(options)) {\n                this._setSettings(options, true); // We do not call `update` here since this would call `set` too\n            }\n\n            var value = this.constructor._toNumericValue(newValue, this.settings);\n            if (isNaN(Number(value))) {\n                this.setValue('', saveChangeToHistory);\n\n                return this;\n            }\n\n            if (value === '' && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero) {\n                // Keep the value zero inside the element\n                value = 0;\n            }\n\n            if (value !== '') {\n                var _constructor$_checkIf = this.constructor._checkIfInRangeWithOverrideOption(value, this.settings),\n                    _constructor$_checkIf2 = _slicedToArray(_constructor$_checkIf, 2),\n                    minTest = _constructor$_checkIf2[0],\n                    maxTest = _constructor$_checkIf2[1];\n                // This test is needed by the showPositiveSign option\n\n\n                var isZero = _AutoNumericHelper2.default.isZeroOrHasNoValue(value);\n                if (isZero) {\n                    value = '0';\n                }\n\n                if (minTest && maxTest) {\n                    // Ensure rounding does not happen twice\n                    var hasBeenRounded = false;\n\n                    // Rounds the extended decimal places\n                    var tempDecimal = void 0;\n                    if (this.settings.decimalPlacesShownOnFocus) {\n                        tempDecimal = this.settings.decimalPlacesOverride;\n                        this.settings.decimalPlacesOverride = Number(this.settings.decimalPlacesShownOnFocus);\n                        value = this.constructor._roundValue(value, this.settings);\n                        hasBeenRounded = true;\n                        this.settings.decimalPlacesOverride = tempDecimal;\n                    }\n\n                    var rawValue = void 0;\n                    if (this.settings.scaleDivisor && !this.isFocused) {\n                        value = this.constructor._roundValue(value, this.settings);\n                        rawValue = this._trimLeadingAndTrailingZeros(value.replace(this.settings.decimalCharacter, '.')); // Move the `setRawValue` call after the `setElementValue` one\n                        value = this.constructor._toNumericValue(value, this.settings);\n                        value = value / this.settings.scaleDivisor;\n                        value = value.toString();\n\n                        if (this.settings.scaleDecimalPlaces) {\n                            tempDecimal = this.settings.decimalPlacesOverride;\n                            this.settings.decimalPlacesOverride = Number(this.settings.scaleDecimalPlaces);\n                            value = this.constructor._roundValue(value, this.settings);\n                            hasBeenRounded = true;\n                        }\n                    }\n\n                    // Rounds if this has not been done already\n                    if (!hasBeenRounded) {\n                        value = this.constructor._roundValue(value, this.settings);\n                    }\n\n                    // Stores rawValue including the decimalPlacesShownOnFocus\n                    if (!this.settings.scaleDivisor) {\n                        //TODO Find a better way to prevent potentially overwriting the `rawValue` variable (that could have already been set few lines above)\n                        rawValue = this._trimLeadingAndTrailingZeros(value.replace(this.settings.decimalCharacter, '.'));\n                    }\n\n                    value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);\n                    value = this.constructor._addGroupSeparators(value, this.settings, this.isFocused, rawValue);\n                    if (!this.isFocused && this.settings.scaleSymbol) {\n                        value = value + this.settings.scaleSymbol;\n                    }\n\n                    if (this.settings.saveValueToSessionStorage && (this.settings.decimalPlacesShownOnFocus || this.settings.scaleDivisor)) {\n                        this._saveValueToPersistentStorage('set');\n                    }\n\n                    // Set back the `decimalPlacesOverride` option to its original value\n                    if (this.settings.scaleDivisor && this.settings.scaleDecimalPlaces && !this.isFocused) {\n                        this.settings.decimalPlacesOverride = tempDecimal;\n                    }\n\n                    this._setElementAndRawValue(value, rawValue, saveChangeToHistory);\n\n                    return this;\n                } else {\n                    var attemptedValue = value;\n                    value = '';\n\n                    if (!minTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n                    }\n\n                    if (!maxTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n                    }\n\n                    _AutoNumericHelper2.default.throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + this.settings.minimumValue + '] and maximumValue [' + this.settings.maximumValue + '] range set for this element');\n\n                    this._saveValueToPersistentStorage('remove');\n                    this.setValue('', saveChangeToHistory);\n\n                    return this;\n                }\n            } else {\n                // Here, `value` equal the empty string `''`\n                var result = void 0;\n                if (this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.always) {\n                    // Keep the currency symbol as per emptyInputBehavior\n                    result = this.settings.currencySymbol;\n                } else {\n                    result = '';\n                }\n\n                this._setElementAndRawValue(result, '', saveChangeToHistory);\n\n                return this;\n            }\n        }\n\n        /**\n         * Set the given value directly as the DOM element value, without formatting it beforehand.\n         * You can also set the value and update the setting in one go (the value will again not be formatted immediately).\n         *\n         * @param {number|string} value\n         * @param {object} options\n         * @returns {AutoNumeric}\n         * @throws\n         */\n\n    }, {\n        key: 'setUnformatted',\n        value: function setUnformatted(value) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            //TODO Should we use `AutoNumeric.unformat()` here and set the unformatted result in case `value` is formatted?\n            if (value === null || _AutoNumericHelper2.default.isUndefined(value)) {\n                return this;\n            }\n\n            // The options update is done only if the `value` is not null\n            if (!_AutoNumericHelper2.default.isNull(options)) {\n                this._setSettings(options, true); // We do not call `update` here since this would call `set` too\n            }\n\n            var strippedValue = this.constructor._removeBrackets(value, this.settings);\n            var normalizedValue = this.constructor._stripAllNonNumberCharacters(strippedValue, this.settings, true, this.isFocused);\n            normalizedValue = normalizedValue.replace(this.settings.decimalCharacter, '.');\n            if (!_AutoNumericHelper2.default.isNumber(normalizedValue)) {\n                _AutoNumericHelper2.default.throwError('The value is not a valid one, it\\'s not a numeric string nor a recognized currency.');\n            }\n\n            var _constructor$_checkIf3 = this.constructor._checkIfInRangeWithOverrideOption(normalizedValue, this.settings),\n                _constructor$_checkIf4 = _slicedToArray(_constructor$_checkIf3, 2),\n                minTest = _constructor$_checkIf4[0],\n                maxTest = _constructor$_checkIf4[1];\n\n            if (minTest && maxTest) {\n                // If the `normalizedValue` is in the range\n                this.setValue(value);\n            } else {\n                _AutoNumericHelper2.default.throwError('The value is out of the range limits [' + this.settings.minimumValue + ', ' + this.settings.maximumValue + '].');\n            }\n\n            return this;\n        }\n\n        /**\n         * Set the given value directly as the DOM element value, without formatting it beforehand, and without checking its validity.\n         *\n         * @param {string|number|null} newValue The new value to set on the element\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'setValue',\n        value: function setValue(newValue) {\n            var saveChangeToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            this._setElementAndRawValue(newValue, saveChangeToHistory);\n\n            return this;\n        }\n\n        /**\n         * Save the raw value inside the AutoNumeric object.\n         *\n         * @param {number|string} rawValue The numeric value as understood by Javascript like a `Number`\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not\n         * @private\n         */\n\n    }, {\n        key: '_setRawValue',\n        value: function _setRawValue(rawValue) {\n            var saveChangeToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            // Update the raw value\n            this.settings.rawValue = rawValue;\n\n            // Change the element style or use the relevant callbacks\n            this._parseStyleRules();\n\n            if (saveChangeToHistory) {\n                // Save in the history the last known raw value and formatted result selection\n                this._historyTableAdd();\n            }\n        }\n\n        /**\n         * Set the given value on the DOM element, without affecting the `rawValue`.\n         * This send an 'autoNumeric:formatted' event if the new value is different than the old one.\n         *\n         * @param {number|string} newElementValue\n         * @returns {AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_setElementValue',\n        value: function _setElementValue(newElementValue) {\n            //TODO Use an internal attribute to track the current value of the element `formattedValue` (like its counterpart `rawValue`). This would allow us to avoid calling `getElementValue` many times\n            // `oldElementValue` is the previous value that will be overwritten. This is used to decide if an event should be sent or not.\n            var oldElementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (newElementValue !== oldElementValue) {\n                // Only update the value if it's different from the current one\n                _AutoNumericHelper2.default.setElementValue(this.domElement, newElementValue);\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, this.domElement, { oldValue: oldElementValue, newValue: newElementValue });\n            }\n\n            return this;\n        }\n\n        /**\n         * Set the given value on the DOM element, and the raw value on `this.settings.rawValue`, if both are given.\n         * If only one value is given, then both the DOM element value and the raw value are set with that value.\n         * The third argument `saveChangeToHistory` defines if the change should be recorded in the history array.\n         * Note: if the second argument `rawValue` is a boolean, we consider that is really is the `saveChangeToHistory` argument.\n         *\n         * @param {number|string} newElementValue\n         * @param {number|string|null|boolean} rawValue\n         * @param {boolean} saveChangeToHistory\n         * @returns {AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_setElementAndRawValue',\n        value: function _setElementAndRawValue(newElementValue) {\n            var rawValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var saveChangeToHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (_AutoNumericHelper2.default.isNull(rawValue)) {\n                rawValue = newElementValue;\n            } else if (_AutoNumericHelper2.default.isBoolean(rawValue)) {\n                saveChangeToHistory = rawValue;\n                rawValue = newElementValue;\n            }\n\n            //XXX The order here is important ; the value should first be set on the element, then and only then we should update the raw value\n            // In the `set()` function, we make sure to call `_setRawValue` *after* `setElementValue` so that if `_setRawValue` calls a callback that modify the `rawValue`, then the new value is set correctly (after `setElementValue` briefly set its value first)\n            this._setElementValue(newElementValue);\n            this._setRawValue(rawValue, saveChangeToHistory);\n\n            return this;\n        }\n\n        /**\n         * Alias of the `getNumericString()` function.\n         * Developers should use one of the more explicit function names to get what they want :\n         * - a numeric string : `getNumericString()`\n         * - a formatted string : `getFormatted()`\n         * - a number : `getNumber()`, or\n         * - a localized numeric string : `getLocalized()`\n         *\n         * @usage anElement.get();\n         *\n         * @deprecated\n         * @returns {string}\n         */\n\n    }, {\n        key: 'get',\n        value: function get() {\n            return this.getNumericString();\n        }\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage anElement.getNumericString();\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'getNumericString',\n        value: function getNumericString() {\n            // Always return a numeric string\n            // The following statement gets rid of the trailing zeros in the decimal places since the current method does not pad decimals\n            return _AutoNumericHelper2.default.trimPaddedZerosFromDecimalPlaces(this.settings.rawValue);\n        }\n\n        /**\n         * Return the current formatted value of the AutoNumeric element as a string\n         *\n         * @usage anElement.getFormatted()\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'getFormatted',\n        value: function getFormatted() {\n            if (!('value' in this.domElement || 'textContent' in this.domElement)) {\n                // Make sure `.value` or `.textContent' exists before trying to access those properties\n                _AutoNumericHelper2.default.throwError('Unable to get the formatted string from the element.');\n            }\n\n            return _AutoNumericHelper2.default.getElementValue(this.domElement);\n        }\n\n        /**\n         * Return the element unformatted value as a real Javascript number.\n         * Warning: This can lead to precision problems with big numbers that should be stored as strings.\n         *\n         * @usage anElement.getNumber()\n         *\n         * @returns {number}\n         */\n\n    }, {\n        key: 'getNumber',\n        value: function getNumber() {\n            var value = this.getNumericString();\n\n            return this.constructor._toLocale(value, 'number');\n        }\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @usage anElement.getLocalized();\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {*}\n         */\n\n    }, {\n        key: 'getLocalized',\n        value: function getLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isEmptyString(this.settings.rawValue)) {\n                value = '';\n            } else {\n                // Here I use `this.settings.rawValue` instead of `this.getNumericString()` since the current input value could be unformatted with a localization (ie. '1234567,89-').\n                // I also convert the rawValue to a number, then back to a string in order to drop the decimal part if the rawValue is an integer.\n                value = '' + Number(this.settings.rawValue);\n            }\n\n            if (value !== '' && Number(value) === 0 && this.settings.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                value = '0';\n            }\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            return this.constructor._toLocale(value, outputFormatToUse);\n        }\n\n        /**\n         * Force the element to reformat its value again (just in case the formatting has been lost).\n         * This can be used right after a form submission for instance (after a previous call to `unformat`).\n         *\n         * @example anElement.reformat()\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'reformat',\n        value: function reformat() {\n            // `this.settings.rawValue` is used instead of `this.domElement.value` because when the content is `unformatLocalized`, it can become a string that cannot be converted to a number easily\n            this.set(this.settings.rawValue);\n\n            return this;\n        }\n\n        /**\n         * Remove the formatting and keep only the raw unformatted value in the element (as a numericString)\n         * Note: this is loosely based on the previous 'unSet()' function\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * @example anElement.unformat()\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'unformat',\n        value: function unformat() {\n            this._setElementValue(this.getNumericString());\n\n            return this;\n        }\n\n        /**\n         * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed\n         *\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Take a look at the `outputFormat` option definition in the default settings for more details.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'unformatLocalized',\n        value: function unformatLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._setElementValue(this.getLocalized(forcedOutputFormat));\n\n            return this;\n        }\n\n        /**\n         * Return `true` if the current value is the same as when the element got initialized.\n         * Note: By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).\n         * In order to test if the formatted value is the same (which means neither the raw value nor the settings have been changed), then you must pass `false` as its argument.\n         *\n         * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one.  If set to `false`, this also checks that the formatted value hasn't changed.\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isPristine',\n        value: function isPristine() {\n            var checkOnlyRawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            var result = void 0;\n            if (checkOnlyRawValue) {\n                result = this.initialValue === this.getNumericString();\n            } else {\n                result = this.initialValueHtmlAttribute === this.getFormatted();\n            }\n\n            return result;\n        }\n\n        /**\n         * Select the formatted element content, based on the `selectNumberOnly` option\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'select',\n        value: function select() {\n            if (this.settings.selectNumberOnly) {\n                this.selectNumber();\n            } else {\n                this._defaultSelectAll();\n            }\n\n            return this;\n        }\n\n        /**\n         * Select the whole element content (including the currency symbol).\n         * @private\n         */\n\n    }, {\n        key: '_defaultSelectAll',\n        value: function _defaultSelectAll() {\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, 0, _AutoNumericHelper2.default.getElementValue(this.domElement).length);\n        }\n\n        /**\n         * Select only the numbers in the formatted element content, leaving out the currency symbol, whatever the value of the `selectNumberOnly` option\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectNumber',\n        value: function selectNumber() {\n            //TODO Make sure the selection is ok when showPositiveSign is set to `true` (select the negative sign, but not the positive one)\n            var unformattedValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var valueLen = unformattedValue.length;\n            var currencySymbolSize = this.settings.currencySymbol.length;\n            var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n            var negLen = !_AutoNumericHelper2.default.isNegative(unformattedValue) ? 0 : 1;\n            var suffixTextLen = this.settings.suffixText.length;\n            var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n            var start = void 0;\n            if (currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                start = 0;\n            } else if (negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left && negLen === 1 && currencySymbolSize > 0) {\n                start = currencySymbolSize + 1;\n            } else {\n                start = currencySymbolSize;\n            }\n\n            var end = void 0;\n            if (currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                end = valueLen - suffixTextLen;\n            } else {\n                switch (negativePositiveSignPlacement) {\n                    case AutoNumeric.options.negativePositiveSignPlacement.left:\n                        end = valueLen - (suffixTextLen + currencySymbolSize);\n                        break;\n                    case AutoNumeric.options.negativePositiveSignPlacement.right:\n                        if (currencySymbolSize > 0) {\n                            end = valueLen - (currencySymbolSize + negLen + suffixTextLen);\n                        } else {\n                            end = valueLen - (currencySymbolSize + suffixTextLen);\n                        }\n                        break;\n                    default:\n                        end = valueLen - (currencySymbolSize + suffixTextLen);\n                }\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Select only the integer part in the formatted element content, whatever the value of `selectNumberOnly`\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectInteger',\n        value: function selectInteger() {\n            var start = 0;\n            var isPositive = this.settings.rawValue >= 0;\n\n            // Negative or positive sign, if any\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.prefix || this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.none)) {\n                if (this.settings.showPositiveSign && isPositive || // This only exclude the positive sign from being selected\n                !isPositive && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left) {\n                    // And this exclude the negative sign from being selected in this special case : '-€ 1.234,57suffixText'\n                    start = start + 1;\n                }\n            }\n\n            // Currency symbol\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                start = start + this.settings.currencySymbol.length;\n            }\n\n            // Calculate the selection end position\n            var elementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var end = elementValue.indexOf(this.settings.decimalCharacter);\n            if (end === -1) {\n                // No decimal character found\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                    end = elementValue.length - this.settings.currencySymbol.length;\n                } else {\n                    end = elementValue.length;\n                }\n\n                // Trailing negative sign\n                if (!isPositive && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix)) {\n                    end = end - 1;\n                }\n\n                // Avoid selecting the suffix test\n                end = end - this.settings.suffixText.length;\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Select only the decimal part in the formatted element content, whatever the value of `selectNumberOnly`\n         * Multiple cases are possible :\n         * +1.234,57suffixText\n         *\n         * € +1.234,57suffixText\n         * +€ 1.234,57suffixText\n         * € 1.234,57+suffixText\n         *\n         * 1.234,57+ €suffixText\n         * 1.234,57 €+suffixText\n         * +1.234,57 €suffixText\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectDecimal',\n        value: function selectDecimal() {\n            var start = _AutoNumericHelper2.default.getElementValue(this.domElement).indexOf(this.settings.decimalCharacter);\n            var end = void 0;\n\n            if (start === -1) {\n                // The decimal character has not been found, we deselect all\n                start = 0;\n                end = 0;\n            } else {\n                // A decimal character has been found\n                start = start + 1; // We add 1 to exclude the decimal character from the selection\n\n                var decimalCount = void 0;\n                if (this.settings.decimalPlacesShownOnFocus === null || this.settings.decimalPlacesShownOnFocus !== null && !this.isFocused) {\n                    decimalCount = this.settings.decimalPlacesOverride;\n                } else {\n                    decimalCount = this.settings.decimalPlacesShownOnFocus;\n                }\n\n                end = start + Number(decimalCount);\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Return the DOM element reference of the autoNumeric-managed element\n         *\n         * @returns {HTMLElement|HTMLInputElement}\n         */\n\n    }, {\n        key: 'node',\n        value: function node() {\n            return this.domElement;\n        }\n\n        /**\n         * Return the DOM element reference of the parent node of the autoNumeric-managed element\n         *\n         * @returns {HTMLElement|HTMLInputElement|Node}\n         */\n\n    }, {\n        key: 'parent',\n        value: function parent() {\n            return this.domElement.parentNode;\n        }\n\n        /**\n         * Detach the current AutoNumeric element from the shared local 'init' list.\n         * This means any changes made on that local shared list will not be transmitted to that element anymore.\n         * Note : The user can provide another AutoNumeric element, and detach this one instead of the current one.\n         *\n         * @param {AutoNumeric} otherAnElement\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach() {\n            var otherAnElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME à tester\n            var domElementToDetach = void 0;\n            if (!_AutoNumericHelper2.default.isNull(otherAnElement)) {\n                domElementToDetach = otherAnElement.node();\n            } else {\n                domElementToDetach = this.domElement;\n            }\n\n            this._removeFromLocalList(domElementToDetach); //FIXME What happens if the selected dom element does not exist in the list?\n\n            return this;\n        }\n\n        /**\n         * Attach the given AutoNumeric element to the shared local 'init' list.\n         * When doing that, by default the DOM content is left untouched.\n         * The user can force a reformat with the new shared list options by passing a second argument to `true`.\n         *\n         * @param {AutoNumeric} otherAnElement\n         * @param {boolean} reFormat\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(otherAnElement) {\n            var reFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            //FIXME à tester\n            this._addToLocalList(otherAnElement.node()); //FIXME Should we make sure the element is not already in the list?\n            if (reFormat) {\n                otherAnElement.update(this.settings);\n            }\n\n            return this;\n        }\n\n        /**\n         * Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n         *\n         * @param {number|HTMLElement|HTMLInputElement} valueOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'formatOther',\n        value: function formatOther(valueOrElement) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            return this._formatOrUnformatOther(true, valueOrElement, optionOverride);\n        }\n\n        /**\n         * Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n          * @param {string|HTMLElement|HTMLInputElement} stringOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'unformatOther',\n        value: function unformatOther(stringOrElement) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            return this._formatOrUnformatOther(false, stringOrElement, optionOverride);\n        }\n\n        /**\n         * Method that either format or unformat the value of another element.\n         *\n         * - Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.\n         * - Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.\n         *\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n         *\n         * @param {boolean} isFormatting If set to `true`, then the method formats, otherwise if set to `false`, it unformats\n         * @param {number|string|HTMLElement|HTMLInputElement} valueOrStringOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         * @private\n         */\n\n    }, {\n        key: '_formatOrUnformatOther',\n        value: function _formatOrUnformatOther(isFormatting, valueOrStringOrElement) {\n            var optionOverride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            //FIXME à tester\n            // If the user wants to override the current element settings temporarily\n            var settingsToUse = void 0;\n            if (!_AutoNumericHelper2.default.isNull(optionOverride)) {\n                settingsToUse = this._cloneAndMergeSettings(optionOverride);\n            } else {\n                settingsToUse = this.settings;\n            }\n\n            // Then the unformatting is done...\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isElement(valueOrStringOrElement)) {\n                // ...either directly on the DOM element value\n                var elementValue = _AutoNumericHelper2.default.getElementValue(valueOrStringOrElement);\n                if (isFormatting) {\n                    result = AutoNumeric.format(elementValue, settingsToUse);\n                } else {\n                    result = AutoNumeric.unformat(elementValue, settingsToUse);\n                }\n\n                _AutoNumericHelper2.default.setElementValue(valueOrStringOrElement, result); //TODO Use `unformatAndSet` and `formatAndSet`instead\n\n                return null;\n            }\n\n            // ...or on the given value\n            if (isFormatting) {\n                result = AutoNumeric.format(valueOrStringOrElement, settingsToUse);\n            } else {\n                result = AutoNumeric.unformat(valueOrStringOrElement, settingsToUse);\n            }\n\n            return result;\n        }\n\n        /**\n         * Use the current AutoNumeric element settings to initialize the DOM element(s) given as a parameter.\n         * Doing so will *link* the AutoNumeric elements together since they will share the same local AutoNumeric element list.\n         * (cf. prototype pattern : https://en.wikipedia.org/wiki/Prototype_pattern)\n         *\n         * You can `init` either a single DOM element (in that case an AutoNumeric object will be returned), or an array of DOM elements or a string that will be used as a CSS selector. In the latter cases, an array of AutoNumeric objects will then be returned (or an empty array if nothing gets selected by the CSS selector).\n         *\n         * Use case : Once you have an AutoNumeric element already setup correctly with the right options, you can use it as many times you want to initialize as many other DOM elements as needed.\n         * Note : this works only on elements that can be managed by autoNumeric.\n         *\n         * @param {HTMLElement|HTMLInputElement|Array<HTMLElement|HTMLInputElement>|string} domElementOrArrayOrString\n         * @param {boolean} attached If set to `false`, then the newly generated AutoNumeric element will not share the same local element list\n         * @returns {AutoNumeric|[AutoNumeric]}\n         */\n\n    }, {\n        key: 'init',\n        value: function init(domElementOrArrayOrString) {\n            var _this4 = this;\n\n            var attached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var returnASingleAutoNumericObject = false; // By default, this function returns an array of AutoNumeric objects\n            var domElementsArray = [];\n            if (_AutoNumericHelper2.default.isString(domElementOrArrayOrString)) {\n                domElementsArray = [].concat(_toConsumableArray(document.querySelectorAll(domElementOrArrayOrString))); // Convert a NodeList to an Array\n            } else if (_AutoNumericHelper2.default.isElement(domElementOrArrayOrString)) {\n                domElementsArray.push(domElementOrArrayOrString);\n                returnASingleAutoNumericObject = true; // Special case when only one DOM element is passed as a parameter\n            } else if (_AutoNumericHelper2.default.isArray(domElementOrArrayOrString)) {\n                domElementsArray = domElementOrArrayOrString;\n            } else {\n                _AutoNumericHelper2.default.throwError('The given parameters to the \\'init\\' function are invalid.');\n            }\n\n            if (domElementsArray.length === 0) {\n                _AutoNumericHelper2.default.warning('No valid DOM elements were given hence no AutoNumeric object were instantiated.');\n                return [];\n            }\n\n            var currentLocalList = this._getLocalList();\n            var autoNumericObjectsArray = [];\n\n            // Instantiate (and link depending on `attached`) each AutoNumeric objects\n            domElementsArray.forEach(function (domElement) {\n                // Initialize the new AutoNumeric element\n                var originalCreateLocalListSetting = _this4.settings.createLocalList;\n                if (attached) {\n                    // Temporary variable to know if we should create the local list during the initialization (since we'll remove it afterwards)\n                    _this4.settings.createLocalList = false;\n                }\n\n                var newAutoNumericElement = new AutoNumeric(domElement, _AutoNumericHelper2.default.getElementValue(domElement), _this4.settings);\n\n                // Set the common shared local list if needed\n                // If the user wants to create a detached new AutoNumeric element, then skip the following step that bind the two elements together by default\n                if (attached) {\n                    // 1) Set the local list reference to point to the initializer's one\n                    newAutoNumericElement._setLocalList(currentLocalList);\n\n                    // 2) Add the new element to that existing list\n                    _this4._addToLocalList(domElement, newAutoNumericElement); // Here we use the *new* AutoNumeric object reference to add to the local list, since we'll need the reference to `this` in the methods to points to that new AutoNumeric object.\n                    _this4.settings.createLocalList = originalCreateLocalListSetting;\n                }\n\n                autoNumericObjectsArray.push(newAutoNumericElement);\n            });\n\n            if (returnASingleAutoNumericObject) {\n                // If a single DOM element was used as the parameter, then we return an AutoNumeric object directly\n                return autoNumericObjectsArray[0];\n            }\n\n            // ...otherwise we return an Array of AutoNumeric objects\n            return autoNumericObjectsArray;\n        }\n\n        /**\n         * Reset the element value either to the empty string '', or the currency sign, depending on the `emptyInputBehavior` option value.\n         * If you set the `forceClearAll` argument to `true`, then the `emptyInputBehavior` option is overridden and the whole input is clear, including any currency sign.\n         *\n         * @param {boolean} forceClearAll\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var forceClearAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (forceClearAll) {\n                var temporaryForcedOptions = {\n                    emptyInputBehavior: AutoNumeric.options.emptyInputBehavior.focus\n                };\n                this.set('', temporaryForcedOptions);\n            } else {\n                this.set('');\n            }\n\n            return this;\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, but keep the element content intact.\n         * This also clears the value from sessionStorage (or cookie, depending on browser supports).\n         * Note: this does not remove the formatting.\n         *\n         * @example anElement.remove()\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove() {\n            this._saveValueToPersistentStorage('remove');\n            this._removeEventListeners();\n\n            // Also remove the element from the local AutoNumeric list\n            this._removeFromLocalList(this.domElement);\n            // Also remove the element from the global AutoNumeric list\n            this.constructor._removeFromGlobalList(this);\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, and reset its value to the empty string ''.\n         * This also clears the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example anElement.wipe()\n         */\n\n    }, {\n        key: 'wipe',\n        value: function wipe() {\n            this._setElementValue('');\n            this.remove();\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, and delete the DOM element altogether\n         */\n\n    }, {\n        key: 'nuke',\n        value: function nuke() {\n            this.remove();\n            // Remove the element from the DOM\n            this.domElement.parentNode.removeChild(this.domElement);\n        }\n\n        // Special functions that really work on the parent <form> element, instead of the <input> element itself\n\n        /**\n         * Return a reference to the parent <form> element if it exists, otherwise return `null`\n         *\n         * @returns {HTMLFormElement|null}\n         */\n\n    }, {\n        key: 'form',\n        value: function form() {\n            //TODO Store a reference to the parent <form> in `this.form` so we do not have to search it on each call?\n            if (this.domElement.tagName.toLowerCase() === 'body') {\n                return null;\n            }\n\n            var node = this.domElement;\n            var tagName = void 0;\n            do {\n                node = node.parentNode;\n                if (_AutoNumericHelper2.default.isNull(node)) {\n                    // Special case when using templates with frameworks like Vue.js, where the input element can be 'detached' when initializing the DOM structure\n                    return null;\n                }\n\n                tagName = node.tagName.toLowerCase();\n\n                if (tagName === 'body') {\n                    break;\n                }\n            } while (tagName !== 'form');\n\n            if (tagName === 'form') {\n                return node;\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values being unformatted.\n         * This string can be used as a query for instance.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formNumericString',\n        value: function formNumericString() {\n            return this.constructor._serializeNumericString(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values being formatted.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formFormatted',\n        value: function formFormatted() {\n            return this.constructor._serializeFormatted(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values, with localized values.\n         * The default output format can be overridden by passing the option as a parameter.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formLocalized',\n        value: function formLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            return this.constructor._serializeLocalized(this.form(), this.settings.serializeSpaces, outputFormatToUse);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is an unformatted numeric string.\n         *\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayNumericString',\n        value: function formArrayNumericString() {\n            return this.constructor._serializeNumericStringArray(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the formatted string.\n         *\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayFormatted',\n        value: function formArrayFormatted() {\n            return this.constructor._serializeFormattedArray(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the localized numeric string.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayLocalized',\n        value: function formArrayLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            return this.constructor._serializeLocalizedArray(this.form(), this.settings.serializeSpaces, outputFormatToUse);\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayNumericString()` function.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonNumericString',\n        value: function formJsonNumericString() {\n            return JSON.stringify(this.formArrayNumericString());\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayFormatted()` function.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonFormatted',\n        value: function formJsonFormatted() {\n            return JSON.stringify(this.formArrayFormatted());\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayLocalized()` function.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonLocalized',\n        value: function formJsonLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            return JSON.stringify(this.formArrayLocalized(forcedOutputFormat));\n        }\n\n        /**\n         * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to numeric strings\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formUnformat',\n        value: function formUnformat() {\n            //FIXME à tester\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).unformat();\n            });\n\n            return this;\n        }\n\n        /**\n         * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to localized strings\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formUnformatLocalized',\n        value: function formUnformatLocalized() {\n            //FIXME à tester\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).unformatLocalized();\n            });\n\n            return this;\n        }\n\n        /**\n         * Reformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formReformat',\n        value: function formReformat() {\n            //FIXME à tester\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).reformat();\n            });\n\n            return this;\n        }\n\n        /**\n         * Convert the input values to numeric strings, submit the form, then reformat those back.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formNumericString()`.\n         *\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitNumericString',\n        value: function formSubmitNumericString() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.formUnformat();\n                this.form().submit();\n                this.formReformat();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Submit the form with the current formatted values.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formFormatted()`.\n         *\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitFormatted',\n        value: function formSubmitFormatted() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.form().submit();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Convert the input values to localized strings, submit the form, then reformat those back.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formLocalized()`.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitLocalized',\n        value: function formSubmitLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.formUnformatLocalized();\n                this.form().submit();\n                this.formReformat();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of numeric strings from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayNumericString()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayNumericString',\n        value: function formSubmitArrayNumericString(callback) {\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of the current formatted values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayFormatted()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayFormatted',\n        value: function formSubmitArrayFormatted(callback) {\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of localized strings from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayLocalized()`.\n         *\n         * @param {function} callback\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayLocalized',\n        value: function formSubmitArrayLocalized(callback) {\n            var forcedOutputFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the numeric strings values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonNumericString()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonNumericString',\n        value: function formSubmitJsonNumericString(callback) {\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the current formatted values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonFormatted()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonFormatted',\n        value: function formSubmitJsonFormatted(callback) {\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the localized strings values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonLocalized()`.\n         *\n         * @param {function} callback\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonLocalized',\n        value: function formSubmitJsonLocalized(callback) {\n            var forcedOutputFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Unformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.\n         *\n         * @param {AutoNumeric} anElement\n         * @private\n         */\n\n    }, {\n        key: '_createLocalList',\n\n\n        /**\n         * Create a `Map` that will stores all the autoNumeric elements that are initialized from this current element.\n         * @private\n         */\n        value: function _createLocalList() {\n            this.autoNumericLocalList = new Map();\n            this._addToLocalList(this.domElement);\n        }\n\n        /**\n         * In some rare cases, you could want to delete the local list generated during the element initialization (in order to use another one instead for instance).\n         * @private\n         */\n\n    }, {\n        key: '_deleteLocalList',\n        value: function _deleteLocalList() {\n            delete this.autoNumericLocalList;\n        }\n\n        /**\n         * Set the local list with the given Map object.\n         *\n         * @param {Map} localList\n         * @private\n         */\n\n    }, {\n        key: '_setLocalList',\n        value: function _setLocalList(localList) {\n            this.autoNumericLocalList = localList;\n        }\n\n        /**\n         * Return the local list Map object.\n         *\n         * @returns {*|Map}\n         * @private\n         */\n\n    }, {\n        key: '_getLocalList',\n        value: function _getLocalList() {\n            return this.autoNumericLocalList;\n        }\n\n        /**\n         * Return `true` is the AutoNumeric object has a local list defined already and has at least one element in it (itself usually).\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_hasLocalList',\n        value: function _hasLocalList() {\n            return this.autoNumericLocalList instanceof Map && this.autoNumericLocalList.size !== 0;\n        }\n\n        /**\n         * Add the given object to the local autoNumeric element list.\n         * Note: in order to keep a coherent list, we only add DOM elements in it, not the autoNumeric object.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {AutoNumeric} autoNumericObject A reference to the AutoNumeric object that manage the given DOM element\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_addToLocalList',\n        value: function _addToLocalList(domElement) {\n            var autoNumericObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (_AutoNumericHelper2.default.isNull(autoNumericObject)) {\n                autoNumericObject = this;\n            }\n\n            if (!_AutoNumericHelper2.default.isUndefined(this.autoNumericLocalList)) {\n                this.autoNumericLocalList.set(domElement, autoNumericObject); // Use the DOM element as key, and the AutoNumeric object as the value\n            } else {\n                _AutoNumericHelper2.default.throwError('The local list provided does not exists when trying to add an element. [' + this.autoNumericLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Remove the given object from the local autoNumeric element list.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @private\n         */\n\n    }, {\n        key: '_removeFromLocalList',\n        value: function _removeFromLocalList(domElement) {\n            if (!_AutoNumericHelper2.default.isUndefined(this.autoNumericLocalList)) {\n                this.autoNumericLocalList.delete(domElement);\n            } else if (this.settings.createLocalList) {\n                _AutoNumericHelper2.default.throwError('The local list provided does not exists when trying to remove an element. [' + this.autoNumericLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Merge the `newSettings` given as parameters into the current element settings.\n         *\n         * WARNING: Using `Object.assign()` here means the merge is not recursive and only one depth is merged.\n         * cf. http://stackoverflow.com/a/39188108/2834898\n         * cf. tests on http://codepen.io/AnotherLinuxUser/pen/KaJORq?editors=0011\n         *\n         * @param {object} newSettings\n         * @private\n         */\n\n    }, {\n        key: '_mergeSettings',\n        value: function _mergeSettings() {\n            for (var _len3 = arguments.length, newSettings = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                newSettings[_key3] = arguments[_key3];\n            }\n\n            _extends.apply(undefined, [this.settings].concat(newSettings));\n        }\n\n        /**\n         * Return a new object with the current element settings merged with the new settings.\n         *\n         * @param {object} newSettings\n         * @returns {object}\n         * @private\n         */\n\n    }, {\n        key: '_cloneAndMergeSettings',\n        value: function _cloneAndMergeSettings() {\n            var result = {};\n\n            for (var _len4 = arguments.length, newSettings = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                newSettings[_key4] = arguments[_key4];\n            }\n\n            _extends.apply(undefined, [result, this.settings].concat(newSettings));\n\n            return result;\n        }\n\n        /**\n         * Validate the given option object.\n         * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n         *\n         * This tests if the options are not conflicting and are well formatted.\n         * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n         *\n         * @param {*} userOptions\n         * @param {Boolean} shouldExtendDefaultOptions If `true`, then this function will extends the `userOptions` passed by the user, with the default options.\n         * @param {object|null} originalOptions The user can pass the original options (and not the one that are generated from the default settings and the various usability corrections), in order to add compatibility and conflicts checks.\n         * @throws Error This throws if the `userOptions` are not valid\n         */\n\n    }, {\n        key: '_updatePredefinedOptions',\n\n\n        // Pre-defined options can be called to update the current default options with their specificities\n        //XXX A better way would be to not initialize first, but that's not possible since `new` is called first and we do not pass the language options (ie. `French`) to the constructor\n\n        /**\n         * Update the AutoNumeric object with the predefined options, and possibly some option overrides.\n         *\n         * @param {object} predefinedOption\n         * @param {object} optionOverride\n         * @private\n         * @returns {AutoNumeric}\n         */\n        value: function _updatePredefinedOptions(predefinedOption) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (!_AutoNumericHelper2.default.isNull(optionOverride)) {\n                this._mergeSettings(predefinedOption, optionOverride);\n                this.update(this.settings);\n            } else {\n                this.update(predefinedOption);\n            }\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the French pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'french',\n        value: function french() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().French, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the North American pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'northAmerican',\n        value: function northAmerican() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().NorthAmerican, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the British pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'british',\n        value: function british() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().British, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Swiss pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'swiss',\n        value: function swiss() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Swiss, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Japanese pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'japanese',\n        value: function japanese() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Japanese, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Spanish pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'spanish',\n        value: function spanish() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Spanish, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Chinese pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'chinese',\n        value: function chinese() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Chinese, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Brazilian pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'brazilian',\n        value: function brazilian() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Brazilian, optionOverride);\n\n            return this;\n        }\n\n        // Internal private functions\n        /**\n         * Run any callbacks found in the settings object in order to set the settings value back.\n         * Any parameter can have a callback defined.\n         * The callback takes the current AutoNumeric element as the first argument, and the key name as the second.\n         * @example callback(this, 'currencySymbol')\n         */\n\n    }, {\n        key: '_runCallbacksFoundInTheSettingsObject',\n        value: function _runCallbacksFoundInTheSettingsObject() {\n            //FIXME à tester\n            // Loops through the this.settings object (option array) to find the following\n            for (var key in this.settings) {\n                if (this.settings.hasOwnProperty(key)) {\n                    var value = this.settings[key];\n\n                    if (typeof value === 'function') {\n                        this.settings[key] = value(this, key);\n                    } else {\n                        // Calls the attached function from the html5 data. For instance: <tag data-currency-symbol=\"functionName\"></tag>\n                        var htmlAttribute = this.domElement.getAttribute(key); //TODO Use `dataset` instead of `getAttribute` when we won't need to support obsolete browsers\n                        htmlAttribute = _AutoNumericHelper2.default.camelize(htmlAttribute);\n                        if (typeof this.settings[htmlAttribute] === 'function') {\n                            this.settings[key] = htmlAttribute(this, key);\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determine the maximum decimal length from the minimumValue and maximumValue settings\n         *\n         * @param {string} minimumValue\n         * @param {string} maximumValue\n         * @returns {number}\n         */\n\n    }, {\n        key: '_setTrailingNegativeSignInfo',\n\n\n        /**\n         * Keep track if the settings configuration leads to a trailing negative sign (only when the raw value is negative), so we do not have to test the settings values every time we need to know that.\n         * `isTrailingNegative` is set to `true` if the settings result in a trailing negative character, `false` otherwise.\n         * Note: This returns `true` even if the raw value is positive.\n         * @private\n         */\n        value: function _setTrailingNegativeSignInfo() {\n            this.isTrailingNegative = this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.right);\n        }\n\n        /**\n         * Strip all unwanted non-number characters.\n         * This keeps the numbers, the negative sign as well as the custom decimal character.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @param {boolean} stripZeros If set to `false`, then the leading zero(s) are not stripped, otherwise if set to `true`, the `leadingZero` option is followed\n         * @param {boolean} isFocused If the element is focused, then this is `true`\n         * @returns {string|*}\n         */\n\n    }, {\n        key: '_setBrackets',\n\n\n        /**\n         * Analyze the `negativeBracketsTypeOnBlur` options and keep track of the first and last bracket characters to use.\n         * @private\n         */\n        value: function _setBrackets() {\n            if (!_AutoNumericHelper2.default.isNull(this.settings.negativeBracketsTypeOnBlur)) {\n                var _settings$negativeBra = this.settings.negativeBracketsTypeOnBlur.split(',');\n\n                var _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2);\n\n                this.settings.firstBracket = _settings$negativeBra2[0];\n                this.settings.lastBracket = _settings$negativeBra2[1];\n            } else {\n                this.settings.firstBracket = '';\n                this.settings.lastBracket = '';\n            }\n        }\n\n        /**\n         * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\n         *\n         * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\n         * Lastly, it also put the negative sign back to its normal position if needed.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @returns {string|void|XML|*}\n         */\n\n    }, {\n        key: '_modifyNegativeSignAndDecimalCharacterForRawValue',\n\n\n        /**\n         * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n         *\n         * @param {string} s\n         * @returns {string}\n         */\n        value: function _modifyNegativeSignAndDecimalCharacterForRawValue(s) {\n            if (this.settings.decimalCharacter !== '.') {\n                s = s.replace(this.settings.decimalCharacter, '.');\n            }\n\n            if (this.settings.negativeSignCharacter !== '-' && this.settings.negativeSignCharacter !== '') {\n                s = s.replace(this.settings.negativeSignCharacter, '-');\n            }\n\n            if (!s.match(/\\d/)) {\n                // The default value returned by `get` is not formatted with decimals\n                s += '0';\n            }\n\n            return s;\n        }\n\n        /**\n         * Modify the negative sign and the decimal character to use those defined in the settings.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @returns {string}\n         */\n\n    }, {\n        key: '_initialCaretPosition',\n\n\n        /**\n         * Calculate where to put the caret position on focus if the element content is not selected.\n         * This calculation is affected by the `caretPositionOnFocus` option which can be either `null`, `'start'`, `'end'`, `'decimalLeft'` or 'decimalRight'`, and will decide where to put the caret (on the left or right of the value or the decimal character, respectively) :\n         * - `null` : the caret position is not forced\n         * - `'start'` : the caret is positioned on the left hand side of the value\n         * - `'end'` : the caret is positioned on the right hand side of the value\n         * - `'decimalLeft'` : the caret is positioned on the left side of the decimal character\n         * - `'decimalRight'` : the caret is positioned on the right side of the decimal character\n         *\n         * @param {string} value The formatted string stripped of the currency symbol and negative/positive sign\n         * @returns {number}\n         * @throws\n         * @private\n         */\n        value: function _initialCaretPosition(value) {\n            if (_AutoNumericHelper2.default.isNull(this.settings.caretPositionOnFocus)) {\n                _AutoNumericHelper2.default.throwError('`_initialCaretPosition()` should never be called when the `caretPositionOnFocus` option is `null`.');\n            }\n\n            var isValueNegative = this.settings.rawValue < 0;\n            var isZeroOrHasNoValue = _AutoNumericHelper2.default.isZeroOrHasNoValue(value);\n            var totalLength = value.length;\n\n            var valueSize = 0;\n            var integerSize = 0;\n            var hasDecimalChar = false;\n            var offsetDecimalChar = 0;\n            if (this.settings.caretPositionOnFocus !== AutoNumeric.options.caretPositionOnFocus.start) {\n                value = value.replace('-', '');\n                value = value.replace('+', '');\n                value = value.replace(this.settings.currencySymbol, '');\n                valueSize = value.length;\n                hasDecimalChar = _AutoNumericHelper2.default.contains(value, this.settings.decimalCharacter);\n\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft || this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (hasDecimalChar) {\n                        integerSize = value.indexOf(this.settings.decimalCharacter);\n                        offsetDecimalChar = this.settings.decimalCharacter.length;\n                    } else {\n                        integerSize = valueSize;\n                        offsetDecimalChar = 0;\n                    }\n                }\n            }\n\n            var signToUse = '';\n            if (isValueNegative) {\n                signToUse = this.settings.negativeSignCharacter;\n            } else if (this.settings.showPositiveSign && !isZeroOrHasNoValue) {\n                signToUse = this.settings.positiveSignCharacter;\n            }\n\n            var positiveNegativeSignSize = signToUse.length;\n            var currencySymbolSize = this.settings.currencySymbol.length;\n\n            // Calculate the caret position based on `currencySymbolPlacement`, `negativePositiveSignPlacement` and `caretPositionOnFocus`\n            var caretPosition = void 0;\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.start) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€|12.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€|12.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+|12.34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €|12.34+\n                                caretPosition = currencySymbolSize;\n                                break;\n                        }\n                    } else {\n                        // €|12.34\n                        caretPosition = currencySymbolSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.end) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12.34|\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12.34|\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12.34|\n                                caretPosition = totalLength;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12.34|+\n                                caretPosition = currencySymbolSize + valueSize;\n                                break;\n                        }\n                    } else {\n                        // €12.34|\n                        caretPosition = totalLength;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12|.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12|.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12|.34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12|.34+\n                                caretPosition = currencySymbolSize + integerSize;\n                                break;\n                        }\n                    } else {\n                        // €12|.34\n                        caretPosition = currencySymbolSize + integerSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12.|34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12.|34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12.|34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize + offsetDecimalChar;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12.|34+\n                                caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;\n                                break;\n                        }\n                    } else {\n                        // €12.|34\n                        caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;\n                    }\n                }\n            } else if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.start) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // |12.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // |12.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // |12.34+€\n                                caretPosition = 0;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +|12.34€\n                                caretPosition = positiveNegativeSignSize;\n                                break;\n                        }\n                    } else {\n                        // |12.34€\n                        caretPosition = 0;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.end) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12.34|€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12.34|€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12.34|+€\n                                caretPosition = valueSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12.34|€\n                                caretPosition = positiveNegativeSignSize + valueSize;\n                                break;\n                        }\n                    } else {\n                        // 12.34|€\n                        caretPosition = valueSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12|.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12|.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12|.34+€\n                                caretPosition = integerSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12|.34€\n                                caretPosition = positiveNegativeSignSize + integerSize;\n                                break;\n                        }\n                    } else {\n                        // 12|.34€\n                        caretPosition = integerSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12.|34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12.|34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12.|34+€\n                                caretPosition = integerSize + offsetDecimalChar;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12.|34€\n                                caretPosition = positiveNegativeSignSize + integerSize + offsetDecimalChar;\n                                break;\n                        }\n                    } else {\n                        // 12.|34€\n                        caretPosition = integerSize + offsetDecimalChar;\n                    }\n                }\n            }\n\n            return caretPosition;\n        }\n\n        /**\n         * Truncate not needed zeros\n         *\n         * @param {string} roundedInputValue\n         * @param {int} decimalPlacesOverride\n         * @returns {void|XML|string|*}\n         */\n\n    }, {\n        key: '_keepAnOriginalSettingsCopy',\n\n\n        /**\n         * Original settings saved for use when the `decimalPlacesShownOnFocus` and `noSeparatorOnFocus` options are used.\n         * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n         */\n        value: function _keepAnOriginalSettingsCopy() {\n            this.originalDecimalPlacesOverride = this.settings.decimalPlacesOverride;\n            this.originalAllowDecimalPadding = this.settings.allowDecimalPadding;\n            this.originalNegativeBracketsTypeOnBlur = this.settings.negativeBracketsTypeOnBlur;\n            this.originalDigitGroupSeparator = this.settings.digitGroupSeparator;\n            this.originalCurrencySymbol = this.settings.currencySymbol;\n            this.originalSuffixText = this.settings.suffixText;\n        }\n\n        /**\n         * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n         * This is taken from Quirksmode.\n         *\n         * @param {string} name\n         * @returns {*}\n         */\n\n    }, {\n        key: '_trimLeadingAndTrailingZeros',\n\n\n        /**\n         * Removes any zeros in excess in the front and back of the given `value`, according to the `settings`.\n         * This also manages the cases where the decimal point is on the far left or far right of the `value`.\n         *\n         * @param {string} value\n         * @returns {string}\n         */\n        value: function _trimLeadingAndTrailingZeros(value) {\n            // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n            if (value === '') {\n                return '';\n            }\n\n            if (this.settings.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                if (Number(value) === 0) {\n                    // Return '0' if the value is zero\n                    return '0';\n                }\n\n                // Trim the leading zeros, while leaving one zero to the left of the decimal point if needed\n                value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n            }\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead\n            // Trim the trailing zeros after the last decimal place not being a zero (ie. 1.2300 -> 1.23)\n            if (_AutoNumericHelper2.default.contains(value, '.')) {\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n\n            // Remove any trailing decimal point\n            value = value.replace(/\\.$/, '');\n\n            return value;\n        }\n\n        /**\n         * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n         *\n         * @param {string} action\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_saveValueToPersistentStorage',\n        value: function _saveValueToPersistentStorage(action) {\n            if (this.settings.saveValueToSessionStorage) {\n                var storedName = this.domElement.name !== '' && !_AutoNumericHelper2.default.isUndefined(this.domElement.name) ? 'AUTO_' + decodeURIComponent(this.domElement.name) : 'AUTO_' + this.domElement.id;\n                var date = void 0;\n                var expires = void 0;\n\n                // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n                if (this._storageTest() === false) {\n                    switch (action) {\n                        case 'set':\n                            document.cookie = storedName + '=' + this.settings.rawValue + '; expires= ; path=/';\n                            break;\n                        case 'remove':\n                            date = new Date();\n                            date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                            expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                            document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                            break;\n                        case 'get':\n                            return this._readCookie(storedName);\n                    }\n                } else {\n                    switch (action) {\n                        case 'set':\n                            sessionStorage.setItem(storedName, this.settings.rawValue);\n                            break;\n                        case 'remove':\n                            sessionStorage.removeItem(storedName);\n                            break;\n                        case 'get':\n                            return sessionStorage.getItem(storedName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Handler for 'focusin' and 'mouseenter' events\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_onFocusInAndMouseEnter',\n        value: function _onFocusInAndMouseEnter(e) {\n            //TODO `AutoNumericHelper.setElementValue` is called 3 times sequentially here, fix that\n            var initialElementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (this.settings.unformatOnHover && e.type === 'mouseenter' && e.altKey) {\n                this.constructor._unformatAltHovered(this);\n\n                return;\n            }\n\n            if (e.type === 'focus' && this.settings.unformatOnHover && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n            }\n\n            if (e.type === 'focus' || e.type === 'mouseenter' && !this.isFocused) {\n                if (this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.focus && this.settings.rawValue < 0 && this.settings.negativeBracketsTypeOnBlur !== null && this.settings.negativeSignCharacter !== '') {\n                    //FIXME this is called a second time in _addGroupSeparators too. Prevent this\n                    // Only remove the brackets if the value is negative\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, this.constructor._removeBrackets(_AutoNumericHelper2.default.getElementValue(this.domElement), this.settings));\n                }\n\n                // Check if the element value needs to be changed by the number of decimal places to show on focus, the scaleDecimal* options or no separator on focus option\n                var updateElementValue = false;\n                if (this.settings.decimalPlacesShownOnFocus) {\n                    this.settings.decimalPlacesOverride = this.settings.decimalPlacesShownOnFocus;\n                    updateElementValue = true;\n                } else if (this.settings.scaleDivisor && this.settings.rawValue !== '') {\n                    // Prevent changing the element value if it's empty (so we don't end up having a '0.000scaleSymbol' value after a mouseenter/mouseleave cycle)\n                    this.settings.decimalPlacesOverride = Number(this.originalDecimalPlacesOverride);\n                    updateElementValue = true;\n                } else if (this.settings.noSeparatorOnFocus) {\n                    //TODO Use a `this.settingsOverride` object instead of modifying the `this.settings` object\n                    this.settings.digitGroupSeparator = '';\n                    this.settings.currencySymbol = '';\n                    this.settings.suffixText = '';\n                    updateElementValue = true;\n                }\n\n                if (updateElementValue) {\n                    var roundedValue = this.constructor._roundValue(this.settings.rawValue, this.settings);\n                    if (this.settings.noSeparatorOnFocus) {\n                        _AutoNumericHelper2.default.setElementValue(this.domElement, roundedValue.replace('.', this.settings.decimalCharacter));\n                    } else {\n                        _AutoNumericHelper2.default.setElementValue(this.domElement, this.constructor._addGroupSeparators(roundedValue, this.settings, this.isFocused));\n                    }\n                }\n\n                // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n                this.valueOnFocus = _AutoNumericHelper2.default.getElementValue(e.target);\n                this.lastVal = this.valueOnFocus;\n                var isEmptyValue = this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(this.valueOnFocus, this.settings);\n                var orderedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(this.valueOnFocus, this.settings, true);\n                if (isEmptyValue && orderedValue !== '' && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.focus) {\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, orderedValue);\n\n                    // If there is a currency symbol and its on the right hand side, then we place the caret accordingly on the far left side\n                    if (orderedValue === this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                        _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n                    }\n                }\n            }\n\n            if (_AutoNumericHelper2.default.getElementValue(this.domElement) !== initialElementValue) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, this.domElement, { oldValue: initialElementValue, newValue: _AutoNumericHelper2.default.getElementValue(this.domElement) });\n            }\n        }\n\n        /**\n         * Handler for the 'focus' event.\n         * We update the info of the focused state in the `this.isFocused` variable when the element gets focused.\n         * @private\n         */\n\n    }, {\n        key: '_onFocus',\n        value: function _onFocus() {\n            if (this.settings.isCancellable) {\n                // Save the current unformatted value for later use by the 'cancellable' feature\n                this._saveCancellableValue();\n            }\n\n            // We keep track if the element is currently focused\n            this.isFocused = true;\n        }\n\n        /**\n         * Handler for the 'focusin' event.\n         * This is called before the 'focus' event, and is necessary to change the selection on focus under Firefox for instance.\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_onFocusIn',\n        value: function _onFocusIn(e) {\n            if (this.settings.selectOnFocus) {\n                // The whole input content is selected on focus (following the `selectOnFocus` and `selectNumberOnly` options)\n                //XXX Firefox <47 does not respect this selection...Oh well.\n                this.select();\n            } else {\n                // Or we decide where to put the caret using the `caretPositionOnFocus` option\n                _AutoNumericHelper2.default.setElementSelection(e.target, this._initialCaretPosition(_AutoNumericHelper2.default.getElementValue(this.domElement)));\n            }\n        }\n\n        /**\n         * Handler for 'keydown' events.\n         * The user just started pushing any key, hence one event is sent.\n         *\n         * Note :\n         * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n         * - keydown\n         * - keypress\n         * - input\n         * - keyup\n         *\n         * ...when inputting a modifier key (ie. 'ctrl') :\n         * - keydown\n         * - keyup\n         *\n         * If 'delete' or 'backspace' is entered, the following events are sent :\n         * - keydown\n         * - input\n         * - keyup\n         *\n         * If 'enter' is entered and the value has not changed, the following events are sent :\n         * - keydown\n         * - keypress\n         * - keyup\n         *\n         * If 'enter' is entered and the value has been changed, the following events are sent :\n         * - keydown\n         * - keypress\n         * - change\n         * - keyup\n         *\n         * When a paste is done, the following events are sent :\n         * - input (if paste is done with the mouse)\n         *\n         * - keydown (if paste is done with ctrl+v)\n         * - keydown\n         * - input\n         * - keyup\n         * - keyup\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeydown',\n        value: function _onKeydown(e) {\n            if (!this.isFocused && this.settings.unformatOnHover && e.altKey && this.domElement === _AutoNumericHelper2.default.getHoveredElement()) {\n                // Here I prevent calling _unformatAltHovered if the element is already focused, since the global 'keydown' listener will pick it up as well\n                this.constructor._unformatAltHovered(this);\n\n                return;\n            }\n\n            this._updateEventKeyInfo(e);\n            this.initialValueOnKeydown = _AutoNumericHelper2.default.getElementValue(e.target); // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n            if (this.domElement.readOnly) {\n                this.processed = true;\n\n                return;\n            }\n\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Esc) {\n                //XXX The default 'Escape' key behavior differs between Firefox and Chrome, Firefox already having a built-in 'cancellable-like' feature. This is why we call `e.preventDefault()` here instead of just when `isCancellable` is set to `true`. This allow us to keep the same behavior across browsers.\n                e.preventDefault();\n\n                if (this.settings.isCancellable) {\n                    // If the user wants to cancel its modifications :\n                    // We set back the saved value\n                    if (this.settings.rawValue !== this.savedCancellableValue) {\n                        // Do not set the value again if it has not changed\n                        this.set(this.savedCancellableValue);\n                        // And we need to send an 'input' event when setting back the initial value in order to make other scripts aware of the value change...\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    }\n                }\n\n                // ..and lastly we update the caret selection, even if the option `isCancellable` is false\n                this.select();\n                //TODO Add an option to select either the integer or decimal part with `Esc`\n            }\n\n            // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Enter && this.valueOnFocus !== targetValue) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, e.target);\n                this.valueOnFocus = targetValue;\n\n                if (this.settings.isCancellable) {\n                    // If the user activated the 'cancellable' feature, we save the validated value when 'Enter' is hit\n                    this._saveCancellableValue();\n                }\n            }\n\n            this._updateInternalProperties(e);\n\n            if (this._processNonPrintableKeysAndShortcuts(e)) {\n                this.processed = true;\n\n                return;\n            }\n\n            // Check if the key is a delete/backspace key\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace || this.eventKey === _AutoNumericEnum2.default.keyName.Delete) {\n                this._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n                this.processed = true;\n                this._formatValue(e);\n\n                // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n                targetValue = _AutoNumericHelper2.default.getElementValue(e.target); // Update the value since it could have been changed during the deletion\n                if (targetValue !== this.lastVal && this.throwInput) {\n                    // Throw an input event when a character deletion is detected\n                    _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n                }\n\n                this.lastVal = targetValue;\n                this.throwInput = true;\n\n                return;\n            }\n\n            this.formatted = false; //TODO Is this line needed? (I mean, _formatValue always set it to `true`, and this overwrite that info)\n        }\n\n        /**\n         * Handler for 'keypress' events.\n         * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n         * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeypress',\n        value: function _onKeypress(e) {\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                return;\n            }\n\n            var processed = this.processed;\n            this._updateInternalProperties(e);\n\n            if (this._processNonPrintableKeysAndShortcuts(e)) {\n                return;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return;\n            }\n\n            var isCharacterInsertionAllowed = this._processCharacterInsertion();\n            if (isCharacterInsertionAllowed) {\n                this._formatValue(e);\n                var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n                if (targetValue !== this.lastVal && this.throwInput) {\n                    // Throws input event on adding a character\n                    _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    e.preventDefault(); // ...and immediately prevent the browser to add a second character\n                } else {\n                    if ((this.eventKey === this.settings.decimalCharacter || this.eventKey === this.settings.decimalCharacterAlternative) && _AutoNumericHelper2.default.getElementSelection(e.target).start === _AutoNumericHelper2.default.getElementSelection(e.target).end && _AutoNumericHelper2.default.getElementSelection(e.target).start === targetValue.indexOf(this.settings.decimalCharacter)) {\n                        var position = _AutoNumericHelper2.default.getElementSelection(e.target).start + 1;\n                        _AutoNumericHelper2.default.setElementSelection(e.target, position);\n                    }\n\n                    e.preventDefault();\n                }\n\n                this.lastVal = _AutoNumericHelper2.default.getElementValue(e.target);\n                this.throwInput = true;\n\n                return;\n            }\n\n            e.preventDefault();\n\n            this.formatted = false; //TODO Is this line needed? (I mean, _formatValue always set it to `true`, and this overwrite that info)\n        }\n\n        /**\n         * Handler for 'input' events.\n         * Handling this event instead of `keypress` is needed in order to support android devices.\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onInput',\n        value: function _onInput(e) {\n            //FIXME à tester\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            // Fix the caret position on keyup in the `_formatValue()` function\n            this.androidSelectionStart = null;\n\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.AndroidDefault) {\n                var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n                if (value.length > this.lastVal.length || value.length >= this.lastVal.length - selection.length) {\n                    // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n                    this.eventKey = value.charCodeAt(selection.start);\n\n                    // Capture the actual character entered, and update the `eventKey` with it (instead of the Android default one)\n                    this.eventKey = value.charAt(selection.start);\n\n                    // Check if the given character should be inserted, and if so, do insert it into the current element value\n                    var isCharacterInsertionAllowed = this._processCharacterInsertion();\n\n                    if (isCharacterInsertionAllowed) {\n                        // Allowed character entered (number, decimal or plus/minus sign)\n                        this._formatValue(e);\n\n                        selection = _AutoNumericHelper2.default.getElementSelection(this.domElement); //TODO is this needed a second time?\n                        // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n                        //TODO Check if this is an Android bug or an autoNumeric one\n                        this.androidSelectionStart = selection.start;\n\n                        var decimalCharacterPosition = _AutoNumericHelper2.default.getElementValue(this.domElement).indexOf(this.settings.decimalCharacter);\n                        var hasDecimalCharacter = decimalCharacterPosition === -1;\n\n                        // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n                        if (this.eventKey === this.settings.decimalCharacter || !hasDecimalCharacter && decimalCharacterPosition < this.androidSelectionStart) {\n                            this.androidSelectionStart = selection.start + 1;\n                        }\n\n                        if (selection.length > value.length) {\n                            // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n                            this._setCaretPosition(this.androidSelectionStart);\n                        }\n\n                        this.lastVal = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n                        return;\n                    } else {\n                        // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n                        _AutoNumericHelper2.default.setElementValue(this.lastVal); //TODO Update the rawValue here too via _setValue()?\n                        _AutoNumericHelper2.default.setElementSelection(this.domElement, selection.start, selection.end);\n                        this.androidSelectionStart = selection.start;\n                    }\n\n                    e.preventDefault(); //TODO Check how that is affecting the normal trigger of the input event\n\n                    this.formatted = false;\n                } else {\n                    // Character deleted\n                    //XXX The change in length could also be the result of the `Delete` key, but there usually are no such key in the Android virtual keyboards\n                    this.eventKey = _AutoNumericEnum2.default.keyName.Backspace;\n                }\n            }\n        }\n\n        /**\n         * Handler for 'keyup' events.\n         * The user just released any key, hence one event is sent.\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeyup',\n        value: function _onKeyup(e) {\n            if (this.settings.isCancellable && this.eventKey === _AutoNumericEnum2.default.keyName.Esc) {\n                // If the user wants to cancel its modifications, we drop the 'keyup' event for the Esc key\n                e.preventDefault();\n\n                return;\n            }\n\n            // Manage the undo/redo events\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Z || this.eventKey === _AutoNumericEnum2.default.keyName.z) {\n                if (e.ctrlKey && e.shiftKey) {\n                    // Redo\n                    e.preventDefault();\n                    this._historyTableRedo();\n                    this.onGoingRedo = true;\n\n                    return;\n                } else if (e.ctrlKey && !e.shiftKey) {\n                    if (this.onGoingRedo) {\n                        // Prevent an 'undo' to be launch when releasing the shift key before the ctrl key after a 'redo' shortcut\n                        this.onGoingRedo = false;\n                    } else {\n                        e.preventDefault();\n                        // Undo\n                        this._historyTableUndo();\n\n                        return;\n                    }\n                }\n            }\n\n            if (this.onGoingRedo && (e.ctrlKey || e.shiftKey)) {\n                // Special case where if the user has entered `Control+Shift+z`, then release `z`, keeping `Control` or `Shift` pressed, then `this.onGoingRedo` is never changed back to `false` when the user release `Control` or `Shift`\n                this.onGoingRedo = false;\n            }\n\n            // Manage the reformat when hovered with the Alt key pressed\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Alt && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n\n                return;\n            }\n\n            this._updateInternalProperties(e);\n\n            var skip = this._processNonPrintableKeysAndShortcuts(e);\n            delete this.valuePartsBeforePaste;\n            var isOnAndroid = this.androidSelectionStart !== null;\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            if (skip && !isOnAndroid || targetValue === '') {\n                return;\n            }\n\n            // Added to properly place the caret when only the currency sign is present\n            if (targetValue === this.settings.currencySymbol) {\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                    _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n                } else {\n                    _AutoNumericHelper2.default.setElementSelection(e.target, this.settings.currencySymbol.length);\n                }\n            } else if (this.eventKey === _AutoNumericEnum2.default.keyName.Tab) {\n                _AutoNumericHelper2.default.setElementSelection(e.target, 0, targetValue.length);\n            }\n\n            if (targetValue === this.settings.suffixText || this.settings.rawValue === '' && this.settings.currencySymbol !== '' && this.settings.suffixText !== '') {\n                _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n            }\n\n            // Saves the extended decimal to preserve the data when navigating away from the page\n            if (this.settings.decimalPlacesShownOnFocus !== null && this.settings.saveValueToSessionStorage) {\n                this._saveValueToPersistentStorage('set');\n            }\n\n            if (!this.formatted) {\n                //TODO Is this line needed? Considering that onKeydown and onKeypress both finish by setting it to false...\n                this._formatValue(e);\n            }\n\n            // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n            if (targetValue !== this.initialValueOnKeydown) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, e.target, { oldValue: this.initialValueOnKeydown, newValue: targetValue }); //TODO Do I need to remove this since we now send this event on `set()`?\n            }\n\n            // Update the selection of the current element of the history table\n            if (this.historyTable.length > 1) {\n                var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                this.selectionStart = selection.start;\n                this.selectionEnd = selection.end;\n                this.historyTable[this.historyTableIndex].start = this.selectionStart;\n                this.historyTable[this.historyTableIndex].end = this.selectionEnd;\n            }\n        }\n\n        /**\n         * Handler for 'focusout' events\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onFocusOutAndMouseLeave',\n        value: function _onFocusOutAndMouseLeave(e) {\n            //TODO Create separate handlers for blur and mouseleave\n            //FIXME Do not call `set()` if the current raw value is the same as the one we are trying to set (currently, on focus out, `set()` is always called, even if the value has not changed\n            if (this.settings.unformatOnHover && e.type === 'mouseleave' && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n\n                return;\n            }\n\n            if (e.type === 'mouseleave' && !this.isFocused || e.type === 'blur') {\n                var origValue = this.settings.rawValue;\n\n                if (this.settings.saveValueToSessionStorage) {\n                    this._saveValueToPersistentStorage('set');\n                }\n\n                if (this.settings.noSeparatorOnFocus === true) {\n                    this.settings.digitGroupSeparator = this.originalDigitGroupSeparator;\n                    this.settings.currencySymbol = this.originalCurrencySymbol;\n                    this.settings.suffixText = this.originalSuffixText;\n                }\n\n                if (this.settings.decimalPlacesShownOnFocus !== null) {\n                    this.settings.decimalPlacesOverride = this.originalDecimalPlacesOverride;\n                    this.settings.allowDecimalPadding = this.originalAllowDecimalPadding;\n                    this.settings.negativeBracketsTypeOnBlur = this.originalNegativeBracketsTypeOnBlur;\n                }\n\n                var value = this.settings.rawValue;\n                if (this.settings.rawValue !== '') {\n                    var _constructor$_checkIf5 = this.constructor._checkIfInRangeWithOverrideOption(this.settings.rawValue, this.settings),\n                        _constructor$_checkIf6 = _slicedToArray(_constructor$_checkIf5, 2),\n                        minTest = _constructor$_checkIf6[0],\n                        maxTest = _constructor$_checkIf6[1];\n\n                    if (minTest && maxTest && !this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(this.settings.rawValue, this.settings)) {\n                        value = this._modifyNegativeSignAndDecimalCharacterForRawValue(value);\n                        this._setRawValue(this._trimLeadingAndTrailingZeros(value));\n\n                        if (this.settings.scaleDivisor) {\n                            value = value / this.settings.scaleDivisor;\n                            value = value.toString();\n                        }\n\n                        this.settings.decimalPlacesOverride = this.settings.scaleDivisor && this.settings.scaleDecimalPlaces ? Number(this.settings.scaleDecimalPlaces) : this.settings.decimalPlacesOverride;\n                        value = this.constructor._roundValue(value, this.settings);\n                        value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);\n                    } else {\n                        if (!minTest) {\n                            _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n                        }\n                        if (!maxTest) {\n                            _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n                        }\n                    }\n                } else {\n                    if (this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero) {\n                        this._setRawValue('0');\n                        value = this.constructor._roundValue('0', this.settings);\n                    } else {\n                        this._setRawValue('');\n                    }\n                }\n\n                var groupedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(value, this.settings, false);\n                if (!this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(value, this.settings)) {\n                    groupedValue = this.constructor._addGroupSeparators(value, this.settings, this.isFocused);\n                }\n\n                // Testing for `allowDecimalPadding.never` is needed to make sure we do not keep a trailing decimalCharacter (like '500.') in the element, since the raw value would still be a rightly formatted integer ('500')\n                if (groupedValue !== origValue || this.settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.never || this.settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats) {\n                    if (this.settings.scaleSymbol) {\n                        groupedValue = '' + groupedValue + this.settings.scaleSymbol;\n                    }\n\n                    this._setElementValue(groupedValue);\n                }\n\n                if (groupedValue !== this.valueOnFocus) {\n                    _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, this.domElement);\n                    delete this.valueOnFocus;\n                }\n            }\n        }\n\n        /**\n         * Handler for 'paste' event\n         *\n         * @param {Event|ClipboardEvent} e\n         */\n\n    }, {\n        key: '_onPaste',\n        value: function _onPaste(e) {\n            //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n            //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n            // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n            e.preventDefault();\n\n            var rawPastedText = e.clipboardData.getData('text/plain');\n\n            // 0. Special case if the user has selected all the input text before pasting\n            var initialFormattedValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            var selectionStart = e.target.selectionStart || 0;\n            var selectionEnd = e.target.selectionEnd || 0;\n            var selectionSize = selectionEnd - selectionStart;\n            var isAllInputTextSelected = false;\n\n            if (selectionSize === initialFormattedValue.length) {\n                isAllInputTextSelected = true;\n            }\n\n            // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n            var isPasteNegative = _AutoNumericHelper2.default.isNegativeStrict(rawPastedText);\n            if (isPasteNegative) {\n                // 1a. Remove the negative sign from the pasted text\n                rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n            }\n\n            // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n            var untranslatedPastedText = this._preparePastedText(rawPastedText);\n\n            var pastedText = void 0;\n            if (untranslatedPastedText === '.') {\n                // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n                pastedText = '.';\n            } else {\n                // Normal case\n                // Allow pasting arabic numbers\n                pastedText = _AutoNumericHelper2.default.arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n            }\n\n            // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n            if (pastedText !== '.' && (!_AutoNumericHelper2.default.isNumber(pastedText) || pastedText === '')) {\n                if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.error) {\n                    //TODO Should we send a warning instead of throwing an error?\n                    _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n                }\n\n                return;\n            }\n\n            // 4. Calculate the paste result\n            var caretPositionOnInitialTextAfterPasting = void 0;\n            var initialUnformattedNumber = this.getNumericString();\n            var isInitialValueNegative = _AutoNumericHelper2.default.isNegativeStrict(initialUnformattedNumber);\n            var isPasteNegativeAndInitialValueIsPositive = void 0;\n            var result = void 0;\n\n            // If the pasted content is negative, then the result will be negative too\n            if (isPasteNegative && !isInitialValueNegative) {\n                initialUnformattedNumber = '-' + initialUnformattedNumber;\n                isInitialValueNegative = true;\n                isPasteNegativeAndInitialValueIsPositive = true;\n            } else {\n                isPasteNegativeAndInitialValueIsPositive = false;\n            }\n\n            var leftPartContainedADot = false;\n            var leftPart = void 0;\n            var rightPart = void 0;\n            switch (this.settings.onInvalidPaste) {\n                /* 4a. Truncate paste behavior:\n                 * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n                 * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n                 * Otherwise paste all the numbers in the clipboard.\n                 * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n                 *\n                 * 4b. Replace paste behavior:\n                 * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n                 */\n                /* eslint no-case-declarations: 0 */\n                case AutoNumeric.options.onInvalidPaste.truncate:\n                case AutoNumeric.options.onInvalidPaste.replace:\n                    var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                    var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                    if (selectionStart !== selectionEnd) {\n                        // a. If there is a selection, remove the selected part, and return the left and right part\n                        result = this._preparePastedText(leftFormattedPart + rightFormattedPart);\n                    } else {\n                        // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                        result = this._preparePastedText(initialFormattedValue);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = _AutoNumericHelper2.default.setRawNegativeSign(result);\n                    }\n\n                    // Build the unformatted result string\n                    caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                        caretPositionOnInitialTextAfterPasting++;\n                        //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                    }\n\n                    leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                    rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                    if (pastedText === '.') {\n                        if (_AutoNumericHelper2.default.contains(leftPart, '.')) {\n                            // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                            // To do so, we keep that info in order to modify the caret position later\n                            leftPartContainedADot = true;\n                            leftPart = leftPart.replace('.', '');\n                        }\n\n                        rightPart = rightPart.replace('.', '');\n                    }\n                    // -- Here, we are good to go to continue on the same basis\n\n                    // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                    //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                    var minParse = _AutoNumericHelper2.default.parseStr(this.settings.minimumValue);\n                    var maxParse = _AutoNumericHelper2.default.parseStr(this.settings.maximumValue);\n                    var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                    var pastedTextIndex = 0;\n                    var modifiedLeftPart = leftPart;\n\n                    while (pastedTextIndex < pastedText.length) {\n                        // Modify the result with another pasted character\n                        modifiedLeftPart += pastedText[pastedTextIndex];\n                        result = modifiedLeftPart + rightPart;\n\n                        // Check the range limits\n                        if (!this.constructor._checkIfInRange(result, minParse, maxParse)) {\n                            // The result is out of the range limits, stop the loop here\n                            break;\n                        }\n\n                        // Save the last good known result\n                        lastGoodKnownResult = result;\n\n                        // Update the local variables for the next loop\n                        pastedTextIndex++;\n                    }\n\n                    // Update the last caret position where to insert a new number\n                    caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                    //XXX Here we have the result for the `truncate` option\n                    if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.truncate) {\n                        //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                        result = lastGoodKnownResult;\n\n                        if (leftPartContainedADot) {\n                            // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                            caretPositionOnInitialTextAfterPasting--;\n                        }\n                        break;\n                    }\n                    //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                    // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                    //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                    //    If you do get to the range limits, use the previous known good value within those limits.\n                    //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                    //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                    var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                    var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                    while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                        if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                            // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                            lastGoodKnownResultIndex++;\n                            continue;\n                        }\n\n                        // This replace one character at a time\n                        result = _AutoNumericHelper2.default.replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                        // Check the range limits\n                        if (!this.constructor._checkIfInRange(result, minParse, maxParse)) {\n                            // The result is out of the range limits, stop the loop here\n                            break;\n                        }\n\n                        // Save the last good known result\n                        lastGoodKnownResult = result;\n\n                        // Update the local variables for the next loop\n                        pastedTextIndex++;\n                        lastGoodKnownResultIndex++;\n                    }\n\n                    // Update the last caret position where to insert a new number\n                    caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n\n                    result = lastGoodKnownResult;\n\n                    break;\n                /* 4c. Normal paste behavior:\n                 * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n                 */\n                case AutoNumeric.options.onInvalidPaste.error:\n                case AutoNumeric.options.onInvalidPaste.ignore:\n                case AutoNumeric.options.onInvalidPaste.clamp:\n                default:\n                    // 1. Generate the unformatted result\n                    var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                    var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                    if (selectionStart !== selectionEnd) {\n                        // a. If there is a selection, remove the selected part, and return the left and right part\n                        result = this._preparePastedText(leftFormattedPart2 + rightFormattedPart2);\n                    } else {\n                        // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                        result = this._preparePastedText(initialFormattedValue);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = _AutoNumericHelper2.default.setRawNegativeSign(result);\n                    }\n\n                    // Build the unformatted result string\n                    caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                        caretPositionOnInitialTextAfterPasting++;\n                        //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                    }\n\n                    leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                    rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                    if (pastedText === '.') {\n                        // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                        if (_AutoNumericHelper2.default.contains(leftPart, '.')) {\n                            // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                            // To do so, we keep that info in order to modify the caret position later\n                            leftPartContainedADot = true;\n                            leftPart = leftPart.replace('.', '');\n                        }\n                        rightPart = rightPart.replace('.', '');\n                    }\n                    // -- Here, we are good to go to continue on the same basis\n\n                    // Generate the unformatted result\n                    result = '' + leftPart + pastedText + rightPart;\n\n                    // 2. Calculate the caret position in the unformatted value, for later use\n                    if (selectionStart === selectionEnd) {\n                        // There is no selection, then the caret position is set after the pasted text\n                        var indexWherePastedTextHasBeenInserted = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                        caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                    } else {\n                        if (isAllInputTextSelected) {\n                            // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                            caretPositionOnInitialTextAfterPasting = result.length;\n                        } else if (rightPart === '') {\n                            // If the user selected from the caret position to the end of the input (on the far right)\n                            caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter)) + pastedText.length;\n                        } else {\n                            // Normal case\n                            var indexSelectionEndInRawValue = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, this.settings.decimalCharacter));\n\n                            // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                            var selectedText = _AutoNumericHelper2.default.getElementValue(e.target).slice(selectionStart, selectionEnd);\n                            caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + _AutoNumericHelper2.default.countCharInText(this.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                        }\n                    }\n\n                    // Modify the caret position for special cases, only if the whole input has not been selected\n                    if (!isAllInputTextSelected) {\n                        if (isPasteNegativeAndInitialValueIsPositive) {\n                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                            caretPositionOnInitialTextAfterPasting++;\n                        }\n\n                        if (leftPartContainedADot) {\n                            // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                            caretPositionOnInitialTextAfterPasting--;\n                        }\n                    }\n            }\n\n            // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n            if (!_AutoNumericHelper2.default.isNumber(result) || result === '') {\n                if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.error) {\n                    _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                    //TODO This is not DRY ; refactor with above\n                }\n                return;\n            }\n\n            // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n            /*\n             * If 'error' (this is the default) :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, then throw an error in the console.\n             *      - Do not change the input value, do not change the current selection.\n             * If 'ignore' :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, do nothing more.\n             *      - Do not change the input value, do not change the current selection.\n             * If 'clamp' :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n             *        paste result.\n             *      - Change the caret position to be positioned on the left hand side of the decimal character.\n             * If 'truncate' :\n             *      - Truncate paste behavior.\n             *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n             *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n             *      - Change the caret position to be positioned after the last pasted character.\n             * If 'replace' :\n             *      - Replace paste behavior.\n             *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n             *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n             *      - Change the caret position to be positioned after the last pasted character.\n             */\n            var valueHasBeenSet = false;\n            var valueHasBeenClamped = false;\n            try {\n                this.set(result);\n                valueHasBeenSet = true;\n            } catch (error) {\n                var clampedValue = void 0;\n                switch (this.settings.onInvalidPaste) {\n                    case AutoNumeric.options.onInvalidPaste.clamp:\n                        clampedValue = _AutoNumericHelper2.default.clampToRangeLimits(result, this.settings);\n                        try {\n                            this.set(clampedValue);\n                        } catch (error) {\n                            _AutoNumericHelper2.default.throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                        }\n\n                        valueHasBeenClamped = true;\n                        valueHasBeenSet = true;\n                        result = clampedValue; // This is used only for setting the caret position later\n                        break;\n                    case AutoNumeric.options.onInvalidPaste.error:\n                    case AutoNumeric.options.onInvalidPaste.truncate:\n                    case AutoNumeric.options.onInvalidPaste.replace:\n                        // Throw an error message\n                        _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + this.settings.minimumValue + '] and maximum [' + this.settings.maximumValue + '] value range.');\n                    // falls through\n                    case AutoNumeric.options.onInvalidPaste.ignore:\n                    // Do nothing\n                    // falls through\n                    default:\n                        return; // ...and nothing else should be changed\n                }\n            }\n\n            // 7. Then lastly, set the caret position at the right logical place\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            var caretPositionInFormattedNumber = void 0;\n            if (valueHasBeenSet) {\n                switch (this.settings.onInvalidPaste) {\n                    case AutoNumeric.options.onInvalidPaste.clamp:\n                        if (valueHasBeenClamped) {\n                            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                                _AutoNumericHelper2.default.setElementSelection(e.target, targetValue.length - this.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                            } else {\n                                _AutoNumericHelper2.default.setElementSelection(e.target, targetValue.length); // ..and this on the far right\n                            }\n\n                            break;\n                        } // else if the value has not been clamped, the default behavior is used...\n                    // falls through\n                    case AutoNumeric.options.onInvalidPaste.error:\n                    case AutoNumeric.options.onInvalidPaste.ignore:\n                    case AutoNumeric.options.onInvalidPaste.truncate:\n                    case AutoNumeric.options.onInvalidPaste.replace:\n                    default:\n                        // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                        caretPositionInFormattedNumber = _AutoNumericHelper2.default.findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, targetValue, this.settings.decimalCharacter);\n                        _AutoNumericHelper2.default.setElementSelection(e.target, caretPositionInFormattedNumber);\n                }\n            }\n\n            // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n            if (valueHasBeenSet && initialFormattedValue !== targetValue) {\n                // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n            }\n        }\n\n        /**\n         * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n         * We also update the info of the focused state in the `this.isFocused` variable.\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onBlur',\n        value: function _onBlur(e) {\n            if (_AutoNumericHelper2.default.getElementValue(e.target) !== this.valueOnFocus) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, e.target);\n            }\n\n            // Keep track if the element is currently focused\n            this.isFocused = false;\n        }\n\n        /**\n         * Handler for 'wheel' event\n         *\n         * @param {WheelEvent} e\n         */\n\n    }, {\n        key: '_onWheel',\n        value: function _onWheel(e) {\n            // If the user is using the 'Shift' key modifier, then we ignore the wheel event\n            // This special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\n            // If that's the case, then he can use the 'Shift' modifier key while using the mouse wheel in order to bypass the increment/decrement feature\n            // This is useful on small screen where some badly configured inputs could use all the available space.\n            if (!e.shiftKey && this.settings.modifyValueOnWheel) {\n                // 0) First, save the caret position so we can set it back once the value has been changed\n                var selectionStart = e.target.selectionStart || 0;\n                var selectionEnd = e.target.selectionEnd || 0;\n\n                // 1) Get the unformatted value\n                var currentUnformattedValue = this.settings.rawValue;\n                var result = void 0;\n                if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(currentUnformattedValue)) {\n                    // If by default the input is empty, start at '0'\n                    if (this.settings.minimumValue > 0 || this.settings.maximumValue < 0) {\n                        // or if '0' is not between min and max value, 'minimumValue' if the user does a wheelup, 'maximumValue' if the user does a wheeldown\n                        if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                            result = this.settings.minimumValue;\n                        } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                            result = this.settings.maximumValue;\n                        } else {\n                            _AutoNumericHelper2.default.throwError('The event is not a \\'wheel\\' event.');\n                        }\n                    } else {\n                        result = 0;\n                    }\n                } else {\n                    result = currentUnformattedValue;\n                }\n\n                result = +result; // Typecast to a number needed for the following addition/subtraction\n\n                // 2) Increment/Decrement the value\n                // But first, choose the increment/decrement method ; fixed or progressive\n                if (_AutoNumericHelper2.default.isNumber(this.settings.wheelStep)) {\n                    var step = +this.settings.wheelStep; // Typecast to a number needed for the following addition/subtraction\n                    // Fixed method\n                    // This is the simplest method, where a fixed offset in added/subtracted from the current value\n                    if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                        // Increment\n                        result = result + step;\n                    } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                        // Decrement\n                        result = result - step;\n                    }\n                } else {\n                    // Progressive method\n                    // For this method, we calculate an offset that is in relation to the size of the current number (using only the integer part size).\n                    // The bigger the number, the bigger the offset (usually the number count in the integer part minus 3, except for small numbers where a different behavior is better for the user experience).\n                    if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                        // Increment\n                        result = _AutoNumericHelper2.default.addAndRoundToNearestAuto(result);\n                    } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                        // Decrement\n                        result = _AutoNumericHelper2.default.subtractAndRoundToNearestAuto(result);\n                    }\n                }\n\n                // 3) Set the new value so it gets formatted\n                // First clamp the result if needed\n                result = _AutoNumericHelper2.default.clampToRangeLimits(result, this.settings);\n                if (result !== +currentUnformattedValue) {\n                    // Only 'set' the value if it has changed. For instance 'set' should not happen if the user hits a limit and continue to try to go past it since we clamp the value.\n                    this.set(result);\n                }\n\n                //XXX Do not prevent if the value is not modified? From a UX point of view, preventing the wheel event when the user use it on top of an autoNumeric element should always be done, even if the value does not change. Perhaps that could affect other scripts relying on this event to be sent though.\n                e.preventDefault(); // We prevent the page to scroll while we increment/decrement the value\n\n                // 4) Finally, we set back the caret position/selection\n                // There is no need to take into account the fact that the number count could be different at the end of the wheel event ; it would be too complex and most of the time unreliable\n                this._setSelection(selectionStart, selectionEnd);\n            }\n        }\n\n        /**\n         * Handler for 'drop' event\n         *\n         * @param {DragEvent} e\n         */\n\n    }, {\n        key: '_onDrop',\n        value: function _onDrop(e) {\n            e.preventDefault();\n            var droppedText = e.dataTransfer.getData('text/plain');\n            var cleanedValue = this.unformatOther(droppedText);\n            this.set(cleanedValue);\n        }\n\n        /**\n         * Handler for 'submit' events happening on the parent <form> element\n         */\n\n    }, {\n        key: '_onFormSubmit',\n        value: function _onFormSubmit() {\n            if (this.settings.unformatOnSubmit) {\n                this._setElementValue(this.settings.rawValue);\n            }\n        }\n\n        /**\n         * Listen for the `alt` key keydown event globally, and if the event is caught, unformat the AutoNumeric element that is hovered by the mouse.\n         *\n         * @param {KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_onKeydownGlobal',\n        value: function _onKeydownGlobal(e) {\n            //TODO Find a way to keep the caret position between the alt keyup/keydown states\n            if (_AutoNumericHelper2.default.character(e) === _AutoNumericEnum2.default.keyName.Alt) {\n                var hoveredElement = _AutoNumericHelper2.default.getHoveredElement();\n                if (AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {\n                    var anElement = AutoNumeric.getAutoNumericElement(hoveredElement);\n                    this.constructor._unformatAltHovered(anElement);\n                }\n            }\n        }\n\n        /**\n         * Listen for the `alt` key keyup event globally, and if the event is caught, reformat the AutoNumeric element that is hovered by the mouse.\n         *\n         * @param {KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_onKeyupGlobal',\n        value: function _onKeyupGlobal(e) {\n            if (_AutoNumericHelper2.default.character(e) === _AutoNumericEnum2.default.keyName.Alt) {\n                var hoveredElement = _AutoNumericHelper2.default.getHoveredElement();\n                if (AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {\n                    var anElement = AutoNumeric.getAutoNumericElement(hoveredElement);\n                    this.constructor._reformatAltHovered(anElement);\n                }\n            }\n        }\n\n        /**\n         * Return `true` if the DOM element is supported by autoNumeric.\n         * A supported element is an element whitelisted in the `allowedTagList`.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isElementTagSupported',\n        value: function _isElementTagSupported() {\n            if (!_AutoNumericHelper2.default.isElement(this.domElement)) {\n                _AutoNumericHelper2.default.throwError('The DOM element is not valid, ' + this.domElement + ' given.');\n            }\n\n            return _AutoNumericHelper2.default.isInArray(this.domElement.tagName.toLowerCase(), this.allowedTagList);\n        }\n\n        /**\n         * Return `true` in the DOM element is an <input>.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isInputElement',\n        value: function _isInputElement() {\n            return this.domElement.tagName.toLowerCase() === 'input';\n        }\n\n        /**\n         * Return `true` if the input type is supported by AutoNumeric\n         *\n         * @returns {boolean}\n         * @throws\n         */\n\n    }, {\n        key: '_isInputTypeSupported',\n        value: function _isInputTypeSupported() {\n            return this.domElement.type === 'text' || this.domElement.type === 'hidden' || this.domElement.type === 'tel' || _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.domElement.type);\n        }\n\n        /**\n         * Check if the DOM element is supported by autoNumeric.\n         * A supported element is either an <input> element with the right 'type' attribute, or a tag whitelisted in the `allowedTagList`.\n         * If the check fails, this method throws.\n         * This function also set the info `this.isInputElement` which keep tracks if the DOM element is an <input> or not, and the `this.isContentEditable` if the element has the `contenteditable` attribute set to `true`.\n         *\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_checkElement',\n        value: function _checkElement() {\n            var currentElementTag = this.domElement.tagName.toLowerCase();\n\n            if (!this._isElementTagSupported()) {\n                _AutoNumericHelper2.default.throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n            }\n\n            if (this._isInputElement()) {\n                if (!this._isInputTypeSupported()) {\n                    _AutoNumericHelper2.default.throwError('The input type \"' + this.domElement.type + '\" is not supported by autoNumeric');\n                }\n\n                this.isInputElement = true;\n            } else {\n                this.isInputElement = false;\n                this.isContentEditable = this.domElement.hasAttribute('contenteditable') && this.domElement.getAttribute('contenteditable') === 'true';\n            }\n        }\n\n        /**\n         * Formats the default value on page load.\n         * This is called only if the `formatOnPageLoad` option is set to `true`.\n         *\n         * @param {number|string|null} forcedInitialValue The value that should be used for initialization, in place on the eventual html one\n         */\n\n    }, {\n        key: '_formatDefaultValueOnPageLoad',\n        value: function _formatDefaultValueOnPageLoad() {\n            var forcedInitialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var setValue = true;\n            var currentValue = void 0;\n            if (!_AutoNumericHelper2.default.isNull(forcedInitialValue)) {\n                currentValue = forcedInitialValue;\n            } else {\n                currentValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            }\n\n            if (this.isInputElement || this.isContentEditable) {\n                /*\n                 * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                 * precedence and should get formatted during the initialization (if this input value is a valid number and that the\n                 * developer wants it formatted on init (cf. the `settings.formatOnPageLoad` option)).\n                 * Note; this is true whatever the developer has set for `data-default-value-override` in the html (asp.net users).\n                 *\n                 * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n                 * But if `input.value` is set to a number, and the html `value` attribute is not set, then it means the dev has\n                 * changed the input value, and then it means we should not overwrite his own decision to do so.\n                 * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `this.domElement.hasAttribute('value')`\n                 * is false, we should ignore `defaultValueOverride` altogether.\n                 */\n                var unLocalizedCurrentValue = this.constructor._toNumericValue(currentValue, this.settings); // This allows to use a localized value on startup\n                if (!this.domElement.hasAttribute('value') || this.domElement.getAttribute('value') === '') {\n                    // Check if the `value` is valid or not\n                    if (!isNaN(Number(unLocalizedCurrentValue)) && Infinity !== unLocalizedCurrentValue) {\n                        this.set(unLocalizedCurrentValue);\n                        setValue = false;\n                    } else {\n                        // If not, inform the developer that nothing usable has been provided\n                        _AutoNumericHelper2.default.throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                    }\n                } else {\n                    /* Checks for :\n                     * - page reload from back button, and\n                     * - ASP.net form post back\n                     *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                     *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                     */\n                    if (this.settings.defaultValueOverride !== null && this.settings.defaultValueOverride.toString() !== currentValue || this.settings.defaultValueOverride === null && currentValue !== '' && currentValue !== this.domElement.getAttribute('value') || currentValue !== '' && this.domElement.getAttribute('type') === 'hidden' && !_AutoNumericHelper2.default.isNumber(unLocalizedCurrentValue)) {\n                        if (this.settings.decimalPlacesShownOnFocus !== null && this.settings.saveValueToSessionStorage || this.settings.scaleDivisor && this.settings.saveValueToSessionStorage) {\n                            this._setRawValue(this._saveValueToPersistentStorage('get'));\n                        }\n\n                        // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                        if (!this.settings.saveValueToSessionStorage) {\n                            var toStrip = void 0;\n\n                            if (this.settings.negativeBracketsTypeOnBlur !== null && this.settings.negativeSignCharacter !== '') {\n                                toStrip = this.constructor._removeBrackets(currentValue, this.settings);\n                            } else {\n                                toStrip = currentValue;\n                            }\n\n                            if ((this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) && this.settings.negativeSignCharacter !== '' && _AutoNumericHelper2.default.isNegative(currentValue)) {\n                                this._setRawValue(this.settings.negativeSignCharacter + this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused));\n                            } else {\n                                this._setRawValue(this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused));\n                            }\n                        }\n\n                        setValue = false;\n                    }\n                }\n\n                if (currentValue === '') {\n                    switch (this.settings.emptyInputBehavior) {\n                        case AutoNumeric.options.emptyInputBehavior.focus:\n                            setValue = false;\n                            break;\n                        //TODO What about the `AutoNumeric.options.emptyInputBehavior.press` value?\n                        case AutoNumeric.options.emptyInputBehavior.always:\n                            this._setElementValue(this.settings.currencySymbol);\n                            setValue = false;\n                            break;\n                        case AutoNumeric.options.emptyInputBehavior.zero:\n                            this.set('0');\n                            setValue = false;\n                            break;\n                        default:\n                        //\n                    }\n                } else if (setValue && currentValue === this.domElement.getAttribute('value')) {\n                    this.set(currentValue);\n                }\n            } else {\n                if (this.settings.defaultValueOverride === null) {\n                    this.set(currentValue);\n                } else {\n                    if (this.settings.defaultValueOverride === currentValue) {\n                        this.set(currentValue);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n         *\n         * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n         * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n         * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n         * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n         */\n\n    }, {\n        key: '_correctNegativePositiveSignPlacementOption',\n        value: function _correctNegativePositiveSignPlacementOption() {\n            // If negativePositiveSignPlacement is already set, we do not overwrite it\n            if (!_AutoNumericHelper2.default.isNull(this.settings.negativePositiveSignPlacement)) {\n                return;\n            }\n\n            if (!_AutoNumericHelper2.default.isUndefined(this.settings) && _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.negativePositiveSignPlacement) && !_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.currencySymbol)) {\n                switch (this.settings.currencySymbolPlacement) {\n                    case AutoNumeric.options.currencySymbolPlacement.suffix:\n                        this.settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix; // Default -1,234.56 €\n                        break;\n                    case AutoNumeric.options.currencySymbolPlacement.prefix:\n                        this.settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.left; // Default -$1,234.56\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                // Sets the default value if `negativePositiveSignPlacement` is `null`\n                this.settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.left;\n            }\n        }\n\n        /**\n         * Correct the `caretPositionOnFocus` and `selectOnFocus` options, since setting both leads to a conflict.\n         *\n         * @param {object} options The options passed as an argument by the user\n         * @returns {object}\n         * @private\n         */\n\n    }, {\n        key: '_calculateVMinAndVMaxIntegerSizes',\n\n\n        /**\n         * Analyze and save the minimumValue and maximumValue integer size for later uses\n         */\n        value: function _calculateVMinAndVMaxIntegerSizes() {\n            var _settings$maximumValu = this.settings.maximumValue.toString().split('.'),\n                _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n                maximumValueIntegerPart = _settings$maximumValu2[0];\n\n            var _ref = !this.settings.minimumValue && this.settings.minimumValue !== 0 ? [] : this.settings.minimumValue.toString().split('.'),\n                _ref2 = _slicedToArray(_ref, 1),\n                minimumValueIntegerPart = _ref2[0];\n\n            maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n            minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n            this.settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n            this.settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n        }\n\n        /**\n         * Modify `decimalPlacesOverride` as needed\n         */\n\n    }, {\n        key: '_correctDecimalPlacesOverrideOption',\n        value: function _correctDecimalPlacesOverrideOption() {\n            if (_AutoNumericHelper2.default.isNull(this.settings.decimalPlacesOverride)) {\n                this.settings.decimalPlacesOverride = this.constructor._maximumVMinAndVMaxDecimalLength(this.settings.minimumValue, this.settings.maximumValue);\n            }\n\n            this.originalDecimalPlacesOverride = String(this.settings.decimalPlacesOverride);\n\n            // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n            this.settings.decimalPlacesOverride = Number(this.settings.decimalPlacesOverride);\n        }\n\n        /**\n         * Sets the alternative decimal separator key.\n         */\n\n    }, {\n        key: '_setAlternativeDecimalSeparatorCharacter',\n        value: function _setAlternativeDecimalSeparatorCharacter() {\n            if (_AutoNumericHelper2.default.isNull(this.settings.decimalCharacterAlternative) && Number(this.settings.decimalPlacesOverride) > 0) {\n                if (this.settings.decimalCharacter === '.' && this.settings.digitGroupSeparator !== ',') {\n                    this.settings.decimalCharacterAlternative = ',';\n                } else if (this.settings.decimalCharacter === ',' && this.settings.digitGroupSeparator !== '.') {\n                    this.settings.decimalCharacterAlternative = '.';\n                }\n            }\n        }\n\n        /**\n         * Caches regular expressions for _stripAllNonNumberCharacters\n         *\n         * @param {object} settings\n         * @param {object} regex\n         */\n\n    }, {\n        key: '_transformOptionsValuesToDefaultTypes',\n\n\n        /**\n         * Modify the user settings to make them 'exploitable' later.\n         */\n        value: function _transformOptionsValuesToDefaultTypes() {\n            for (var key in this.settings) {\n                if (this.settings.hasOwnProperty(key)) {\n                    var value = this.settings[key];\n\n                    // Convert the strings 'true' and 'false' to booleans\n                    if (value === 'true' || value === 'false') {\n                        this.settings[key] = value === 'true';\n                    }\n\n                    // Convert numbers in options to strings\n                    //TODO Only transform the values of type 'Number' to 'String' if it's a currency number (so that we can have big numbers). Do not convert other numbers (ie. `historySize`)\n                    if (typeof value === 'number') {\n                        this.settings[key] = value.toString();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Convert the old settings options name to new ones.\n         *\n         * @param {object} options\n         */\n\n    }, {\n        key: '_setSettings',\n\n\n        /**\n         * Analyse the settings/options passed by the user, validate and clean them, then set them into `this.settings`.\n         * Note: This sets the settings to `null` if somehow the settings objet is undefined or empty\n         *\n         * @param {object} options\n         * @param {boolean} update - If set to `true`, then the settings already exists and this function only updates them instead of recreating them from scratch\n         * @throws\n         */\n        value: function _setSettings(options) {\n            var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            // If the user used old options, we convert them to new ones\n            if (update || !_AutoNumericHelper2.default.isNull(options)) {\n                this.constructor._convertOldOptionsToNewOnes(options);\n            }\n\n            if (update) {\n                // The settings are updated\n                this._mergeSettings(options);\n            } else {\n                // The settings are generated for the first time\n                this.settings = {};\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed as a parameter as well as with the HTML5 `data-*` info (via `this.domElement.dataset`), if any.\n                this._mergeSettings(this.constructor.getDefaultConfig(), this.domElement.dataset, options, { rawValue: '' });\n                this.caretFix = false;\n                this.throwInput = true; // Throw input event\n                this.allowedTagList = _AutoNumericEnum2.default.allowedTagList;\n                this.runOnce = false;\n                this.hoveredWithAlt = false; // Keep tracks if the current AutoNumeric element is hovered by the mouse cursor while `Alt` is pressed\n                this.androidSelectionStart = null; // If `null`, then we are not on an Android device (the keyCode is not always equal to 229)\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            this._transformOptionsValuesToDefaultTypes();\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            this._correctNegativePositiveSignPlacementOption();\n\n            // Set the `caretPositionOnFocus` and `selectOnFocus` options so that they do not conflict, if one of those have been set manually by the user.\n            // If order to check that, we take a look at the original options the user passed as an argument, not `this.settings` that have been merged with the default settings.\n            this.settings = this.constructor._correctCaretPositionOnFocusAndSelectOnFocusOptions(this.settings);\n\n            // Set the negative and positive signs, as needed\n            this.settings.negativeSignCharacter = this.settings.minimumValue < 0 ? '-' : '';\n            this.settings.positiveSignCharacter = this.settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object\n            this._runCallbacksFoundInTheSettingsObject();\n            this._calculateVMinAndVMaxIntegerSizes();\n            this._correctDecimalPlacesOverrideOption();\n            this._setAlternativeDecimalSeparatorCharacter();\n            this._setTrailingNegativeSignInfo();\n            this.regex = {}; // Create the object that will store the regular expressions\n            this.constructor._cachesUsualRegularExpressions(this.settings, this.regex);\n            this._setBrackets();\n\n            // Validate the settings. Both tests throws if necessary.\n            this.constructor.validate(this.settings, false, options);\n            if (_AutoNumericHelper2.default.isEmptyObj(this.settings)) {\n                _AutoNumericHelper2.default.throwError('Unable to set the settings, those are invalid ; an empty object was given.');\n            }\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            this._keepAnOriginalSettingsCopy();\n        }\n\n        /**\n         * Convert the `value` parameter that can either be :\n         * - a real number,\n         * - a string representing a real number, or\n         * - a string representing a localized number (with specific group separators and decimal character),\n         * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\n         *\n         * This function returns `NaN` if such conversion fails.\n         *\n         * @param {int|float|string} value\n         * @param {object} settings\n         * @returns {string|NaN}\n         */\n\n    }, {\n        key: '_preparePastedText',\n\n\n        /**\n         * Return the pasted text that will be used.\n         *\n         * @param {string} text\n         * @returns {string|void|XML|*}\n         */\n        value: function _preparePastedText(text) {\n            return this.constructor._stripAllNonNumberCharacters(text, this.settings, true, this.isFocused).replace(this.settings.decimalCharacter, '.');\n        }\n\n        /**\n         * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n         *\n         * @param {string} value\n         * @param {object} parsedMinValue Parsed via the `parseStr()` function\n         * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_updateInternalProperties',\n\n\n        /**\n         * Update the selection values as well as resets the internal state of the current AutoNumeric object.\n         * This keeps tracks of the current selection and resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n        value: function _updateInternalProperties() {\n            this.selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n            this.processed = false;\n            this.formatted = false;\n        }\n\n        /**\n         * Update the `event.key` attribute that triggered the given event.\n         *\n         * `event.key` describes:\n         * - the key name (if a non-printable character),\n         * - or directly the character that result from the key press used to trigger the event.\n         *\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n         * The key list is described here:\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n         *\n         * @param {Event|KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_updateEventKeyInfo',\n        value: function _updateEventKeyInfo(e) {\n            this.eventKey = _AutoNumericHelper2.default.character(e);\n        }\n\n        /**\n         * Save the unformatted element value.\n         * This is used in the 'cancellable' feature where the element value is saved on focus and input validation, to be used if the user wants to cancel his modifications by hitting the 'Escape' key.\n         *\n         * @private\n         */\n\n    }, {\n        key: '_saveCancellableValue',\n        value: function _saveCancellableValue() {\n            this.savedCancellableValue = this.settings.rawValue;\n        }\n\n        /**\n         * Set the text selection inside the input with the given start and end position.\n         *\n         * @param {int} start\n         * @param {int} end\n         * @private\n         */\n\n    }, {\n        key: '_setSelection',\n        value: function _setSelection(start, end) {\n            //TODO use this function to replace the direct calls to `setElementSelection()`, wherever possible\n            start = Math.max(start, 0);\n            end = Math.min(end, _AutoNumericHelper2.default.getElementValue(this.domElement).length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n        }\n\n        /**\n         * Set the caret position inside the input at the given position.\n         *\n         * @param {int} position\n         * @private\n         */\n\n    }, {\n        key: '_setCaretPosition',\n        value: function _setCaretPosition(position) {\n            this._setSelection(position, position);\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are left 'untouched', ie. formatted by autoNumeric.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection\n         * @private\n         */\n\n    }, {\n        key: '_getLeftAndRightPartAroundTheSelection',\n        value: function _getLeftAndRightPartAroundTheSelection() {\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are unformatted (stripped) of any non-numbers characters.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n         * @private\n         */\n\n    }, {\n        key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n        value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n            var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                left = _getLeftAndRightPartA2[0],\n                right = _getLeftAndRightPartA2[1];\n\n            if (left === '' && right === '') {\n                return ['', ''];\n            }\n\n            // If changing the sign and `left` is equal to the number zero, prevent stripping the leading zero(s)\n            var stripZeros = true;\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n\n            if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(right) && !_AutoNumericHelper2.default.isNegative(left)) {\n                // Only set the negative sign if the value is negative\n                left = '-' + left;\n                right = right.replace(this.settings.negativeSignCharacter, '');\n            }\n\n            left = AutoNumeric._stripAllNonNumberCharacters(left, this.settings, stripZeros, this.isFocused);\n            right = AutoNumeric._stripAllNonNumberCharacters(right, this.settings, false, this.isFocused);\n\n            return [left, right];\n        }\n\n        /**\n         * Strip parts from excess characters and leading zeros.\n         *\n         * @param {string} left\n         * @param {string} right\n         * @returns {[*,*,*]}\n         * @private\n         */\n\n    }, {\n        key: '_normalizeParts',\n        value: function _normalizeParts(left, right) {\n            //TODO Refactor with `_getUnformattedLeftAndRightPartAroundTheSelection` which share a lot of similar code\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n            var stripZeros = true;\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n\n            if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(right) && !_AutoNumericHelper2.default.isNegative(left)) {\n                // Only set the negative sign if the value is negative\n                left = '-' + left;\n                right = right.replace(this.settings.negativeSignCharacter, '');\n            }\n\n            left = AutoNumeric._stripAllNonNumberCharacters(left, this.settings, stripZeros, this.isFocused);\n            right = AutoNumeric._stripAllNonNumberCharacters(right, this.settings, false, this.isFocused);\n\n            // Prevents multiple leading zeros from being entered\n            if (this.settings.leadingZero === AutoNumeric.options.leadingZero.deny && (this.eventKey === _AutoNumericEnum2.default.keyName.num0 || this.eventKey === _AutoNumericEnum2.default.keyName.numpad0) && Number(left) === 0 &&\n            // If `right` is not empty and the first character is not `decimalCharacter`\n            !_AutoNumericHelper2.default.contains(left, this.settings.decimalCharacter) && right !== '') {\n                left = left.substring(0, left.length - 1);\n            }\n\n            // Insert zero there is a leading dot\n            var newValue = left + right;\n            if (this.settings.decimalCharacter) {\n                var m = newValue.match(new RegExp('^' + this.regex.aNegRegAutoStrip + '\\\\' + this.settings.decimalCharacter));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    newValue = left + right;\n                }\n            }\n\n            return [left, right, newValue];\n        }\n\n        /**\n         * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n         * This function also sets the raw value.\n         *\n         * @param {string} left\n         * @param {string} right\n         * @param {boolean} isPaste\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_setValueParts',\n        value: function _setValueParts(left, right) {\n            var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var _normalizeParts2 = this._normalizeParts(left, right),\n                _normalizeParts3 = _slicedToArray(_normalizeParts2, 3),\n                normalizedLeft = _normalizeParts3[0],\n                normalizedRight = _normalizeParts3[1],\n                normalizedNewValue = _normalizeParts3[2];\n\n            var _AutoNumeric$_checkIf = AutoNumeric._checkIfInRangeWithOverrideOption(normalizedNewValue, this.settings),\n                _AutoNumeric$_checkIf2 = _slicedToArray(_AutoNumeric$_checkIf, 2),\n                minTest = _AutoNumeric$_checkIf2[0],\n                maxTest = _AutoNumeric$_checkIf2[1];\n\n            var position = normalizedLeft.length;\n            var newValue = normalizedNewValue;\n\n            if (minTest && maxTest) {\n                newValue = AutoNumeric._truncateDecimalPlaces(newValue, this.settings, isPaste);\n                //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                var testValue = _AutoNumericHelper2.default.contains(newValue, ',') ? newValue.replace(',', '.') : newValue;\n                if (testValue === '' || testValue === this.settings.negativeSignCharacter) {\n                    this._setRawValue(this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero ? '0' : '');\n                } else {\n                    this._setRawValue(this._trimLeadingAndTrailingZeros(testValue));\n                }\n\n                if (position > newValue.length) {\n                    position = newValue.length;\n                }\n\n                // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                if (position === 1 && normalizedLeft === '0' && this.settings.leadingZero === AutoNumeric.options.leadingZero.deny) {\n                    // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                    if (normalizedRight === '' || normalizedLeft === '0' && normalizedRight !== '') {\n                        position = 1;\n                    } else {\n                        position = 0;\n                    }\n                }\n\n                _AutoNumericHelper2.default.setElementValue(this.domElement, newValue);\n                this._setCaretPosition(position);\n\n                return true;\n            }\n\n            if (!minTest) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n            } else if (!maxTest) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n            }\n\n            return false;\n        }\n\n        /**\n         * Helper function for `_expandSelectionOnSign()`.\n         *\n         * @returns {Array} Array containing [signPosition, currencySymbolPosition] of a formatted value\n         * @private\n         */\n\n    }, {\n        key: '_getSignPosition',\n        value: function _getSignPosition() {\n            var result = void 0;\n            if (this.settings.currencySymbol) {\n                var currencySymbolLen = this.settings.currencySymbol.length;\n                var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                    var hasNeg = this.settings.negativeSignCharacter && value && value.charAt(0) === this.settings.negativeSignCharacter;\n                    if (hasNeg) {\n                        result = [1, currencySymbolLen + 1];\n                    } else {\n                        result = [0, currencySymbolLen];\n                    }\n                } else {\n                    var valueLen = value.length;\n                    result = [valueLen - currencySymbolLen, valueLen];\n                }\n            } else {\n                result = [1000, -1];\n            }\n\n            return result;\n        }\n\n        /**\n         * Expands selection to cover whole sign\n         * Prevents partial deletion/copying/overwriting of a sign\n         * @private\n         */\n\n    }, {\n        key: '_expandSelectionOnSign',\n        value: function _expandSelectionOnSign() {\n            var _getSignPosition2 = this._getSignPosition(),\n                _getSignPosition3 = _slicedToArray(_getSignPosition2, 2),\n                signPosition = _getSignPosition3[0],\n                currencySymbolPosition = _getSignPosition3[1];\n\n            var selection = this.selection;\n\n            // If selection catches something except sign and catches only space from sign\n            if (selection.start < currencySymbolPosition && selection.end > signPosition) {\n                // Then select without empty space\n                if ((selection.start < signPosition || selection.end > currencySymbolPosition) && _AutoNumericHelper2.default.getElementValue(this.domElement).substring(Math.max(selection.start, signPosition), Math.min(selection.end, currencySymbolPosition)).match(/^\\s*$/)) {\n                    if (selection.start < signPosition) {\n                        this._setSelection(selection.start, signPosition);\n                    } else {\n                        this._setSelection(currencySymbolPosition, selection.end);\n                    }\n                } else {\n                    // Else select with whole sign\n                    this._setSelection(Math.min(selection.start, signPosition), Math.max(selection.end, currencySymbolPosition));\n                }\n            }\n        }\n\n        /**\n         * Try to strip pasted value to digits\n         */\n\n    }, {\n        key: '_checkPaste',\n        value: function _checkPaste() {\n            if (!_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                    left = _getLeftAndRightPartA4[0],\n                    right = _getLeftAndRightPartA4[1];\n\n                // Try to strip the pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + AutoNumeric._stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settings, true, this.isFocused);\n                if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, oldParts.join(''));\n                    this._setCaretPosition(oldParts[0].length);\n                }\n            }\n        }\n\n        /**\n         * Return `true` is the given key should be ignored or not.\n         *\n         * @param {string} eventKeyName\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_processNonPrintableKeysAndShortcuts',\n\n\n        /**\n         * Process copying, cutting and pasting, as well as undo/redoing and cursor moving.\n         * Return `true` if further processing should not be performed.\n         *\n         * @param {KeyboardEvent} e\n         * @returns {boolean}\n         * @private\n         */\n        value: function _processNonPrintableKeysAndShortcuts(e) {\n            // Catch the ctrl up on ctrl-v\n            if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                //TODO Move this test inside the `onKeyup` handler\n                this._checkPaste();\n\n                return false;\n            }\n\n            // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n            if (this.constructor._shouldSkipEventKey(this.eventKey)) {\n                return true;\n            }\n\n            // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n            if ((e.ctrlKey || e.metaKey) && this.eventKey === _AutoNumericEnum2.default.keyName.a) {\n                if (this.settings.selectNumberOnly) {\n                    // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                    e.preventDefault();\n                    //TODO replace `selectNumber` by `select`?\n                    this.selectNumber();\n                }\n\n                return true;\n            }\n\n            // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n            if ((e.ctrlKey || e.metaKey) && (this.eventKey === _AutoNumericEnum2.default.keyName.c || this.eventKey === _AutoNumericEnum2.default.keyName.v || this.eventKey === _AutoNumericEnum2.default.keyName.x)) {\n                if (e.type === 'keydown') {\n                    this._expandSelectionOnSign();\n                }\n\n                // Try to prevent wrong paste\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.v || this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                        }\n                    } else {\n                        this._checkPaste();\n                    }\n                }\n\n                return e.type === 'keydown' || e.type === 'keypress' || this.eventKey === _AutoNumericEnum2.default.keyName.c;\n            }\n\n            if (e.ctrlKey || e.metaKey) {\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.Z || this.eventKey === _AutoNumericEnum2.default.keyName.z) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n\n            // Jump over the thousand separator\n            //TODO Move this test inside the `onKeydown` handler\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.LeftArrow || this.eventKey === _AutoNumericEnum2.default.keyName.RightArrow) {\n                if (e.type === 'keydown' && !e.shiftKey) {\n                    var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n                    if (this.eventKey === _AutoNumericEnum2.default.keyName.LeftArrow && (value.charAt(this.selection.start - 2) === this.settings.digitGroupSeparator || value.charAt(this.selection.start - 2) === this.settings.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start - 1);\n                    } else if (this.eventKey === _AutoNumericEnum2.default.keyName.RightArrow && (value.charAt(this.selection.start + 1) === this.settings.digitGroupSeparator || value.charAt(this.selection.start + 1) === this.settings.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start + 1);\n                    }\n                }\n\n                return true;\n            }\n\n            return _AutoNumericHelper2.default.isInArray(this.eventKey, _AutoNumericEnum2.default.keyName._directionKeys);\n        }\n\n        /**\n         * Process deletion of characters when the minus sign is to the right of the numeric characters.\n         *\n         * @param {string} left The part on the left of the caret or selection\n         * @param {string} right The part on the right of the caret or selection\n         * @returns {[string, string]}\n         * @private\n         */\n\n    }, {\n        key: '_processCharacterDeletionIfTrailingNegativeSign',\n        value: function _processCharacterDeletionIfTrailingNegativeSign(_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                left = _ref4[0],\n                right = _ref4[1];\n\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix) {\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                    this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== '';\n                    if (value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= value.length - this.settings.suffixText.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== '';\n                    if (this.selection.start >= value.indexOf(this.settings.currencySymbol) + this.settings.currencySymbol.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (_AutoNumericHelper2.default.isNegative(left) && value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                switch (this.settings.negativePositiveSignPlacement) {\n                    case AutoNumeric.options.negativePositiveSignPlacement.left:\n                        this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;\n                        if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length && _AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            } else if (left !== '-' && (this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) || !_AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter))) {\n                                left = left.substring(0, left.length - 1);\n                            }\n                        } else {\n                            if (left[0] === '-') {\n                                right = right.substring(1);\n                            }\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) && _AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            }\n                        }\n                        break;\n                    case AutoNumeric.options.negativePositiveSignPlacement.right:\n                        this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;\n                        if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length) {\n                                left = left.substring(1);\n                            } else if (left !== '-' && this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) - this.settings.currencySymbol.length) {\n                                left = left.substring(0, left.length - 1);\n                            } else if (left !== '' && !_AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(0, left.length - 1);\n                            }\n                        } else {\n                            this.caretFix = this.selection.start >= value.indexOf(this.settings.currencySymbol) && this.settings.currencySymbol !== '';\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            }\n\n                            right = right.substring(1);\n                        }\n                        break;\n                }\n            }\n\n            return [left, right];\n        }\n\n        /**\n         * Process the deletion of characters.\n         */\n\n    }, {\n        key: '_processCharacterDeletion',\n        value: function _processCharacterDeletion() {\n            var left = void 0;\n            var right = void 0;\n\n            if (!this.selection.length) {\n                var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                left = _getUnformattedLeftAn2[0];\n                right = _getUnformattedLeftAn2[1];\n\n                if (left === '' && right === '') {\n                    this.throwInput = false;\n                }\n\n                if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(_AutoNumericHelper2.default.getElementValue(this.domElement))) {\n                    var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\n\n                    var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                    left = _processCharacterDele2[0];\n                    right = _processCharacterDele2[1];\n                } else {\n                    if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                        left = left.substring(0, left.length - 1);\n                    } else {\n                        right = right.substring(1, right.length);\n                    }\n                }\n            } else {\n                this._expandSelectionOnSign();\n\n                var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                left = _getUnformattedLeftAn4[0];\n                right = _getUnformattedLeftAn4[1];\n            }\n\n            this._setValueParts(left, right);\n        }\n\n        /**\n         * Return `true` if the key is allowed.\n         * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n         * //TODO This should use another function in order to separate the test and the modification\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_processCharacterInsertion',\n        value: function _processCharacterInsertion() {\n            var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                left = _getUnformattedLeftAn6[0],\n                right = _getUnformattedLeftAn6[1];\n\n            if (this.eventKey !== _AutoNumericEnum2.default.keyName.AndroidDefault) {\n                this.throwInput = true;\n            }\n\n            // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // Do not allow decimal character if no decimal part allowed\n            if (this.eventKey === this.settings.decimalCharacter || this.settings.decimalCharacterAlternative && this.eventKey === this.settings.decimalCharacterAlternative || this.eventKey === '.' || this.eventKey === ',' || this.eventKey === _AutoNumericEnum2.default.keyName.NumpadDot) {\n                if (!this.settings.decimalPlacesOverride || !this.settings.decimalCharacter) {\n                    return true;\n                }\n\n                // Do not allow decimal character before negativeSignCharacter character\n                if (this.settings.negativeSignCharacter && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    return true;\n                }\n\n                // Do not allow a decimal character if another decimal character is already present\n                if (_AutoNumericHelper2.default.contains(left, this.settings.decimalCharacter)) {\n                    return true;\n                }\n\n                if (right.indexOf(this.settings.decimalCharacter) > 0) {\n                    return true;\n                }\n\n                if (right.indexOf(this.settings.decimalCharacter) === 0) {\n                    right = right.substr(1);\n                }\n\n                this._setValueParts(left + this.settings.decimalCharacter, right);\n\n                return true;\n            }\n\n            // Prevent entering the minus sign if it's not allowed (Note: `this.settings.negativeSignCharacter` is only set if the minimumValue or maximumValue is lower than zero, allowing negative numbers to be entered)\n            if ((this.eventKey === '-' || this.eventKey === '+') && this.settings.negativeSignCharacter === '-') {\n                if (left === '' && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    // The value is originally negative (with a trailing negative sign)\n                    right = right.replace(this.settings.negativeSignCharacter, '');\n                } else if (_AutoNumericHelper2.default.isNegative(left)) {\n                    // The value is originally negative (with a leading negative sign)\n                    // Remove the negative sign, effectively converting the value to a positive one\n                    left = left.replace('-', ''); //TODO replace with '+' if `showPositiveSign`?\n                } else {\n                    // The value is originally positive\n                    left = this.settings.negativeSignCharacter + left;\n                }\n\n                this._setValueParts(left, right);\n\n                return true;\n            }\n\n            // If the user tries to insert a digit before the minus sign\n            var eventNumber = Number(this.eventKey);\n            if (eventNumber >= 0 && eventNumber <= 9) {\n                if (this.settings.negativeSignCharacter && left === '' && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    left = this.settings.negativeSignCharacter;\n                    right = right.substring(1, right.length);\n                }\n\n                if (this.settings.maximumValue <= 0 && this.settings.minimumValue < this.settings.maximumValue && !_AutoNumericHelper2.default.contains(_AutoNumericHelper2.default.getElementValue(this.domElement), this.settings.negativeSignCharacter) && this.eventKey !== '0') {\n                    left = this.settings.negativeSignCharacter + left;\n                }\n\n                this._setValueParts(left + this.eventKey, right);\n\n                return true;\n            }\n\n            // Prevent any other characters\n            this.throwInput = false;\n\n            return false;\n        }\n\n        /**\n         * Formatting of just processed value while keeping the cursor position\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_formatValue',\n        value: function _formatValue(e) {\n            var _this5 = this;\n\n            var elementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                left = _getUnformattedLeftAn8[0];\n\n            // No grouping separator and no currency sign\n\n\n            if ((this.settings.digitGroupSeparator === '' || this.settings.digitGroupSeparator !== '' && !_AutoNumericHelper2.default.contains(elementValue, this.settings.digitGroupSeparator)) && (this.settings.currencySymbol === '' || this.settings.currencySymbol !== '' && !_AutoNumericHelper2.default.contains(elementValue, this.settings.currencySymbol))) {\n                var _elementValue$split = elementValue.split(this.settings.decimalCharacter),\n                    _elementValue$split2 = _slicedToArray(_elementValue$split, 1),\n                    subParts = _elementValue$split2[0];\n\n                var negativeSign = '';\n                if (_AutoNumericHelper2.default.isNegative(subParts)) {\n                    negativeSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // Strip leading zero on positive value if needed\n                if (negativeSign === '' && subParts.length > this.settings.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // Strip leading zero on negative value if needed\n                if (negativeSign === '-' && subParts.length > this.settings.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                left = negativeSign + left;\n            }\n\n            var value = this.constructor._addGroupSeparators(elementValue, this.settings, this.isFocused);\n            var position = value.length;\n            if (value) {\n                // Prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // Fixes caret position with trailing minus sign\n                if ((this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) && leftAr[0] === '-' && this.settings.negativeSignCharacter !== '') {\n                    leftAr.shift();\n\n                    if ((this.eventKey === _AutoNumericEnum2.default.keyName.Backspace || this.eventKey === _AutoNumericEnum2.default.keyName.Delete) && this.caretFix) {\n                        if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix) {\n                            leftAr.push('-');\n                            this.caretFix = e.type === 'keydown';\n                        }\n\n                        if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.right) {\n                            (function () {\n                                var signParts = _this5.settings.currencySymbol.split('');\n                                var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                var escapedParts = [];\n                                signParts.forEach(function (i, miniParts) {\n                                    miniParts = signParts[i];\n                                    if (_AutoNumericHelper2.default.isInArray(miniParts, escapeChr)) {\n                                        escapedParts.push('\\\\' + miniParts);\n                                    } else {\n                                        escapedParts.push(miniParts);\n                                    }\n                                });\n\n                                if (_this5.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                                    escapedParts.push('-');\n                                }\n\n                                // Pushing the escaped sign\n                                leftAr.push(escapedParts.join(''));\n                                _this5.caretFix = e.type === 'keydown';\n                            })();\n                        }\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // Search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // If the positive sign is shown, calculate the caret position accordingly\n                    if (this.settings.showPositiveSign) {\n                        if (position === 0 && newLeft.input.charAt(0) === this.settings.positiveSignCharacter) {\n                            position = newLeft.input.indexOf(this.settings.currencySymbol) === 1 ? this.settings.currencySymbol.length + 1 : 1;\n                        }\n\n                        if (position === 0 && newLeft.input.charAt(this.settings.currencySymbol.length) === this.settings.positiveSignCharacter) {\n                            position = this.settings.currencySymbol.length + 1;\n                        }\n                    }\n\n                    // If we are just before the sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== this.settings.negativeSignCharacter || position === 1 && value.charAt(0) === this.settings.negativeSignCharacter) && this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                        // Place caret after prefix sign\n                        //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                        position = this.settings.currencySymbol.length + (_AutoNumericHelper2.default.isNegativeStrict(value) ? 1 : 0);\n                    }\n                } else {\n                    if (this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                        // If we could not find a place for cursor and have a sign as a suffix\n                        // Place caret before suffix currency sign\n                        position -= this.settings.currencySymbol.length;\n                    }\n\n                    if (this.settings.suffixText) {\n                        // If we could not find a place for cursor and have a suffix\n                        // Place caret before suffix\n                        position -= this.settings.suffixText.length;\n                    }\n                }\n            }\n\n            // Only update the value if it has changed. This prevents modifying the selection, if any.\n            if (value !== elementValue || value === elementValue && (this.eventKey === _AutoNumericEnum2.default.keyName.num0 || this.eventKey === _AutoNumericEnum2.default.keyName.numpad0)) {\n                this._setElementValue(value);\n                this._setCaretPosition(position);\n            }\n\n            if (this.androidSelectionStart !== null) {\n                // If an Android browser is detected, fix the caret position\n                // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n                // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n                this._setCaretPosition(this.androidSelectionStart);\n            }\n\n            this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n        }\n\n        /**\n         * Serialize the form child <input> element values to a string, or an Array.\n         * The output format is defined with the `formatType` argument.\n         * This is loosely based upon http://stackoverflow.com/a/40705993/2834898.\n         *\n         * @param {HTMLFormElement} form\n         * @param {boolean} intoAnArray If `true`, instead of generating a string, it generates an Array.\n         * @param {string} formatType If `'unformatted'`, then the AutoNumeric elements values are unformatted, if `'localized'`, then the AutoNumeric elements values are localized, and if `'formatted'`, then the AutoNumeric elements values are kept formatted. In either way, this function does not modify the value of each DOM element, but only affect the value that is returned by that serialize function.\n         * @param {string} serializedSpaceCharacter Can either be the '+' character, or the '%20' string.\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {string|Array}\n         * @private\n         */\n\n    }], [{\n        key: 'version',\n        value: function version() {\n            return '4.0.0-beta.16';\n        }\n\n        /**\n         * Take the parameters given to the AutoNumeric object, and output the three variables that are needed to finish initializing it :\n         * - domElement : The target DOM element\n         * - initialValue : The initial value, or `null` if none is given\n         * - userOptions : The option object\n         *\n         * @param {object|Array|number|string} arg1\n         * @param {object|Array|number|string|null} arg2\n         * @param {object|Array|number|string|null} arg3\n         * @returns {{domElement: *, initialValue: *, userOptions: *}}\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_setArgumentsValues',\n        value: function _setArgumentsValues(arg1, arg2, arg3) {\n            // Basic check on the argument count\n            if (_AutoNumericHelper2.default.isNull(arg1)) {\n                _AutoNumericHelper2.default.throwError('At least one valid parameter is needed in order to initialize an AutoNumeric object');\n            }\n\n            // Prepare the arguments in order to create the AutoNumeric object with the right values\n            // Test the argument types\n            var isArg1Element = _AutoNumericHelper2.default.isElement(arg1);\n            var isArg1String = _AutoNumericHelper2.default.isString(arg1);\n\n            var isArg2Object = _AutoNumericHelper2.default.isObject(arg2);\n            var isArg2Number = _AutoNumericHelper2.default.isNumberOrArabic(arg2) || arg2 === '';\n            var isArg2Null = _AutoNumericHelper2.default.isNull(arg2);\n            var isArg2EmptyString = _AutoNumericHelper2.default.isEmptyString(arg2);\n\n            var isArg3Object = _AutoNumericHelper2.default.isObject(arg3);\n            var isArg3Null = _AutoNumericHelper2.default.isNull(arg3);\n\n            // Given the parameters passed, sort the data and return a stable state before the initialization\n            var domElement = void 0;\n            var userOptions = void 0;\n            var initialValue = void 0;\n\n            if (isArg1Element && isArg2Null && isArg3Null) {\n                // new AutoNumeric(domElement); // With the default options\n                domElement = arg1;\n                initialValue = null;\n                userOptions = null;\n            } else if (isArg1Element && isArg2Number && isArg3Null) {\n                // new AutoNumeric(domElement, 12345.789); // With the default options, and an initial value\n                // new AutoNumeric(domElement, '12345.789');\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = null;\n            } else if (isArg1Element && isArg2Object && isArg3Null) {\n                // new AutoNumeric(domElement, { options }); // With one option object\n                domElement = arg1;\n                initialValue = null;\n                userOptions = arg2;\n            } else if (isArg1Element && (isArg2Null || isArg2EmptyString) && isArg3Object) {\n                // new AutoNumeric(domElement, null, { options }); // With one option object\n                domElement = arg1;\n                initialValue = null;\n                userOptions = arg3;\n            } else if (isArg1String && isArg2Null && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input');\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = null;\n            } else if (isArg1String && isArg2Object && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', { options });\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = arg2;\n            } else if (isArg1String && (isArg2Null || isArg2EmptyString) && isArg3Object) {\n                // new AutoNumeric('.myCssClass > input', null, { options });\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = arg3;\n            } else if (isArg1String && isArg2Number && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', 12345.789);\n                // new AutoNumeric('.myCssClass > input', '12345.789');\n                // new AutoNumeric('.myCssClass > input', '');\n                domElement = document.querySelector(arg1);\n                initialValue = arg2;\n                userOptions = null;\n            } else if (isArg1String && isArg2Number && isArg3Object) {\n                // new AutoNumeric('.myCssClass > input', 12345.789, { options });\n                // new AutoNumeric('.myCssClass > input', '12345.789', { options });\n                // new AutoNumeric('.myCssClass > input', '', { options });\n                domElement = document.querySelector(arg1);\n                initialValue = arg2;\n                userOptions = arg3;\n            } else if (isArg1Element && isArg2Number && isArg3Object) {\n                // new AutoNumeric(domElement, 12345.789, { options });\n                // new AutoNumeric(domElement, '12345.789', { options });\n                // new AutoNumeric(domElement, '', { options });\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = arg3;\n            } else {\n                _AutoNumericHelper2.default.throwError('The parameters given to the AutoNumeric object are not valid, \\'' + arg1 + '\\', \\'' + arg2 + '\\' and \\'' + arg3 + '\\' given.');\n            }\n\n            if (_AutoNumericHelper2.default.isNull(domElement)) {\n                _AutoNumericHelper2.default.throwError('The selector \\'' + arg1 + '\\' did not select any valid DOM element. Please check on which element you called AutoNumeric.');\n            }\n\n            return { domElement: domElement, initialValue: initialValue, userOptions: userOptions };\n        }\n    }, {\n        key: '_unformatAltHovered',\n        value: function _unformatAltHovered(anElement) {\n            anElement.hoveredWithAlt = true;\n            anElement.unformat();\n        }\n\n        /**\n         * Reformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.\n         *\n         * @param {AutoNumeric} anElement\n         * @private\n         */\n\n    }, {\n        key: '_reformatAltHovered',\n        value: function _reformatAltHovered(anElement) {\n            anElement.hoveredWithAlt = false;\n            anElement.reformat();\n        }\n\n        /**\n         * Return an array of autoNumeric elements, child of the <form> element passed as a parameter.\n         *\n         * @param {HTMLElement} formNode\n         * @returns {Array}\n         * @private\n         */\n\n    }, {\n        key: '_getChildANInputElement',\n        value: function _getChildANInputElement(formNode) {\n            var _this6 = this;\n\n            //FIXME à tester\n            var inputList = formNode.getElementsByTagName('input');\n\n            // Loop this list and keep only the inputs that are managed by AutoNumeric\n            var autoNumericInputs = [];\n            var inputElements = Array.prototype.slice.call(inputList, 0);\n            inputElements.forEach(function (input) {\n                if (_this6.test(input)) {\n                    autoNumericInputs.push(input);\n                }\n            });\n\n            return autoNumericInputs;\n        }\n\n        // Static methods\n        /**\n         * Test if the given domElement is already managed by AutoNumeric (if it has been initialized on the current page).\n         *\n         * @param {HTMLElement} domElement\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'test',\n        value: function test(domElement) {\n            return this._isInGlobalList(domElement);\n        }\n\n        /**\n         * Create a WeakMap with the given name.\n         *\n         * @param {string} weakMapName\n         * @private\n         */\n\n    }, {\n        key: '_createWeakMap',\n        value: function _createWeakMap(weakMapName) {\n            window[weakMapName] = new WeakMap();\n        }\n\n        /**\n         * Create a list of all the AutoNumeric elements that are initialized on the current page.\n         * This is needed in order to determine if a given dom element is already managed by autoNumeric.\n         * This uses a WeakMap in order to limit potential garbage collection problems.\n         * (cf. my tests on http://codepen.io/AnotherLinuxUser/pen/pRQGaM?editors=1011)\n         * @private\n         */\n\n    }, {\n        key: '_createGlobalList',\n        value: function _createGlobalList() {\n            // The check that this global list does not exists already is done in the add and remove functions already\n            this.autoNumericGlobalListName = 'autoNumericGlobalList'; //XXX This looks weird to set a variable on `this.` in a static method, but that really declare that variable like a static property\n            // Note: I should not get any memory leaks for referencing the DOM element in the `value`, this DOM element also being the `key`, according to the spec : http://www.ecma-international.org/ecma-262/6.0/#sec-weakmap-objects\n            this._createWeakMap(this.autoNumericGlobalListName);\n        }\n\n        /**\n         * Return `true` if the global AutoNumeric element list exists.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_doesGlobalListExists',\n        value: function _doesGlobalListExists() {\n            var type = _typeof(window[this.autoNumericGlobalListName]);\n            return type !== 'undefined' && type === 'object';\n        }\n\n        /**\n         * Add the given object to the global AutoNumeric element list.\n         *\n         * @param {AutoNumeric} autoNumericObject\n         * @private\n         */\n\n    }, {\n        key: '_addToGlobalList',\n        value: function _addToGlobalList(autoNumericObject) {\n            if (!this._doesGlobalListExists()) {\n                this._createGlobalList();\n            }\n\n            var domElement = autoNumericObject.node();\n            // This checks if the object is not already in the global list before adding it.\n            // This could happen if an AutoNumeric element is initialized, then the DOM element is removed directly via `removeChild` (hence the reference does not get removed from the global list), then it get recreated and initialized again\n            if (this._isInGlobalList(domElement)) {\n                if (this._getFromGlobalList(domElement) === this) {\n                    // Do not add this AutoNumeric object again since it's already in that global list\n                    return;\n                } else {\n                    // Print a warning to warn that the domElement already has a reference in the global map (but we cannot for sure starts deleting those old references since they could still be used by another AutoNumeric object)\n                    _AutoNumericHelper2.default.warning('A reference to the DOM element you just initialized already exists in the global AutoNumeric element list. Please make sure to not initialize the same DOM element multiple times.');\n                }\n            }\n\n            window[this.autoNumericGlobalListName].set(domElement, autoNumericObject);\n        }\n\n        /**\n         * Remove the given object from the global AutoNumeric element list.\n         *\n         * @param {AutoNumeric} autoNumericObject\n         * @private\n         */\n\n    }, {\n        key: '_removeFromGlobalList',\n        value: function _removeFromGlobalList(autoNumericObject) {\n            //FIXME à tester\n            if (this._doesGlobalListExists()) {\n                window[this.autoNumericGlobalListName].delete(autoNumericObject.node());\n            }\n        }\n\n        /**\n         * Return the value associated to the key `domElement` passed as a parameter.\n         * The value is the AutoNumeric object that manages the DOM element `domElement`.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {null|AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_getFromGlobalList',\n        value: function _getFromGlobalList(domElement) {\n            //FIXME à tester\n            if (this._doesGlobalListExists()) {\n                return window[this.autoNumericGlobalListName].get(domElement);\n            }\n\n            return null;\n        }\n\n        /**\n         * Check if the given DOM element is in the global AutoNumeric element list.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isInGlobalList',\n        value: function _isInGlobalList(domElement) {\n            //FIXME à tester\n            if (!this._doesGlobalListExists()) {\n                return false;\n            }\n\n            return window[this.autoNumericGlobalListName].has(domElement);\n        }\n    }, {\n        key: 'validate',\n        value: function validate(userOptions) {\n            var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var originalOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(userOptions) || !_AutoNumericHelper2.default.isObject(userOptions)) {\n                _AutoNumericHelper2.default.throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n            }\n\n            var isOriginalOptionAnObject = _AutoNumericHelper2.default.isObject(originalOptions);\n            if (!isOriginalOptionAnObject && !_AutoNumericHelper2.default.isNull(originalOptions)) {\n                _AutoNumericHelper2.default.throwError('The \\'originalOptions\\' parameter is invalid ; it should either be a valid option object or `null`, [' + userOptions + '] given.');\n            }\n\n            // If the user used old options, we convert them to new ones\n            if (!_AutoNumericHelper2.default.isNull(userOptions)) {\n                this._convertOldOptionsToNewOnes(userOptions);\n            }\n\n            // The user can choose if the `userOptions` has already been extended with the default options, or not\n            var options = void 0;\n            if (shouldExtendDefaultOptions) {\n                options = _extends({}, this.getDefaultConfig(), userOptions);\n            } else {\n                options = userOptions;\n            }\n\n            // First things first, we test that the `showWarnings` option is valid\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.showWarnings) && !_AutoNumericHelper2.default.isBoolean(options.showWarnings)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n            }\n\n            // Define the regular expressions needed for the following tests\n            var testPositiveInteger = /^[0-9]+$/;\n            var testNumericalCharacters = /[0-9]+/;\n            // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n            var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n            var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n            // Then tests the options individually\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.allowDecimalPadding) && !_AutoNumericHelper2.default.isBoolean(options.allowDecimalPadding) && options.allowDecimalPadding !== AutoNumeric.options.allowDecimalPadding.floats) {\n                _AutoNumericHelper2.default.throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\', \\'true\\' or \\'floats\\', [' + options.allowDecimalPadding + '] given.');\n            }\n\n            if (!options.allowDecimalPadding && !_AutoNumericHelper2.default.isNull(options.decimalPlacesOverride)) {\n                _AutoNumericHelper2.default.warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.caretPositionOnFocus) && !_AutoNumericHelper2.default.isInArray(options.caretPositionOnFocus, [AutoNumeric.options.caretPositionOnFocus.start, AutoNumeric.options.caretPositionOnFocus.end, AutoNumeric.options.caretPositionOnFocus.decimalLeft, AutoNumeric.options.caretPositionOnFocus.decimalRight])) {\n                _AutoNumericHelper2.default.throwError('The display on empty string option \\'caretPositionOnFocus\\' is invalid ; it should either be `null`, \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.caretPositionOnFocus + '] given.');\n            }\n\n            // Special case here for `caretPositionOnFocus` and `selectOnFocus` where we need to check the original non-tempered version of the options in order to check for conflicts, since using the default settings remove those and would prevent us warning the user that his option object is not correct.\n            var optionsToUse = void 0;\n            if (isOriginalOptionAnObject) {\n                optionsToUse = originalOptions;\n            } else {\n                optionsToUse = this._correctCaretPositionOnFocusAndSelectOnFocusOptions(userOptions);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(optionsToUse) && optionsToUse.caretPositionOnFocus !== AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition && optionsToUse.selectOnFocus === AutoNumeric.options.selectOnFocus.select) {\n                _AutoNumericHelper2.default.warning('The \\'selectOnFocus\\' option is set to \\'select\\', which is in conflict with the \\'caretPositionOnFocus\\' which is set to \\'' + optionsToUse.caretPositionOnFocus + '\\'. As a result, if this has been called when instantiating an AutoNumeric object, the \\'selectOnFocus\\' option is forced to \\'doNotSelect\\'.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.digitGroupSeparator, [AutoNumeric.options.digitGroupSeparator.comma, AutoNumeric.options.digitGroupSeparator.dot, AutoNumeric.options.digitGroupSeparator.normalSpace, AutoNumeric.options.digitGroupSeparator.thinSpace, AutoNumeric.options.digitGroupSeparator.narrowNoBreakSpace, AutoNumeric.options.digitGroupSeparator.noBreakSpace, AutoNumeric.options.digitGroupSeparator.noSeparator, AutoNumeric.options.digitGroupSeparator.apostrophe, AutoNumeric.options.digitGroupSeparator.arabicThousandsSeparator, AutoNumeric.options.digitGroupSeparator.dotAbove])) {\n                _AutoNumericHelper2.default.throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.noSeparatorOnFocus) && !_AutoNumericHelper2.default.isBoolean(options.noSeparatorOnFocus)) {\n                _AutoNumericHelper2.default.throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n            }\n\n            if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n                _AutoNumericHelper2.default.throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.decimalCharacter, [AutoNumeric.options.decimalCharacter.comma, AutoNumeric.options.decimalCharacter.dot, AutoNumeric.options.decimalCharacter.middleDot, AutoNumeric.options.decimalCharacter.arabicDecimalSeparator, AutoNumeric.options.decimalCharacter.decimalSeparatorKeySymbol])) {\n                _AutoNumericHelper2.default.throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n            }\n\n            // Checks if the decimal and thousand characters are the same\n            if (options.decimalCharacter === options.digitGroupSeparator) {\n                _AutoNumericHelper2.default.throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.decimalCharacterAlternative) && !_AutoNumericHelper2.default.isString(options.decimalCharacterAlternative)) {\n                _AutoNumericHelper2.default.throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n            }\n\n            if (options.currencySymbol !== '' && !_AutoNumericHelper2.default.isString(options.currencySymbol)) {\n                _AutoNumericHelper2.default.throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.currencySymbolPlacement, [AutoNumeric.options.currencySymbolPlacement.prefix, AutoNumeric.options.currencySymbolPlacement.suffix])) {\n                _AutoNumericHelper2.default.throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.negativePositiveSignPlacement, [AutoNumeric.options.negativePositiveSignPlacement.prefix, AutoNumeric.options.negativePositiveSignPlacement.suffix, AutoNumeric.options.negativePositiveSignPlacement.left, AutoNumeric.options.negativePositiveSignPlacement.right, AutoNumeric.options.negativePositiveSignPlacement.none])) {\n                _AutoNumericHelper2.default.throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.showPositiveSign) && !_AutoNumericHelper2.default.isBoolean(options.showPositiveSign)) {\n                _AutoNumericHelper2.default.throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.suffixText) || options.suffixText !== '' && (_AutoNumericHelper2.default.isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n                _AutoNumericHelper2.default.throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.overrideMinMaxLimits) && !_AutoNumericHelper2.default.isInArray(options.overrideMinMaxLimits, [AutoNumeric.options.overrideMinMaxLimits.ceiling, AutoNumeric.options.overrideMinMaxLimits.floor, AutoNumeric.options.overrideMinMaxLimits.ignore])) {\n                _AutoNumericHelper2.default.throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n                _AutoNumericHelper2.default.throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n                _AutoNumericHelper2.default.throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n            }\n\n            if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n                _AutoNumericHelper2.default.throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n            }\n\n            if (!(_AutoNumericHelper2.default.isNull(options.decimalPlacesOverride) || _AutoNumericHelper2.default.isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n            _AutoNumericHelper2.default.isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n            ) {\n                    _AutoNumericHelper2.default.throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n                }\n\n            // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n            var vMinAndVMaxMaximumDecimalPlaces = this._maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n                _AutoNumericHelper2.default.warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesShownOnFocus) && (!_AutoNumericHelper2.default.isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n                _AutoNumericHelper2.default.throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n            }\n\n            // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesShownOnFocus) && !_AutoNumericHelper2.default.isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n                _AutoNumericHelper2.default.warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n                _AutoNumericHelper2.default.throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n                _AutoNumericHelper2.default.throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.scaleSymbol) && !_AutoNumericHelper2.default.isString(options.scaleSymbol)) {\n                _AutoNumericHelper2.default.throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.saveValueToSessionStorage) && !_AutoNumericHelper2.default.isBoolean(options.saveValueToSessionStorage)) {\n                _AutoNumericHelper2.default.throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.onInvalidPaste, [AutoNumeric.options.onInvalidPaste.error, AutoNumeric.options.onInvalidPaste.ignore, AutoNumeric.options.onInvalidPaste.clamp, AutoNumeric.options.onInvalidPaste.truncate, AutoNumeric.options.onInvalidPaste.replace])) {\n                _AutoNumericHelper2.default.throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.roundingMethod, [AutoNumeric.options.roundingMethod.halfUpSymmetric, AutoNumeric.options.roundingMethod.halfUpAsymmetric, AutoNumeric.options.roundingMethod.halfDownSymmetric, AutoNumeric.options.roundingMethod.halfDownAsymmetric, AutoNumeric.options.roundingMethod.halfEvenBankersRounding, AutoNumeric.options.roundingMethod.upRoundAwayFromZero, AutoNumeric.options.roundingMethod.downRoundTowardZero, AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity, AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity, AutoNumeric.options.roundingMethod.toNearest05, AutoNumeric.options.roundingMethod.toNearest05Alt, AutoNumeric.options.roundingMethod.upToNext05, AutoNumeric.options.roundingMethod.downToNext05])) {\n                _AutoNumericHelper2.default.throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.negativeBracketsTypeOnBlur) && !_AutoNumericHelper2.default.isInArray(options.negativeBracketsTypeOnBlur, [AutoNumeric.options.negativeBracketsTypeOnBlur.parentheses, AutoNumeric.options.negativeBracketsTypeOnBlur.brackets, AutoNumeric.options.negativeBracketsTypeOnBlur.chevrons, AutoNumeric.options.negativeBracketsTypeOnBlur.curlyBraces, AutoNumeric.options.negativeBracketsTypeOnBlur.angleBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.japaneseQuotationMarks, AutoNumeric.options.negativeBracketsTypeOnBlur.halfBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.whiteSquareBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.quotationMarks, AutoNumeric.options.negativeBracketsTypeOnBlur.guillemets])) {\n                _AutoNumericHelper2.default.throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\', \\'{,}\\', \\'\\u3008,\\u3009\\', \\'\\uFF62,\\uFF63\\', \\'\\u2E24,\\u2E25\\', \\'\\u27E6,\\u27E7\\', \\'\\u2039,\\u203A\\' or \\'\\xAB,\\xBB\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.emptyInputBehavior, [AutoNumeric.options.emptyInputBehavior.focus, AutoNumeric.options.emptyInputBehavior.press, AutoNumeric.options.emptyInputBehavior.always, AutoNumeric.options.emptyInputBehavior.zero])) {\n                _AutoNumericHelper2.default.throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n            }\n\n            if (options.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero && (options.minimumValue > 0 || options.maximumValue < 0)) {\n                _AutoNumericHelper2.default.throwError('The \\'emptyInputBehavior\\' option is set to \\'zero\\', but this value is outside of the range defined by \\'minimumValue\\' and \\'maximumValue\\' [' + options.minimumValue + ', ' + options.maximumValue + '].');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.leadingZero, [AutoNumeric.options.leadingZero.allow, AutoNumeric.options.leadingZero.deny, AutoNumeric.options.leadingZero.keep])) {\n                _AutoNumericHelper2.default.throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.formatOnPageLoad) && !_AutoNumericHelper2.default.isBoolean(options.formatOnPageLoad)) {\n                _AutoNumericHelper2.default.throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n            }\n\n            if (!testPositiveInteger.test(options.historySize) || options.historySize === 0) {\n                _AutoNumericHelper2.default.throwError('The history size option \\'historySize\\' is invalid ; it should be a positive integer, [' + options.historySize + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.selectNumberOnly) && !_AutoNumericHelper2.default.isBoolean(options.selectNumberOnly)) {\n                _AutoNumericHelper2.default.throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.selectOnFocus) && !_AutoNumericHelper2.default.isBoolean(options.selectOnFocus)) {\n                _AutoNumericHelper2.default.throwError('The select on focus option \\'selectOnFocus\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectOnFocus + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n                _AutoNumericHelper2.default.throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.unformatOnSubmit) && !_AutoNumericHelper2.default.isBoolean(options.unformatOnSubmit)) {\n                _AutoNumericHelper2.default.throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.outputFormat) && !_AutoNumericHelper2.default.isInArray(options.outputFormat, [AutoNumeric.options.outputFormat.string, AutoNumeric.options.outputFormat.number, AutoNumeric.options.outputFormat.dot, AutoNumeric.options.outputFormat.negativeDot, AutoNumeric.options.outputFormat.comma, AutoNumeric.options.outputFormat.negativeComma, AutoNumeric.options.outputFormat.dotNegative, AutoNumeric.options.outputFormat.commaNegative])) {\n                _AutoNumericHelper2.default.throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.isCancellable) && !_AutoNumericHelper2.default.isBoolean(options.isCancellable)) {\n                _AutoNumericHelper2.default.throwError('The cancellable behavior option \\'isCancellable\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.isCancellable + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.modifyValueOnWheel) && !_AutoNumericHelper2.default.isBoolean(options.modifyValueOnWheel)) {\n                _AutoNumericHelper2.default.throwError('The increment/decrement on mouse wheel option \\'modifyValueOnWheel\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.modifyValueOnWheel + '] given.');\n            }\n\n            if (!(_AutoNumericHelper2.default.isString(options.wheelStep) || _AutoNumericHelper2.default.isNumber(options.wheelStep)) || options.wheelStep !== 'progressive' && !testPositiveFloatOrInteger.test(options.wheelStep) || Number(options.wheelStep) === 0) {\n                // A step equal to '0' is rejected\n                _AutoNumericHelper2.default.throwError('The wheel step value option \\'wheelStep\\' is invalid ; it should either be the string \\'progressive\\', or a number or a string that represents a positive number (excluding zero), [' + options.wheelStep + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.serializeSpaces, [AutoNumeric.options.serializeSpaces.plus, AutoNumeric.options.serializeSpaces.percent])) {\n                _AutoNumericHelper2.default.throwError('The space replacement character option \\'serializeSpaces\\' is invalid ; it should either be \\'+\\' or \\'%20\\', [' + options.serializeSpaces + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.noEventListeners) && !_AutoNumericHelper2.default.isBoolean(options.noEventListeners)) {\n                _AutoNumericHelper2.default.throwError('The option \\'noEventListeners\\' that prevent the creation of event listeners is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noEventListeners + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.styleRules) && !(_AutoNumericHelper2.default.isObject(options.styleRules) && (options.styleRules.hasOwnProperty('positive') || options.styleRules.hasOwnProperty('negative') || options.styleRules.hasOwnProperty('ranges') || options.styleRules.hasOwnProperty('userDefined')))) {\n                _AutoNumericHelper2.default.throwError('The option \\'styleRules\\' is invalid ; it should be a correctly structured object, with one or more \\'positive\\', \\'negative\\', \\'ranges\\' or \\'userDefined\\' attributes, [' + options.styleRules + '] given.');\n            }\n\n            // Deeper tests of the `styleRules` object : Check that the callback, if defined, is a function\n            if (!_AutoNumericHelper2.default.isNull(options.styleRules) && options.styleRules.hasOwnProperty('userDefined') && !_AutoNumericHelper2.default.isNull(options.styleRules.userDefined)) {\n                options.styleRules.userDefined.forEach(function (rule) {\n                    if (rule.hasOwnProperty('callback') && !_AutoNumericHelper2.default.isFunction(rule.callback)) {\n                        _AutoNumericHelper2.default.throwError('The callback defined in the `userDefined` attribute is not a function, ' + _typeof(rule.callback) + ' given.');\n                    }\n                });\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.readOnly) && !_AutoNumericHelper2.default.isBoolean(options.readOnly)) {\n                _AutoNumericHelper2.default.throwError('The option \\'readOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.readOnly + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.unformatOnHover) && !_AutoNumericHelper2.default.isBoolean(options.unformatOnHover)) {\n                _AutoNumericHelper2.default.throwError('The option \\'unformatOnHover\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnHover + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.failOnUnknownOption) && !_AutoNumericHelper2.default.isBoolean(options.failOnUnknownOption)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.createLocalList) && !_AutoNumericHelper2.default.isBoolean(options.createLocalList)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'createLocalList\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.createLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Return `true` is the settings/options are valid, `false` otherwise.\n         *\n         * @param {object} options\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'areSettingsValid',\n        value: function areSettingsValid(options) {\n            //FIXME à tester\n            var isValid = true;\n            try {\n                this.validate(options, true);\n            } catch (error) {\n                isValid = false;\n            }\n\n            return isValid;\n        }\n\n        /**\n         * Return the default autoNumeric settings.\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getDefaultConfig',\n        value: function getDefaultConfig() {\n            return AutoNumeric.defaultSettings;\n        }\n\n        /**\n         * Return all the predefined language options in one object.\n         * You can also access a specific language object directly by using `AutoNumeric.getPredefinedOptions().French` for instance.\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getPredefinedOptions',\n        value: function getPredefinedOptions() {\n            return AutoNumeric.predefinedOptions;\n        }\n\n        /**\n         * Format the given number (or numeric string) with the given options. This returns the formatted value as a string.\n         * This can also format the give DOM element value with the given options and returns the formatted value as a string.\n         * Note : This function does update that element value with the newly formatted value in the process.\n         *\n         * @param {number|string|HTMLElement|HTMLInputElement} valueOrDomElement A number, or a string that represent a javascript number, or a DOM element\n         * @param {object|null} options\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'format',\n        value: function format(valueOrDomElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            if (_AutoNumericHelper2.default.isUndefined(valueOrDomElement) || valueOrDomElement === null) {\n                return null;\n            }\n\n            if (!_AutoNumericHelper2.default.isString(valueOrDomElement) && !_AutoNumericHelper2.default.isNumber(valueOrDomElement)) {\n                _AutoNumericHelper2.default.throwError('The value \"' + valueOrDomElement + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n            }\n\n            // Initiate a very basic settings object\n            var settings = _extends({}, this.getDefaultConfig(), options);\n            if (valueOrDomElement < 0) {\n                settings.negativeSignCharacter = '-';\n            }\n\n            var regex = {};\n            this._cachesUsualRegularExpressions(settings, regex); // This is needed by `_stripAllNonNumberCharacters` that uses those regex\n\n            if (_AutoNumericHelper2.default.isNull(settings.decimalPlacesOverride)) {\n                settings.decimalPlacesOverride = this._maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n            }\n\n            // Check the validity of the `valueOrDomElement` parameter\n            // Convert the valueOrDomElement to a numeric string, stripping unnecessary characters in the process\n            var valueString = this._toNumericValue(valueOrDomElement, settings);\n            if (isNaN(Number(valueString))) {\n                _AutoNumericHelper2.default.throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n            }\n\n            // Basic tests to check if the given valueString is valid\n\n            var _checkIfInRangeWithOv = this._checkIfInRangeWithOverrideOption(valueString, settings),\n                _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                minTest = _checkIfInRangeWithOv2[0],\n                maxTest = _checkIfInRangeWithOv2[1];\n\n            if (!minTest || !maxTest) {\n                // Throw a custom event\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, document, 'Range test failed');\n                _AutoNumericHelper2.default.throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n            }\n\n            // Everything is ok, proceed to rounding, formatting and grouping\n            valueString = this._roundValue(valueString, settings);\n            valueString = this._modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n            valueString = this._addGroupSeparators(valueString, settings, false);\n\n            return valueString;\n        }\n\n        /**\n         * Format the given DOM element value, and set the resulting value back as the element value.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {object} options\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'formatAndSet',\n        value: function formatAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            var formattedValue = this.format(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, formattedValue);\n\n            return formattedValue;\n        }\n\n        /**\n         * Unformat the given formatted string with the given options. This returns a numeric string.\n         * It can also unformat the given DOM element value with the given options and returns the unformatted numeric string.\n         * Note: This does *not* update that element value.\n         * This basically allows to get the unformatted value without first having to initialize an AutoNumeric object.\n         *\n         * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement\n         * @param {object|null} options Multiple objects can be passed, the latter overwriting the settings from the former ones\n         * @returns {*}\n         */\n\n    }, {\n        key: 'unformat',\n        value: function unformat(numericStringOrDomElement) {\n            if (_AutoNumericHelper2.default.isNumberStrict(numericStringOrDomElement)) {\n                // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n                return numericStringOrDomElement;\n            }\n\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isElement(numericStringOrDomElement)) {\n                value = _AutoNumericHelper2.default.getElementValue(numericStringOrDomElement);\n            } else {\n                value = numericStringOrDomElement;\n            }\n\n            if (_AutoNumericHelper2.default.isUndefined(value) || value === null) {\n                return null;\n            }\n\n            if (_AutoNumericHelper2.default.isArray(value) || _AutoNumericHelper2.default.isObject(value)) {\n                // Check the validity of the `value` parameter\n                _AutoNumericHelper2.default.throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n            }\n\n            var optionsToUse = {};\n\n            for (var _len5 = arguments.length, options = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                options[_key5 - 1] = arguments[_key5];\n            }\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options) || options.length === 0) {\n                optionsToUse = null;\n            } else if (options.length >= 1) {\n                options.forEach(function (optionObject) {\n                    _extends(optionsToUse, optionObject);\n                });\n            }\n\n            var settings = _extends({}, this.getDefaultConfig(), optionsToUse);\n            if (_AutoNumericHelper2.default.isNull(settings.decimalPlacesOverride)) {\n                settings.decimalPlacesOverride = this._maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n            }\n            value = value.toString();\n\n            // This checks if a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n            if (_AutoNumericHelper2.default.isNegative(value)) {\n                settings.negativeSignCharacter = '-';\n            } else if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur)) {\n                var _settings$negativeBra3 = settings.negativeBracketsTypeOnBlur.split(',');\n\n                var _settings$negativeBra4 = _slicedToArray(_settings$negativeBra3, 2);\n\n                settings.firstBracket = _settings$negativeBra4[0];\n                settings.lastBracket = _settings$negativeBra4[1];\n\n                if (value.charAt(0) === settings.firstBracket && value.charAt(value.length - 1) === settings.lastBracket) {\n                    settings.negativeSignCharacter = '-';\n                    value = this._removeBrackets(value, settings, false);\n                }\n            }\n\n            value = this._convertToNumericString(value, settings);\n            var unwantedCharacters = new RegExp('[^+-0123456789.]', 'gi');\n            if (unwantedCharacters.test(value)) {\n                return NaN;\n            }\n\n            value = this._roundValue(value, settings);\n            value = value.replace(settings.decimalCharacter, '.'); // Here we need to convert back the decimal character to a period since `_roundValue` adds it in some cases\n            value = this._toLocale(value, settings.outputFormat);\n\n            return value;\n        }\n\n        /**\n         * Unformat the given DOM element value, and set the resulting value back as the element value.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {object} options\n         * @returns {*}\n         */\n\n    }, {\n        key: 'unformatAndSet',\n        value: function unformatAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            var unformattedValue = this.unformat(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, unformattedValue);\n\n            return unformattedValue;\n        }\n\n        /**\n         * Unformat and localize the given formatted string with the given options. This returns a numeric string.\n         * It can also unformat and localize the given DOM element value with the given options and returns the unformatted numeric string.\n         * Note: This does *not* update that element value.\n         * This basically allows to get the localized value without first having to initialize an AutoNumeric object.\n         *\n         * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement\n         * @param {object} options\n         * @returns {*}\n         */\n\n    }, {\n        key: 'localize',\n        value: function localize(numericStringOrDomElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isElement(numericStringOrDomElement)) {\n                value = _AutoNumericHelper2.default.getElementValue(numericStringOrDomElement);\n            } else {\n                value = numericStringOrDomElement;\n            }\n\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                options = AutoNumeric.defaultSettings;\n            }\n\n            value = this.unformat(value, options);\n\n            //XXX The following code is pretty close to the one you can find in `getLocalized()`, but different enough so we won't refactor it.\n            if (Number(value) === 0 && options.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                value = '0';\n            }\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                outputFormatToUse = options.outputFormat;\n            } else {\n                outputFormatToUse = AutoNumeric.defaultSettings.outputFormat;\n            }\n\n            return this._toLocale(value, outputFormatToUse);\n        }\n    }, {\n        key: 'localizeAndSet',\n        value: function localizeAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME à tester\n            var localizedValue = this.localize(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, localizedValue);\n\n            return localizedValue;\n        }\n\n        /**\n         * Return `true` is the given DOM element has an AutoNumeric object that manages it.\n         *\n         * @param {HTMLElement} domElement\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isManagedByAutoNumeric',\n        value: function isManagedByAutoNumeric(domElement) {\n            //FIXME à tester\n            return this._isInGlobalList(domElement);\n        }\n\n        /**\n         * Return the AutoNumeric object that manages the given DOM element.\n         *\n         * @param {HTMLElement} domElement\n         * @returns {null|AutoNumeric}\n         */\n\n    }, {\n        key: 'getAutoNumericElement',\n        value: function getAutoNumericElement(domElement) {\n            //FIXME à tester\n            if (!this.isManagedByAutoNumeric(domElement)) {\n                return null;\n            }\n\n            return this._getFromGlobalList(domElement);\n        }\n    }, {\n        key: '_maximumVMinAndVMaxDecimalLength',\n        value: function _maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n            return Math.max(_AutoNumericHelper2.default.decimalPlaces(minimumValue), _AutoNumericHelper2.default.decimalPlaces(maximumValue));\n        }\n    }, {\n        key: '_stripAllNonNumberCharacters',\n        value: function _stripAllNonNumberCharacters(s, settings, stripZeros, isFocused) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n            //TODO Refactor this with `convertToNumericString()` if possible?\n            s = String(s); // Typecast to to a string, in case that the initialValue is a number\n\n            if (settings.currencySymbol !== '') {\n                // Remove currency sign\n                s = s.replace(settings.currencySymbol, '');\n            }\n\n            if (settings.suffixText) {\n                // Remove suffix\n                s = s.replace(settings.suffixText, '');\n            }\n\n            //TODO Remove the positive sign too?\n\n            // First replace anything before digits\n            s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n            // Then replace anything after digits\n            s = s.replace(settings.skipLastAutoStrip, '$1');\n\n            // Then remove any uninteresting characters\n            s = s.replace(settings.allowedAutoStrip, '');\n            if (settings.decimalCharacterAlternative) {\n                s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n            }\n\n            // Get only number string\n            var m = s.match(settings.numRegAutoStrip);\n            s = m ? [m[1], m[2], m[3]].join('') : '';\n\n            if (settings.leadingZero === AutoNumeric.options.leadingZero.allow || settings.leadingZero === AutoNumeric.options.leadingZero.keep) {\n                var negativeSign = '';\n\n                var _s$split = s.split(settings.decimalCharacter),\n                    _s$split2 = _slicedToArray(_s$split, 2),\n                    integerPart = _s$split2[0],\n                    decimalPart = _s$split2[1];\n\n                var modifiedIntegerPart = integerPart;\n                if (_AutoNumericHelper2.default.contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                    negativeSign = settings.negativeSignCharacter;\n                    modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n                }\n\n                // Strip leading zero on positive value if need\n                if (negativeSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                    modifiedIntegerPart = modifiedIntegerPart.slice(1);\n                }\n\n                // Strip leading zero on negative value if need\n                if (negativeSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                    modifiedIntegerPart = modifiedIntegerPart.slice(1);\n                }\n\n                s = '' + negativeSign + modifiedIntegerPart + (_AutoNumericHelper2.default.isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n            }\n\n            if (stripZeros && settings.leadingZero === AutoNumeric.options.leadingZero.deny || !isFocused && settings.leadingZero === AutoNumeric.options.leadingZero.allow) {\n                s = s.replace(settings.stripReg, '$1$2');\n            }\n\n            return s;\n        }\n\n        /**\n         * Sets or removes brackets on negative values, depending on the focus state, which is passed as `isFocused`.\n         * The focus state is 'stored' in that object property.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} isFocused\n         * @returns {*}\n         */\n\n    }, {\n        key: '_toggleNegativeBracket',\n        value: function _toggleNegativeBracket(value, settings, isFocused) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var result = void 0;\n            if (isFocused) {\n                result = this._removeBrackets(value, settings);\n            } else {\n                result = this._addBrackets(value, settings);\n            }\n\n            return result;\n        }\n\n        /**\n         * Add the bracket types specified in the `settings` object, to the given string `value`.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_addBrackets',\n        value: function _addBrackets(value, settings) {\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur)) {\n                result = '' + settings.firstBracket + value.replace(settings.negativeSignCharacter, '') + settings.lastBracket;\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Remove the bracket types specified in the `settings` object, from the given string `value`.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} rearrangeSignsAndValueOrder If set to `true`, then only the brackets are remove and a negative sign is added, without reordering the negative sign, currency symbol and value according to the settings.\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_removeBrackets',\n        value: function _removeBrackets(value, settings) {\n            var rearrangeSignsAndValueOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur) && value.charAt(0) === settings.firstBracket) {\n                // Remove the brackets if they are present\n                result = value.replace(settings.firstBracket, '');\n                result = result.replace(settings.lastBracket, '');\n\n                // Add back the negative sign at the right place\n                if (rearrangeSignsAndValueOrder) {\n                    // First we need to remove the currency symbol from the value, since we want to be able to add back the negative sign at the right place (including between the value and the currency sign)\n                    result = result.replace(settings.currencySymbol, '');\n                    result = this._mergeCurrencySignNegativePositiveSignAndValue(result, settings, true, false); //TODO This assume the value is negative and non-empty. Is this always the case?\n                } else {\n                    // Here we only want to add the negative sign since we removed the brackets, without reordering\n                    result = '-' + result;\n                }\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n    }, {\n        key: '_convertToNumericString',\n        value: function _convertToNumericString(s, settings) {\n            // Remove the currency symbol\n            s = s.replace(settings.currencySymbol, '');\n\n            // Remove the grouping separators (thousands separators usually)\n            s = s.replace(settings.digitGroupSeparator, '');\n\n            // Replace the decimal character by a dot\n            if (settings.decimalCharacter !== '.') {\n                s = s.replace(settings.decimalCharacter, '.');\n            }\n\n            // Remove the suffixText\n            if (settings.suffixText !== AutoNumeric.options.suffixText.none) {\n                s = s.replace(settings.suffixText, '');\n            }\n\n            // Move the trailing negative sign to the right position, if any\n            if (_AutoNumericHelper2.default.isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n                s = s.replace('-', '');\n                s = '-' + s;\n            }\n\n            // Convert arabic numbers to latin ones, if any\n            var convertToNumber = settings.leadingZero !== AutoNumeric.options.leadingZero.keep;\n            var temp = _AutoNumericHelper2.default.arabicToLatinNumbers(s, convertToNumber, false, false);\n            if (!isNaN(temp)) {\n                s = temp.toString();\n            }\n\n            return s;\n        }\n\n        /**\n         * Converts the ISO numeric string to the locale decimal and minus sign placement.\n         * See the \"outputFormat\" option definition for more details.\n         *\n         * @param {string|null} value\n         * @param {string|null} locale\n         * @returns {*}\n         */\n\n    }, {\n        key: '_toLocale',\n        value: function _toLocale(value, locale) {\n            if (_AutoNumericHelper2.default.isNull(locale) || locale === AutoNumeric.options.outputFormat.string) {\n                return value;\n            }\n\n            var result = void 0;\n            switch (locale) {\n                case AutoNumeric.options.outputFormat.number:\n                    result = Number(value);\n                    break;\n                case AutoNumeric.options.outputFormat.dotNegative:\n                    result = _AutoNumericHelper2.default.isNegative(value) ? value.replace('-', '') + '-' : value;\n                    break;\n                case AutoNumeric.options.outputFormat.comma:\n                case AutoNumeric.options.outputFormat.negativeComma:\n                    result = value.replace('.', ',');\n                    break;\n                case AutoNumeric.options.outputFormat.commaNegative:\n                    result = value.replace('.', ',');\n                    result = _AutoNumericHelper2.default.isNegative(result) ? result.replace('-', '') + '-' : result;\n                    break;\n                // The default case\n                case AutoNumeric.options.outputFormat.dot:\n                case AutoNumeric.options.outputFormat.negativeDot:\n                    result = value;\n                    break;\n                default:\n                    _AutoNumericHelper2.default.throwError('The given outputFormat [' + locale + '] option is not recognized.');\n            }\n\n            return result;\n        }\n    }, {\n        key: '_modifyNegativeSignAndDecimalCharacterForFormattedValue',\n        value: function _modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n                s = s.replace('-', settings.negativeSignCharacter);\n            }\n\n            if (settings.decimalCharacter !== '.') {\n                s = s.replace('.', settings.decimalCharacter);\n            }\n\n            return s;\n        }\n\n        /**\n         * Return `true` if the given value is empty or is equal to the negative sign character defined in the given settings.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isElementValueEmptyOrOnlyTheNegativeSign',\n        value: function _isElementValueEmptyOrOnlyTheNegativeSign(value, settings) {\n            return value === '' || value === settings.negativeSignCharacter;\n        }\n\n        /**\n         * Return the value with the currency symbol and the suffix text ordered according to the given settings.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} signOnEmpty\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_orderValueCurrencySymbolAndSuffixText',\n        value: function _orderValueCurrencySymbolAndSuffixText(value, settings, signOnEmpty) {\n            var result = void 0;\n            if (settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.always || signOnEmpty) {\n                if (settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left) {\n                    result = value + settings.currencySymbol + settings.suffixText;\n                } else {\n                    result = settings.currencySymbol + value + settings.suffixText;\n                }\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Modify the input value by adding the group separators, as defined in the settings.\n         *\n         * @param {string} inputValue\n         * @param {object} settings\n         * @param {boolean} isFocused\n         * @param {number|string|null} rawValue If this is set, then this rawValue is used instead of the one passed through the `settings` object. This is useful is some very specific cases where we need to set the raw value *after* settings the formatted value, using the `_addGroupSeparators()` method.\n         * @returns {*}\n         */\n\n    }, {\n        key: '_addGroupSeparators',\n        value: function _addGroupSeparators(inputValue, settings, isFocused) {\n            var rawValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var isValueNegative = _AutoNumericHelper2.default.isNegative(inputValue) || _AutoNumericHelper2.default.isNegativeWithBrackets(inputValue, settings.firstBracket, settings.lastBracket); // Test if the value is negative before removing the negative sign\n\n            inputValue = this._stripAllNonNumberCharacters(inputValue, settings, false, isFocused);\n\n            if (this._isElementValueEmptyOrOnlyTheNegativeSign(inputValue, settings)) {\n                return this._orderValueCurrencySymbolAndSuffixText(inputValue, settings, true);\n            }\n\n            var isZeroOrHasNoValue = _AutoNumericHelper2.default.isZeroOrHasNoValue(inputValue);\n\n            // Temporarily remove the negative sign if present\n            if (isValueNegative) {\n                inputValue = inputValue.replace('-', '');\n            }\n\n            settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n            var digitalGroup = void 0;\n            switch (settings.digitalGroupSpacing) {\n                case AutoNumeric.options.digitalGroupSpacing.two:\n                    digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.twoScaled:\n                    digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.four:\n                    digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.three:\n                default:\n                    digitalGroup = /(\\d)((\\d{3}?)+)$/;\n            }\n\n            // Splits the string at the decimal string\n\n            var _inputValue$split = inputValue.split(settings.decimalCharacter),\n                _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n                integerPart = _inputValue$split2[0],\n                decimalPart = _inputValue$split2[1];\n\n            if (settings.decimalCharacterAlternative && _AutoNumericHelper2.default.isUndefined(decimalPart)) {\n                var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n                var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n                integerPart = _inputValue$split4[0];\n                decimalPart = _inputValue$split4[1];\n            }\n\n            if (settings.digitGroupSeparator !== '') {\n                // Re-inserts the thousand separator via a regular expression\n                while (digitalGroup.test(integerPart)) {\n                    integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n                }\n            }\n\n            if (settings.decimalPlacesOverride !== 0 && !_AutoNumericHelper2.default.isUndefined(decimalPart)) {\n                if (decimalPart.length > settings.decimalPlacesOverride) {\n                    decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                }\n\n                // Joins the whole number with the decimal value\n                inputValue = integerPart + settings.decimalCharacter + decimalPart;\n            } else {\n                // Otherwise if it's an integer\n                inputValue = integerPart;\n            }\n\n            // Add back the negative/positive sign and the currency symbol, at the right positions\n            inputValue = AutoNumeric._mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue); //TODO this function is called again in `_toggleNegativeBracket` if the brackets are removed; let's DRY this\n\n            if (_AutoNumericHelper2.default.isNull(rawValue)) {\n                // If the raw value is not forced, use the default one from the settings object\n                rawValue = settings.rawValue;\n            }\n\n            // Toggle the negative sign and brackets\n            if (settings.negativeBracketsTypeOnBlur !== null && (rawValue < 0 || _AutoNumericHelper2.default.isNegativeStrict(inputValue))) {\n                inputValue = this._toggleNegativeBracket(inputValue, settings, isFocused);\n            }\n\n            var result = void 0;\n            if (settings.suffixText) {\n                result = inputValue + settings.suffixText;\n            } else {\n                result = inputValue;\n            }\n\n            return result;\n        }\n\n        /**\n         * Return a semi-formatted string where the input value, the negative or positive sign, and the currency symbol are stitched together at the right positions, using the options set in the `settings` object.\n         * Note : the `inputValue` is usually not a numeric string since the grouping symbols are already added to it at this point.\n         *\n         * @param {string} inputValue\n         * @param {object} settings\n         * @param {boolean} isValueNegative\n         * @param {boolean} isZeroOrHasNoValue\n         * @returns {*}\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_mergeCurrencySignNegativePositiveSignAndValue',\n        value: function _mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue) {\n            var signToUse = '';\n            if (isValueNegative) {\n                signToUse = settings.negativeSignCharacter;\n            } else if (settings.showPositiveSign && !isZeroOrHasNoValue) {\n                signToUse = settings.positiveSignCharacter;\n            }\n\n            var result = void 0;\n            if (settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                if (settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                    switch (settings.negativePositiveSignPlacement) {\n                        case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                        case AutoNumeric.options.negativePositiveSignPlacement.left:\n                            result = '' + signToUse + settings.currencySymbol + inputValue;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.right:\n                            result = '' + settings.currencySymbol + signToUse + inputValue;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                            result = '' + settings.currencySymbol + inputValue + signToUse;\n                            break;\n                    }\n                } else {\n                    result = settings.currencySymbol + inputValue;\n                }\n            } else if (settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                if (settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                    switch (settings.negativePositiveSignPlacement) {\n                        case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                        case AutoNumeric.options.negativePositiveSignPlacement.right:\n                            result = '' + inputValue + settings.currencySymbol + signToUse;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.left:\n                            result = '' + inputValue + signToUse + settings.currencySymbol;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                            result = '' + signToUse + inputValue + settings.currencySymbol;\n                            break;\n                    }\n                } else {\n                    result = inputValue + settings.currencySymbol;\n                }\n            }\n\n            return result;\n        }\n    }, {\n        key: '_truncateZeros',\n        value: function _truncateZeros(roundedInputValue, decimalPlacesOverride) {\n            var regex = void 0;\n            switch (decimalPlacesOverride) {\n                case 0:\n                    // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                    regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                    break;\n                case 1:\n                    // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                    regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                    break;\n                default:\n                    // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                    regex = new RegExp('(\\\\.\\\\d{' + decimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n            }\n\n            // If there are no decimal places, we don't need a decimal point at the end\n            roundedInputValue = roundedInputValue.replace(regex, '$1');\n            if (decimalPlacesOverride === 0) {\n                roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n            }\n\n            return roundedInputValue;\n        }\n\n        /**\n         * Round the input value using the rounding method defined in the settings.\n         * This function accepts multiple rounding methods. See the documentation for more details about those.\n         *\n         * Note : This is handled as text since JavaScript math function can return inaccurate values.\n         *\n         * @param {string} inputValue\n         * @param {object} settings\n         * @returns {*}\n         */\n\n    }, {\n        key: '_roundValue',\n        value: function _roundValue(inputValue, settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            //TODO Divide this function to make it easier to understand\n            inputValue = inputValue === '' ? '0' : inputValue.toString();\n            if (settings.roundingMethod === AutoNumeric.options.roundingMethod.toNearest05 || settings.roundingMethod === AutoNumeric.options.roundingMethod.toNearest05Alt || settings.roundingMethod === AutoNumeric.options.roundingMethod.upToNext05 || settings.roundingMethod === AutoNumeric.options.roundingMethod.downToNext05) {\n                return this._roundCloseTo05(inputValue, settings);\n            }\n\n            var _AutoNumeric$_prepare = AutoNumeric._prepareValueForRounding(inputValue, settings),\n                _AutoNumeric$_prepare2 = _slicedToArray(_AutoNumeric$_prepare, 2),\n                negativeSign = _AutoNumeric$_prepare2[0],\n                preparedValue = _AutoNumeric$_prepare2[1];\n\n            inputValue = preparedValue;\n\n            var decimalCharacterPosition = inputValue.lastIndexOf('.');\n            var inputValueHasADot = decimalCharacterPosition === -1;\n\n            var _inputValue$split5 = inputValue.split('.'),\n                _inputValue$split6 = _slicedToArray(_inputValue$split5, 2),\n                decimalPart = _inputValue$split6[1]; // Here the decimal character is always a period '.'\n\n\n            var hasDecimals = decimalPart > 0;\n            if (!hasDecimals && (settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.never || settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats)) {\n                return Number(inputValue) === 0 ? inputValue : negativeSign + inputValue;\n            }\n\n            // Virtual decimal position\n            var virtualDecimalPosition = inputValueHasADot ? inputValue.length - 1 : decimalCharacterPosition;\n\n            // Sets the truncate zero method\n            var temporaryDecimalPlacesOverride = void 0;\n            if (settings.allowDecimalPadding) {\n                temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n            } else {\n                temporaryDecimalPlacesOverride = 0;\n            }\n\n            // Checks decimal places to determine if rounding is required :\n            var inputValueRounded = '';\n            var checkDecimalPlaces = inputValue.length - 1 - virtualDecimalPosition;\n            // Check if no rounding is required\n            if (checkDecimalPlaces <= settings.decimalPlacesOverride) {\n                // Check if we need to pad with zeros\n                inputValueRounded = inputValue;\n                if (checkDecimalPlaces < temporaryDecimalPlacesOverride) {\n                    if (inputValueHasADot) {\n                        inputValueRounded += settings.decimalCharacter;\n                    }\n\n                    var zeros = '000000';\n                    while (checkDecimalPlaces < temporaryDecimalPlacesOverride) {\n                        zeros = zeros.substring(0, temporaryDecimalPlacesOverride - checkDecimalPlaces);\n                        inputValueRounded += zeros;\n                        checkDecimalPlaces += zeros.length;\n                    }\n                } else if (checkDecimalPlaces > temporaryDecimalPlacesOverride) {\n                    inputValueRounded = this._truncateZeros(inputValueRounded, temporaryDecimalPlacesOverride);\n                } else if (checkDecimalPlaces === 0 && temporaryDecimalPlacesOverride === 0) {\n                    inputValueRounded = inputValueRounded.replace(/\\.$/, '');\n                }\n\n                return Number(inputValueRounded) === 0 ? inputValueRounded : negativeSign + inputValueRounded;\n            }\n\n            // Rounded length of the string after rounding\n            var roundedStrLength = void 0;\n            if (inputValueHasADot) {\n                roundedStrLength = settings.decimalPlacesOverride - 1;\n            } else {\n                roundedStrLength = settings.decimalPlacesOverride + decimalCharacterPosition;\n            }\n\n            var lastDigit = Number(inputValue.charAt(roundedStrLength + 1));\n            var inputValueArray = inputValue.substring(0, roundedStrLength + 1).split('');\n            var odd = void 0;\n            if (inputValue.charAt(roundedStrLength) === '.') {\n                odd = inputValue.charAt(roundedStrLength - 1) % 2;\n            } else {\n                odd = inputValue.charAt(roundedStrLength) % 2;\n            }\n\n            if (this._shouldRoundUp(lastDigit, settings, negativeSign, odd)) {\n                // Round up the last digit if required, and continue until no more 9's are found\n                for (var i = inputValueArray.length - 1; i >= 0; i -= 1) {\n                    if (inputValueArray[i] !== '.') {\n                        inputValueArray[i] = +inputValueArray[i] + 1;\n                        if (inputValueArray[i] < 10) {\n                            break;\n                        }\n\n                        if (i > 0) {\n                            inputValueArray[i] = '0';\n                        }\n                    }\n                }\n            }\n\n            // Reconstruct the string, converting any 10's to 0's\n            inputValueArray = inputValueArray.slice(0, roundedStrLength + 1);\n\n            // Return the rounded value\n            inputValueRounded = this._truncateZeros(inputValueArray.join(''), temporaryDecimalPlacesOverride);\n\n            return Number(inputValueRounded) === 0 ? inputValueRounded : negativeSign + inputValueRounded;\n        }\n\n        /**\n         * Round the `value` when the rounding method deals with '.05'\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_roundCloseTo05',\n        value: function _roundCloseTo05(value, settings) {\n            switch (settings.roundingMethod) {\n                case AutoNumeric.options.roundingMethod.toNearest05:\n                case AutoNumeric.options.roundingMethod.toNearest05Alt:\n                    value = (Math.round(value * 20) / 20).toString();\n                    break;\n                case AutoNumeric.options.roundingMethod.upToNext05:\n                    value = (Math.ceil(value * 20) / 20).toString();\n                    break;\n                default:\n                    value = (Math.floor(value * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.contains(value, '.')) {\n                result = value + '.00';\n            } else if (value.length - value.indexOf('.') < 3) {\n                result = value + '0';\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Modify the given `value` in order to make it usable for the rest of the rounding function.\n         * This convert the `value` to a positive one, trim any leading zeros and make sure it does not starts with a leading dot.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {[string, string]}\n         * @private\n         */\n\n    }, {\n        key: '_prepareValueForRounding',\n        value: function _prepareValueForRounding(value, settings) {\n            // Checks if `inputValue` is a negative value\n            var negativeSign = '';\n            if (_AutoNumericHelper2.default.isNegativeStrict(value)) {\n                negativeSign = '-';\n\n                // Removes the negative sign that will be added back later if required\n                value = value.replace('-', '');\n            }\n\n            // Append a zero if the first character is not a digit (then it is likely a dot)\n            if (!value.match(/^\\d/)) {\n                value = '0' + value;\n            }\n\n            // Determines if the value is equal to zero. If it is, remove the negative sign\n            if (Number(value) === 0) {\n                negativeSign = '';\n            }\n\n            // Trims leading zero's as needed\n            if (Number(value) > 0 && settings.leadingZero !== AutoNumeric.options.leadingZero.keep || value.length > 0 && settings.leadingZero === AutoNumeric.options.leadingZero.allow) {\n                value = value.replace(/^0*(\\d)/, '$1');\n            }\n\n            return [negativeSign, value];\n        }\n\n        /**\n         * Return `true` if a round up should be done given the last digit, the settings and other information about the value.\n         * \n         * @param {number} lastDigit\n         * @param {object} settings\n         * @param {string} negativeSign\n         * @param {number} odd\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_shouldRoundUp',\n        value: function _shouldRoundUp(lastDigit, settings, negativeSign, odd) {\n            return lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpSymmetric || // Round half up symmetric\n            lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === '' || // Round half up asymmetric positive values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === '-' || // Round half up asymmetric negative values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownSymmetric || // Round half down symmetric\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === '' || // Round half down asymmetric positive values\n            lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === '-' || // Round half down asymmetric negative values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfEvenBankersRounding || lastDigit === 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfEvenBankersRounding && odd === 1 || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity && negativeSign === '' || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity && negativeSign === '-' || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.upRoundAwayFromZero; // Round up away from zero\n        }\n\n        /**\n         * Truncates the decimal part of a number.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @param {boolean} isPaste\n         * @returns {*}\n         */\n\n    }, {\n        key: '_truncateDecimalPlaces',\n        value: function _truncateDecimalPlaces(s, settings, isPaste) {\n            if (isPaste) {\n                s = this._roundValue(s, settings);\n            }\n\n            if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n                var _s$split3 = s.split(settings.decimalCharacter),\n                    _s$split4 = _slicedToArray(_s$split3, 2),\n                    integerPart = _s$split4[0],\n                    decimalPart = _s$split4[1];\n\n                // Truncate the decimal part to the satisfying length since we would round it anyway\n\n\n                if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                    if (settings.decimalPlacesOverride > 0) {\n                        var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                        s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                    } else {\n                        s = integerPart;\n                    }\n                }\n            }\n\n            return s;\n        }\n\n        /**\n         * Check that the number satisfy the format conditions\n         * and lays between settings.minimumValue and settings.maximumValue\n         * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @returns {*}\n         */\n\n    }, {\n        key: '_checkIfInRangeWithOverrideOption',\n        value: function _checkIfInRangeWithOverrideOption(s, settings) {\n            s = s.toString();\n            s = s.replace(',', '.');\n            var minParse = _AutoNumericHelper2.default.parseStr(settings.minimumValue);\n            var maxParse = _AutoNumericHelper2.default.parseStr(settings.maximumValue);\n            var valParse = _AutoNumericHelper2.default.parseStr(s);\n\n            var result = void 0;\n            switch (settings.overrideMinMaxLimits) {\n                case AutoNumeric.options.overrideMinMaxLimits.floor:\n                    result = [_AutoNumericHelper2.default.testMinMax(minParse, valParse) > -1, true];\n                    break;\n                case AutoNumeric.options.overrideMinMaxLimits.ceiling:\n                    result = [true, _AutoNumericHelper2.default.testMinMax(maxParse, valParse) < 1];\n                    break;\n                case AutoNumeric.options.overrideMinMaxLimits.ignore:\n                    result = [true, true];\n                    break;\n                default:\n                    result = [_AutoNumericHelper2.default.testMinMax(minParse, valParse) > -1, _AutoNumericHelper2.default.testMinMax(maxParse, valParse) < 1];\n            }\n\n            return result;\n        }\n    }, {\n        key: '_readCookie',\n        value: function _readCookie(name) {\n            var nameEQ = name + '=';\n            var ca = document.cookie.split(';');\n            var c = '';\n            for (var i = 0; i < ca.length; i += 1) {\n                c = ca[i];\n                while (c.charAt(0) === ' ') {\n                    c = c.substring(1, c.length);\n                }\n                if (c.indexOf(nameEQ) === 0) {\n                    return c.substring(nameEQ.length, c.length);\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Test if sessionStorage is supported.\n         * This is taken from Modernizr.\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_storageTest',\n        value: function _storageTest() {\n            var mod = 'modernizr';\n            try {\n                sessionStorage.setItem(mod, mod);\n                sessionStorage.removeItem(mod);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }, {\n        key: '_correctCaretPositionOnFocusAndSelectOnFocusOptions',\n        value: function _correctCaretPositionOnFocusAndSelectOnFocusOptions(options) {\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                return null;\n            }\n\n            // If the user has set the `caretPositionOnFocus` option, do not set `selectOnFocus` to `true` by default\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.selectOnFocus)) {\n                options.selectOnFocus = AutoNumeric.options.selectOnFocus.doNotSelect;\n            }\n\n            // If the user has set the `selectOnFocus` option to `true`, set `caretPositionOnFocus` to `doNoForceCaretPosition`\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && !_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.selectOnFocus) && options.selectOnFocus === AutoNumeric.options.selectOnFocus.select) {\n                options.caretPositionOnFocus = AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition;\n            }\n\n            return options;\n        }\n    }, {\n        key: '_cachesUsualRegularExpressions',\n        value: function _cachesUsualRegularExpressions(settings, regex) {\n            var allNumbersReg = '[0-9]';\n            var noAllNumbersReg = '[^0-9]';\n\n            // Test if there is a negative character in the string\n            var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n            regex.aNegRegAutoStrip = aNegReg;\n\n            var negativeSignRegPart = void 0;\n            if (settings.negativeSignCharacter) {\n                negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n            } else {\n                negativeSignRegPart = '';\n            }\n\n            settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n            settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n            var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n            settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n            settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n            // Using this regex version `^${regex.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            settings.stripReg = new RegExp('^' + regex.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n        }\n    }, {\n        key: '_convertOldOptionsToNewOnes',\n        value: function _convertOldOptionsToNewOnes(options) {\n            //TODO Delete this function once the old options are not used anymore\n            var oldOptionsConverter = {\n                // Old option names, with their corresponding new names\n                aSep: 'digitGroupSeparator',\n                nSep: 'noSeparatorOnFocus',\n                dGroup: 'digitalGroupSpacing',\n                aDec: 'decimalCharacter',\n                altDec: 'decimalCharacterAlternative',\n                aSign: 'currencySymbol',\n                pSign: 'currencySymbolPlacement',\n                pNeg: 'negativePositiveSignPlacement',\n                aSuffix: 'suffixText',\n                oLimits: 'overrideMinMaxLimits',\n                vMax: 'maximumValue',\n                vMin: 'minimumValue',\n                mDec: 'decimalPlacesOverride',\n                eDec: 'decimalPlacesShownOnFocus',\n                scaleDecimal: 'scaleDecimalPlaces',\n                aStor: 'saveValueToSessionStorage',\n                mRound: 'roundingMethod',\n                aPad: 'allowDecimalPadding',\n                nBracket: 'negativeBracketsTypeOnBlur',\n                wEmpty: 'emptyInputBehavior',\n                lZero: 'leadingZero',\n                aForm: 'formatOnPageLoad',\n                sNumber: 'selectNumberOnly',\n                anDefault: 'defaultValueOverride',\n                unSetOnSubmit: 'unformatOnSubmit',\n                outputType: 'outputFormat',\n                debug: 'showWarnings',\n\n                // Current options :\n                allowDecimalPadding: true,\n                caretPositionOnFocus: true,\n                createLocalList: true,\n                currencySymbol: true,\n                currencySymbolPlacement: true,\n                decimalCharacter: true,\n                decimalCharacterAlternative: true,\n                decimalPlacesOverride: true,\n                decimalPlacesShownOnFocus: true,\n                defaultValueOverride: true,\n                digitalGroupSpacing: true,\n                digitGroupSeparator: true,\n                emptyInputBehavior: true,\n                failOnUnknownOption: true,\n                formatOnPageLoad: true,\n                historySize: true,\n                isCancellable: true,\n                leadingZero: true,\n                maximumValue: true,\n                minimumValue: true,\n                modifyValueOnWheel: true,\n                negativeBracketsTypeOnBlur: true,\n                negativePositiveSignPlacement: true,\n                noEventListeners: true,\n                noSeparatorOnFocus: true,\n                onInvalidPaste: true,\n                outputFormat: true,\n                overrideMinMaxLimits: true,\n                readOnly: true,\n                roundingMethod: true,\n                saveValueToSessionStorage: true,\n                scaleDecimalPlaces: true,\n                scaleDivisor: true,\n                scaleSymbol: true,\n                selectNumberOnly: true,\n                selectOnFocus: true,\n                serializeSpaces: true,\n                showPositiveSign: true,\n                showWarnings: true,\n                styleRules: true,\n                suffixText: true,\n                unformatOnHover: true,\n                unformatOnSubmit: true,\n                wheelStep: true,\n\n                // Additional information that are added to the `settings` object :\n                //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n                allowedAutoStrip: true,\n                mIntNeg: true,\n                mIntPos: true,\n                negativeSignCharacter: true,\n                numRegAutoStrip: true,\n                positiveSignCharacter: true,\n                rawValue: true,\n                skipFirstAutoStrip: true,\n                skipLastAutoStrip: true,\n                stripReg: true\n            };\n\n            for (var option in options) {\n                if (options.hasOwnProperty(option)) {\n                    if (oldOptionsConverter[option] === true) {\n                        // If the option is a 'new' option, we continue looping\n                        continue;\n                    }\n\n                    if (oldOptionsConverter.hasOwnProperty(option)) {\n                        // Else we have an 'old' option name\n                        _AutoNumericHelper2.default.warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                        // Then we modify the initial option object to use the new options instead of the old ones\n                        options[oldOptionsConverter[option]] = options[option];\n                        delete options[option];\n                    } else if (options.failOnUnknownOption) {\n                        // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                        _AutoNumericHelper2.default.throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                    }\n                }\n            }\n        }\n    }, {\n        key: '_toNumericValue',\n        value: function _toNumericValue(value, settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isNumber(Number(value))) {\n                // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n                result = value;\n            } else {\n                // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n                // Convert the value to a numeric string, stripping unnecessary characters in the process\n                result = this._convertToNumericString(value.toString(), settings);\n\n                // If the result is still not a numeric string, then we throw a warning\n                if (!_AutoNumericHelper2.default.isNumber(Number(result))) {\n                    _AutoNumericHelper2.default.warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                    result = NaN;\n                }\n            }\n\n            return result;\n        }\n    }, {\n        key: '_checkIfInRange',\n        value: function _checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n            var parsedValue = _AutoNumericHelper2.default.parseStr(value);\n            return _AutoNumericHelper2.default.testMinMax(parsedMinValue, parsedValue) > -1 && _AutoNumericHelper2.default.testMinMax(parsedMaxValue, parsedValue) < 1;\n        }\n    }, {\n        key: '_shouldSkipEventKey',\n        value: function _shouldSkipEventKey(eventKeyName) {\n            var isFnKeys = _AutoNumericHelper2.default.isInArray(eventKeyName, _AutoNumericEnum2.default.keyName._allFnKeys);\n            var isOSKeys = eventKeyName === _AutoNumericEnum2.default.keyName.OSLeft || eventKeyName === _AutoNumericEnum2.default.keyName.OSRight;\n            var isContextMenu = eventKeyName === _AutoNumericEnum2.default.keyName.ContextMenu;\n            var isSomeNonPrintableKeys = _AutoNumericHelper2.default.isInArray(eventKeyName, _AutoNumericEnum2.default.keyName._someNonPrintableKeys);\n            var isOtherNonPrintableKeys = eventKeyName === _AutoNumericEnum2.default.keyName.NumLock || eventKeyName === _AutoNumericEnum2.default.keyName.ScrollLock || eventKeyName === _AutoNumericEnum2.default.keyName.Insert || eventKeyName === _AutoNumericEnum2.default.keyName.Command;\n            var isUnrecognizableKeys = eventKeyName === _AutoNumericEnum2.default.keyName.Unidentified;\n\n            return isFnKeys || isOSKeys || isContextMenu || isSomeNonPrintableKeys || isUnrecognizableKeys || isOtherNonPrintableKeys;\n        }\n    }, {\n        key: '_serialize',\n        value: function _serialize(form) {\n            var intoAnArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var formatType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unformatted';\n\n            var _this7 = this;\n\n            var serializedSpaceCharacter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '+';\n            var forcedOutputFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            var result = [];\n\n            if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) === 'object' && form.nodeName.toLowerCase() === 'form') {\n                Array.prototype.slice.call(form.elements).forEach(function (element) {\n                    if (element.name && !element.disabled && ['file', 'reset', 'submit', 'button'].indexOf(element.type) === -1) {\n                        if (element.type === 'select-multiple') {\n                            Array.prototype.slice.call(element.options).forEach(function (option) {\n                                if (option.selected) {\n                                    //TODO Should we unformat/format/localize the selection option (which be default should be read-only)?\n                                    if (intoAnArray) {\n                                        result.push({ name: element.name, value: option.value });\n                                    } else {\n                                        // into a string\n                                        result.push(encodeURIComponent(element.name) + '=' + encodeURIComponent(option.value));\n                                    }\n                                }\n                            });\n                        } else if (['checkbox', 'radio'].indexOf(element.type) === -1 || element.checked) {\n                            var valueResult = void 0;\n                            if (_this7.isManagedByAutoNumeric(element)) {\n                                var anObject = void 0;\n                                switch (formatType) {\n                                    case 'unformatted':\n                                        anObject = _this7.getAutoNumericElement(element);\n                                        if (!_AutoNumericHelper2.default.isNull(anObject)) {\n                                            valueResult = _this7.unformat(element, anObject.getSettings());\n                                        }\n                                        break;\n                                    case 'localized':\n                                        anObject = _this7.getAutoNumericElement(element);\n                                        if (!_AutoNumericHelper2.default.isNull(anObject)) {\n                                            // Here I need to clone the setting object, otherwise I would modify it when changing the `outputFormat` option value\n                                            var currentSettings = _AutoNumericHelper2.default.cloneObject(anObject.getSettings());\n                                            if (!_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                                                currentSettings.outputFormat = forcedOutputFormat;\n                                            }\n\n                                            valueResult = _this7.localize(element, currentSettings);\n                                        }\n                                        break;\n                                    case 'formatted':\n                                    default:\n                                        valueResult = element.value;\n                                }\n                            } else {\n                                valueResult = element.value;\n                            }\n\n                            if (_AutoNumericHelper2.default.isUndefined(valueResult)) {\n                                _AutoNumericHelper2.default.throwError('This error should never be hit. If it has, something really wrong happened!');\n                            }\n\n                            if (intoAnArray) {\n                                result.push({ name: element.name, value: valueResult });\n                            } else {\n                                // into a string\n                                result.push(encodeURIComponent(element.name) + '=' + encodeURIComponent(valueResult));\n                            }\n                        }\n                    }\n                });\n            }\n\n            var finalResult = void 0;\n\n            if (intoAnArray) {\n                // Result as an Array\n                // Note: `serializedSpaceCharacter` does not affect the array result since we do not change the space character for this one\n                finalResult = result;\n            } else {\n                // Result as a string\n                finalResult = result.join('&');\n\n                if ('+' === serializedSpaceCharacter) {\n                    finalResult = finalResult.replace(/%20/g, '+');\n                }\n            }\n\n            return finalResult;\n        }\n\n        /**\n         * Serialize the form values to a string, outputting numeric strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeNumericString',\n        value: function _serializeNumericString(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, false, 'unformatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Serialize the form values to a string, outputting the formatted value as strings for each AutoNumeric-managed elements.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeFormatted',\n        value: function _serializeFormatted(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, false, 'formatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Serialize the form values to a string, outputting localized strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeLocalized',\n        value: function _serializeLocalized(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n            var forcedOutputFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            return this._serialize(form, false, 'localized', serializedSpaceCharacter, forcedOutputFormat);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting numeric strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeNumericStringArray',\n        value: function _serializeNumericStringArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, true, 'unformatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting the formatted value as strings for each AutoNumeric-managed elements.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeFormattedArray',\n        value: function _serializeFormattedArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, true, 'formatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting localized strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeLocalizedArray',\n        value: function _serializeLocalizedArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n            var forcedOutputFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            return this._serialize(form, true, 'localized', serializedSpaceCharacter, forcedOutputFormat);\n        }\n    }]);\n\n    return AutoNumeric;\n}();\n\n/**\n * Initialize multiple DOM elements in one call (and possibly pass multiple values that will be mapped to each DOM element).\n *\n * @param {string|Array|{ rootElement: HTMLElement }|{ rootElement: HTMLElement, exclude: Array<HTMLInputElement>}} arg1\n * @param {number|Array|object|null} initialValue\n * @param {object|null} options\n * @returns {Array}\n */\n\n\nAutoNumeric.multiple = function (arg1) {\n    var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    var result = [];\n\n    // Analyze the arguments and transform them to make them exploitable\n    if (_AutoNumericHelper2.default.isObject(initialValue)) {\n        // If the user gave an option object as the second argument, instead of the initial values\n        options = initialValue;\n        initialValue = null;\n    }\n\n    if (_AutoNumericHelper2.default.isString(arg1)) {\n        arg1 = [].concat(_toConsumableArray(document.querySelectorAll(arg1))); // Convert a NodeList to an Array (cf. http://stackoverflow.com/a/37297292/2834898)\n    } else if (_AutoNumericHelper2.default.isObject(arg1)) {\n        if (!arg1.hasOwnProperty('rootElement')) {\n            _AutoNumericHelper2.default.throwError('The object passed to the \\'multiple\\' function is invalid ; no \\'rootElement\\' attribute found.');\n        }\n\n        // Retrieve the DOM element list from the given <form> element\n        var elements = [].concat(_toConsumableArray(arg1.rootElement.querySelectorAll('input')));\n        if (arg1.hasOwnProperty('exclude')) {\n            if (!Array.isArray(arg1.exclude)) {\n                _AutoNumericHelper2.default.throwError('The \\'exclude\\' array passed to the \\'multiple\\' function is invalid.');\n            }\n\n            // Filter out the excluded elements\n            arg1 = _AutoNumericHelper2.default.filterOut(elements, arg1.exclude);\n        } else {\n            arg1 = elements;\n        }\n    } else if (!_AutoNumericHelper2.default.isArray(arg1)) {\n        _AutoNumericHelper2.default.throwError('The given parameters to the \\'multiple\\' function are invalid.');\n    }\n\n    if (arg1.length === 0) {\n        _AutoNumericHelper2.default.warning('No valid DOM elements were given hence no AutoNumeric object were instantiated.');\n        return [];\n    }\n\n    // Initialize the initial values\n    var isInitialValueArray = _AutoNumericHelper2.default.isArray(initialValue);\n    var isInitialValueNumber = _AutoNumericHelper2.default.isNumber(initialValue);\n    var initialValueArraySize = void 0;\n    if (isInitialValueArray) {\n        initialValueArraySize = initialValue.length;\n    }\n\n    // Instantiate each AutoNumeric objects\n    arg1.forEach(function (domElement, index) {\n        if (isInitialValueNumber) {\n            // We set the same value for each elements\n            result.push(new AutoNumeric(domElement, initialValue, options));\n        } else if (isInitialValueArray && index <= initialValueArraySize) {\n            result.push(new AutoNumeric(domElement, initialValue[index], options));\n        } else {\n            result.push(new AutoNumeric(domElement, null, options));\n        }\n    });\n\n    return result;\n};\n\n/**\n * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n * //TODO Make sure we call that at least once when loading the AutoNumeric library\n */\n(function () {\n    if (typeof window.CustomEvent === 'function') {\n        return false;\n    }\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: void 0 };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    window.CustomEvent = CustomEvent;\n})();\n\n/**\n * //XXX This is needed in order to get direct access to the `AutoNumeric` constructor without having to use `new AutoNumeric.default()` (cf. http://stackoverflow.com/a/36389244/2834898) : using `export var __useDefault = true;` does not work though.\n * //XXX The workaround (using `module.exports = AutoNumeric` instead of `export default class AutoNumeric {}`) comes from https://github.com/webpack/webpack/issues/706#issuecomment-167908576\n * //XXX And the explanation why Babel 6 changed the way Babel 5 worked : http://stackoverflow.com/a/33506169/2834898\n * //XXX Ideally, we should be able to just declare `export default class AutoNumeric {}` in the future, and remove the following `module.exports = AutoNumeric;` line\n *\n * @type {AutoNumeric}\n */\nmodule.exports = AutoNumeric;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWMuanM/YjJlOSJdLCJuYW1lcyI6WyJBdXRvTnVtZXJpYyIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIl9zZXRBcmd1bWVudHNWYWx1ZXMiLCJkb21FbGVtZW50IiwiaW5pdGlhbFZhbHVlIiwidXNlck9wdGlvbnMiLCJfc2V0U2V0dGluZ3MiLCJfY2hlY2tFbGVtZW50Iiwic2F2ZWRDYW5jZWxsYWJsZVZhbHVlIiwiaGlzdG9yeVRhYmxlIiwiaGlzdG9yeVRhYmxlSW5kZXgiLCJvbkdvaW5nUmVkbyIsInJ1bk9uY2UiLCJzZXR0aW5ncyIsImZvcm1hdE9uUGFnZUxvYWQiLCJfZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsImlzSW5wdXRFbGVtZW50IiwiaXNDb250ZW50RWRpdGFibGUiLCJub0V2ZW50TGlzdGVuZXJzIiwiX2NyZWF0ZUV2ZW50TGlzdGVuZXJzIiwiX3NldFJlYWRPbmx5IiwiX3NhdmVJbml0aWFsVmFsdWVzIiwiaXNGb2N1c2VkIiwiY3JlYXRlTG9jYWxMaXN0IiwiX2NyZWF0ZUxvY2FsTGlzdCIsImNvbnN0cnVjdG9yIiwiX2FkZFRvR2xvYmFsTGlzdCIsImdsb2JhbCIsInNldCIsIm5ld1ZhbHVlIiwib3B0aW9ucyIsImF1dG9OdW1lcmljTG9jYWxMaXN0IiwiZm9yRWFjaCIsImFOT2JqZWN0Iiwic2V0VW5mb3JtYXR0ZWQiLCJ2YWx1ZSIsImdldCIsInJlc3VsdCIsInB1c2giLCJnZXROdW1lcmljU3RyaW5nIiwiZ2V0Rm9ybWF0dGVkIiwiZ2V0TnVtYmVyIiwiZ2V0TG9jYWxpemVkIiwicmVmb3JtYXQiLCJ1bmZvcm1hdCIsInVuZm9ybWF0TG9jYWxpemVkIiwiZm9yY2VkT3V0cHV0Rm9ybWF0IiwidXBkYXRlIiwibmV3T3B0aW9ucyIsImlzUHJpc3RpbmUiLCJjaGVja09ubHlSYXdWYWx1ZSIsImNsZWFyIiwiZm9yY2VDbGVhckFsbCIsInJlbW92ZSIsIndpcGUiLCJudWtlIiwiaGFzIiwiZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QiLCJub2RlIiwiYWRkT2JqZWN0Iiwib3RoZXJBdXRvTnVtZXJpY09iamVjdCIsImdldEF1dG9OdW1lcmljRWxlbWVudCIsIl9oYXNMb2NhbExpc3QiLCJvdGhlckFOTG9jYWxMaXN0IiwiX2dldExvY2FsTGlzdCIsInNpemUiLCJtZXJnZWRMb2NhbExpc3RzIiwiTWFwIiwibWVyZ2VNYXBzIiwiX2FkZFRvTG9jYWxMaXN0IiwiX3NldExvY2FsTGlzdCIsInJlbW92ZU9iamVjdCIsImtlZXBDdXJyZW50QU5PYmplY3QiLCJpbml0aWFsQ29tcGxldGVMb2NhbExpc3QiLCJkZWxldGUiLCJlbXB0eSIsImtlZXBFYWNoQU5PYmplY3RJbkl0c093bkxpc3QiLCJlbGVtZW50cyIsImdldExpc3QiLCJyZXNldCIsImRlZmF1bHRTZXR0aW5ncyIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJjYXJldFBvc2l0aW9uT25Gb2N1cyIsIl9kZWxldGVMb2NhbExpc3QiLCJjdXJyZW5jeVN5bWJvbCIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwiZGVjaW1hbENoYXJhY3RlciIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMiLCJkZWZhdWx0VmFsdWVPdmVycmlkZSIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkaWdpdEdyb3VwU2VwYXJhdG9yIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwiZmFpbE9uVW5rbm93bk9wdGlvbiIsImlzQ2FuY2VsbGFibGUiLCJsZWFkaW5nWmVybyIsIm1heGltdW1WYWx1ZSIsIm1pbmltdW1WYWx1ZSIsIm1vZGlmeVZhbHVlT25XaGVlbCIsIm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIiwibmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQiLCJub0V2ZW50cyIsImFkZEV2ZW50cyIsIl9yZW1vdmVFdmVudExpc3RlbmVycyIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsIm9uSW52YWxpZFBhc3RlIiwib3V0cHV0Rm9ybWF0Iiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJyZWFkT25seSIsInJvdW5kaW5nTWV0aG9kIiwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSIsInNjYWxlRGVjaW1hbFBsYWNlcyIsInNjYWxlRGl2aXNvciIsInNjYWxlU3ltYm9sIiwic2VsZWN0TnVtYmVyT25seSIsInNlbGVjdE9uRm9jdXMiLCJzZXJpYWxpemVTcGFjZXMiLCJzaG93UG9zaXRpdmVTaWduIiwic2hvd1dhcm5pbmdzIiwic3R5bGVSdWxlcyIsInN1ZmZpeFRleHQiLCJ1bmZvcm1hdE9uSG92ZXIiLCJ1bmZvcm1hdE9uU3VibWl0Iiwid2hlZWxTdGVwIiwiaW5pdGlhbFZhbHVlSHRtbEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImlzTnVsbCIsIl9vbkZvY3VzSW5GdW5jIiwiX29uRm9jdXNJbiIsImUiLCJfb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMiLCJfb25Gb2N1c0luQW5kTW91c2VFbnRlciIsIl9vbkZvY3VzRnVuYyIsIl9vbkZvY3VzIiwiX29uS2V5ZG93bkZ1bmMiLCJfb25LZXlkb3duIiwiX29uS2V5cHJlc3NGdW5jIiwiX29uS2V5cHJlc3MiLCJfb25JbnB1dEZ1bmMiLCJfb25JbnB1dCIsIl9vbktleXVwRnVuYyIsIl9vbktleXVwIiwiX29uQmx1ckZ1bmMiLCJfb25CbHVyIiwiX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYyIsIl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIl9vblBhc3RlRnVuYyIsIl9vblBhc3RlIiwiX29uV2hlZWxGdW5jIiwiX29uV2hlZWwiLCJfb25Gb3JtU3VibWl0RnVuYyIsIl9vbkZvcm1TdWJtaXQiLCJfb25LZXlkb3duR2xvYmFsRnVuYyIsIl9vbktleWRvd25HbG9iYWwiLCJfb25LZXl1cEdsb2JhbEZ1bmMiLCJfb25LZXl1cEdsb2JhbCIsIl9vbkRyb3BGdW5jIiwiX29uRHJvcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXJlbnRGb3JtIiwiZm9ybSIsIl9kb2VzR2xvYmFsTGlzdEV4aXN0cyIsImRvY3VtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzRW1wdHlIaXN0b3J5VGFibGUiLCJsZW5ndGgiLCJyYXdWYWx1ZSIsIl9oaXN0b3J5VGFibGVDdXJyZW50VmFsdWVVc2VkIiwiYWRkTmV3SGlzdG9yeVN0YXRlIiwibmV4dEhpc3RvcnlTdGF0ZUluZGV4IiwiYXJyYXlUcmltIiwic2VsZWN0aW9uIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJlbmQiLCJoaXN0b3J5U2l6ZSIsIl9oaXN0b3J5VGFibGVGb3JnZXQiLCJ1bmRvIiwiY2hlY2siLCJ1bmRvSW5mbyIsInNldEVsZW1lbnRTZWxlY3Rpb24iLCJfaGlzdG9yeVRhYmxlVW5kb09yUmVkbyIsIm51bWJlck9mRW50cmllc1RvRm9yZ2V0Iiwic2hpZnRlZEF3YXkiLCJpIiwic2hpZnQiLCJpbmRleFRvVXNlIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwicG9zaXRpdmUiLCJfYWRkQ1NTQ2xhc3MiLCJfcmVtb3ZlQ1NTQ2xhc3MiLCJuZWdhdGl2ZSIsInJhbmdlcyIsInJhbmdlIiwibWluIiwibWF4IiwiY2xhc3MiLCJ1c2VyRGVmaW5lZCIsImlzRnVuY3Rpb24iLCJ1c2VyT2JqZWN0IiwiY2FsbGJhY2siLCJpc1N0cmluZyIsImNsYXNzZXMiLCJpc0FycmF5IiwiY2FsbGJhY2tSZXN1bHQiLCJ1c2VyQ2xhc3MiLCJpbmRleCIsImlzSW5BcnJheSIsImlzSW50IiwidGhyb3dFcnJvciIsIndhcm5pbmciLCJjc3NDbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJudW1lcmljU3RyaW5nIiwib3B0aW9uc1RvVXNlIiwib3B0aW9uT2JqZWN0IiwiZXJyb3IiLCJzYXZlQ2hhbmdlVG9IaXN0b3J5IiwiaXNVbmRlZmluZWQiLCJfdG9OdW1lcmljVmFsdWUiLCJpc05hTiIsIk51bWJlciIsInNldFZhbHVlIiwiemVybyIsIl9jaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbiIsIm1pblRlc3QiLCJtYXhUZXN0IiwiaXNaZXJvIiwiaXNaZXJvT3JIYXNOb1ZhbHVlIiwiaGFzQmVlblJvdW5kZWQiLCJ0ZW1wRGVjaW1hbCIsIl9yb3VuZFZhbHVlIiwiX3RyaW1MZWFkaW5nQW5kVHJhaWxpbmdaZXJvcyIsInJlcGxhY2UiLCJ0b1N0cmluZyIsIl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUiLCJfYWRkR3JvdXBTZXBhcmF0b3JzIiwiX3NhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UiLCJfc2V0RWxlbWVudEFuZFJhd1ZhbHVlIiwiYXR0ZW1wdGVkVmFsdWUiLCJ0cmlnZ2VyRXZlbnQiLCJldmVudHMiLCJtaW5SYW5nZUV4Y2VlZGVkIiwibWF4UmFuZ2VFeGNlZWRlZCIsImFsd2F5cyIsInN0cmlwcGVkVmFsdWUiLCJfcmVtb3ZlQnJhY2tldHMiLCJub3JtYWxpemVkVmFsdWUiLCJfc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzIiwiaXNOdW1iZXIiLCJfcGFyc2VTdHlsZVJ1bGVzIiwiX2hpc3RvcnlUYWJsZUFkZCIsIm5ld0VsZW1lbnRWYWx1ZSIsIm9sZEVsZW1lbnRWYWx1ZSIsImdldEVsZW1lbnRWYWx1ZSIsInNldEVsZW1lbnRWYWx1ZSIsImZvcm1hdHRlZCIsIm9sZFZhbHVlIiwiaXNCb29sZWFuIiwiX3NldEVsZW1lbnRWYWx1ZSIsIl9zZXRSYXdWYWx1ZSIsInRyaW1QYWRkZWRaZXJvc0Zyb21EZWNpbWFsUGxhY2VzIiwiX3RvTG9jYWxlIiwiaXNFbXB0eVN0cmluZyIsImtlZXAiLCJvdXRwdXRGb3JtYXRUb1VzZSIsInNlbGVjdE51bWJlciIsIl9kZWZhdWx0U2VsZWN0QWxsIiwidW5mb3JtYXR0ZWRWYWx1ZSIsInZhbHVlTGVuIiwiY3VycmVuY3lTeW1ib2xTaXplIiwibmVnTGVuIiwiaXNOZWdhdGl2ZSIsInN1ZmZpeFRleHRMZW4iLCJzdWZmaXgiLCJsZWZ0IiwicHJlZml4IiwicmlnaHQiLCJpc1Bvc2l0aXZlIiwibm9uZSIsImVsZW1lbnRWYWx1ZSIsImluZGV4T2YiLCJkZWNpbWFsQ291bnQiLCJwYXJlbnROb2RlIiwib3RoZXJBbkVsZW1lbnQiLCJkb21FbGVtZW50VG9EZXRhY2giLCJfcmVtb3ZlRnJvbUxvY2FsTGlzdCIsInJlRm9ybWF0IiwidmFsdWVPckVsZW1lbnQiLCJvcHRpb25PdmVycmlkZSIsIl9mb3JtYXRPclVuZm9ybWF0T3RoZXIiLCJzdHJpbmdPckVsZW1lbnQiLCJpc0Zvcm1hdHRpbmciLCJ2YWx1ZU9yU3RyaW5nT3JFbGVtZW50Iiwic2V0dGluZ3NUb1VzZSIsIl9jbG9uZUFuZE1lcmdlU2V0dGluZ3MiLCJpc0VsZW1lbnQiLCJmb3JtYXQiLCJkb21FbGVtZW50T3JBcnJheU9yU3RyaW5nIiwiYXR0YWNoZWQiLCJyZXR1cm5BU2luZ2xlQXV0b051bWVyaWNPYmplY3QiLCJkb21FbGVtZW50c0FycmF5IiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRMb2NhbExpc3QiLCJhdXRvTnVtZXJpY09iamVjdHNBcnJheSIsIm9yaWdpbmFsQ3JlYXRlTG9jYWxMaXN0U2V0dGluZyIsIm5ld0F1dG9OdW1lcmljRWxlbWVudCIsInRlbXBvcmFyeUZvcmNlZE9wdGlvbnMiLCJmb2N1cyIsIl9yZW1vdmVGcm9tR2xvYmFsTGlzdCIsInJlbW92ZUNoaWxkIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmciLCJfc2VyaWFsaXplRm9ybWF0dGVkIiwiX3NlcmlhbGl6ZUxvY2FsaXplZCIsIl9zZXJpYWxpemVOdW1lcmljU3RyaW5nQXJyYXkiLCJfc2VyaWFsaXplRm9ybWF0dGVkQXJyYXkiLCJfc2VyaWFsaXplTG9jYWxpemVkQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybUFycmF5TnVtZXJpY1N0cmluZyIsImZvcm1BcnJheUZvcm1hdHRlZCIsImZvcm1BcnJheUxvY2FsaXplZCIsImlucHV0cyIsIl9nZXRDaGlsZEFOSW5wdXRFbGVtZW50IiwiaW5wdXQiLCJmb3JtVW5mb3JtYXQiLCJzdWJtaXQiLCJmb3JtUmVmb3JtYXQiLCJmb3JtTnVtZXJpY1N0cmluZyIsImZvcm1Gb3JtYXR0ZWQiLCJmb3JtVW5mb3JtYXRMb2NhbGl6ZWQiLCJmb3JtTG9jYWxpemVkIiwiZm9ybUpzb25OdW1lcmljU3RyaW5nIiwiZm9ybUpzb25Gb3JtYXR0ZWQiLCJmb3JtSnNvbkxvY2FsaXplZCIsImxvY2FsTGlzdCIsImF1dG9OdW1lcmljT2JqZWN0IiwibmV3U2V0dGluZ3MiLCJwcmVkZWZpbmVkT3B0aW9uIiwiX21lcmdlU2V0dGluZ3MiLCJfdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMiLCJnZXRQcmVkZWZpbmVkT3B0aW9ucyIsIkZyZW5jaCIsIk5vcnRoQW1lcmljYW4iLCJCcml0aXNoIiwiU3dpc3MiLCJKYXBhbmVzZSIsIlNwYW5pc2giLCJDaGluZXNlIiwiQnJhemlsaWFuIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJodG1sQXR0cmlidXRlIiwiY2FtZWxpemUiLCJpc1RyYWlsaW5nTmVnYXRpdmUiLCJzcGxpdCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwicyIsIm5lZ2F0aXZlU2lnbkNoYXJhY3RlciIsIm1hdGNoIiwiaXNWYWx1ZU5lZ2F0aXZlIiwidG90YWxMZW5ndGgiLCJ2YWx1ZVNpemUiLCJpbnRlZ2VyU2l6ZSIsImhhc0RlY2ltYWxDaGFyIiwib2Zmc2V0RGVjaW1hbENoYXIiLCJjb250YWlucyIsImRlY2ltYWxMZWZ0IiwiZGVjaW1hbFJpZ2h0Iiwic2lnblRvVXNlIiwicG9zaXRpdmVTaWduQ2hhcmFjdGVyIiwicG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplIiwiY2FyZXRQb3NpdGlvbiIsIm9yaWdpbmFsRGVjaW1hbFBsYWNlc092ZXJyaWRlIiwib3JpZ2luYWxBbGxvd0RlY2ltYWxQYWRkaW5nIiwib3JpZ2luYWxOZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsIm9yaWdpbmFsRGlnaXRHcm91cFNlcGFyYXRvciIsIm9yaWdpbmFsQ3VycmVuY3lTeW1ib2wiLCJvcmlnaW5hbFN1ZmZpeFRleHQiLCJhY3Rpb24iLCJzdG9yZWROYW1lIiwibmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJfc3RvcmFnZVRlc3QiLCJjb29raWUiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsIl9yZWFkQ29va2llIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEl0ZW0iLCJpbml0aWFsRWxlbWVudFZhbHVlIiwidHlwZSIsImFsdEtleSIsIl91bmZvcm1hdEFsdEhvdmVyZWQiLCJob3ZlcmVkV2l0aEFsdCIsIl9yZWZvcm1hdEFsdEhvdmVyZWQiLCJ1cGRhdGVFbGVtZW50VmFsdWUiLCJyb3VuZGVkVmFsdWUiLCJ2YWx1ZU9uRm9jdXMiLCJ0YXJnZXQiLCJsYXN0VmFsIiwiaXNFbXB0eVZhbHVlIiwiX2lzRWxlbWVudFZhbHVlRW1wdHlPck9ubHlUaGVOZWdhdGl2ZVNpZ24iLCJvcmRlcmVkVmFsdWUiLCJfb3JkZXJWYWx1ZUN1cnJlbmN5U3ltYm9sQW5kU3VmZml4VGV4dCIsIl9zYXZlQ2FuY2VsbGFibGVWYWx1ZSIsInNlbGVjdCIsIl9pbml0aWFsQ2FyZXRQb3NpdGlvbiIsImdldEhvdmVyZWRFbGVtZW50IiwiX3VwZGF0ZUV2ZW50S2V5SW5mbyIsImluaXRpYWxWYWx1ZU9uS2V5ZG93biIsInByb2Nlc3NlZCIsImV2ZW50S2V5Iiwia2V5TmFtZSIsIkVzYyIsInByZXZlbnREZWZhdWx0IiwibmF0aXZlIiwidGFyZ2V0VmFsdWUiLCJFbnRlciIsImNoYW5nZSIsIl91cGRhdGVJbnRlcm5hbFByb3BlcnRpZXMiLCJfcHJvY2Vzc05vblByaW50YWJsZUtleXNBbmRTaG9ydGN1dHMiLCJCYWNrc3BhY2UiLCJEZWxldGUiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uIiwiX2Zvcm1hdFZhbHVlIiwidGhyb3dJbnB1dCIsIkluc2VydCIsImlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCIsIl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uIiwicG9zaXRpb24iLCJhbmRyb2lkU2VsZWN0aW9uU3RhcnQiLCJBbmRyb2lkRGVmYXVsdCIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24iLCJoYXNEZWNpbWFsQ2hhcmFjdGVyIiwiX3NldENhcmV0UG9zaXRpb24iLCJaIiwieiIsImN0cmxLZXkiLCJzaGlmdEtleSIsIl9oaXN0b3J5VGFibGVSZWRvIiwiX2hpc3RvcnlUYWJsZVVuZG8iLCJBbHQiLCJza2lwIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwiaXNPbkFuZHJvaWQiLCJUYWIiLCJvcmlnVmFsdWUiLCJfbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlIiwiZ3JvdXBlZFZhbHVlIiwibmV2ZXIiLCJmbG9hdHMiLCJyYXdQYXN0ZWRUZXh0IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsImlzTmVnYXRpdmVTdHJpY3QiLCJzbGljZSIsInVudHJhbnNsYXRlZFBhc3RlZFRleHQiLCJfcHJlcGFyZVBhc3RlZFRleHQiLCJwYXN0ZWRUZXh0IiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyIsImluaXRpYWxVbmZvcm1hdHRlZE51bWJlciIsImlzSW5pdGlhbFZhbHVlTmVnYXRpdmUiLCJpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlIiwibGVmdFBhcnRDb250YWluZWRBRG90IiwibGVmdFBhcnQiLCJyaWdodFBhcnQiLCJ0cnVuY2F0ZSIsImxlZnRGb3JtYXR0ZWRQYXJ0IiwicmlnaHRGb3JtYXR0ZWRQYXJ0Iiwic2V0UmF3TmVnYXRpdmVTaWduIiwiY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uIiwiY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlIiwibWluUGFyc2UiLCJwYXJzZVN0ciIsIm1heFBhcnNlIiwibGFzdEdvb2RLbm93blJlc3VsdCIsInBhc3RlZFRleHRJbmRleCIsIm1vZGlmaWVkTGVmdFBhcnQiLCJfY2hlY2tJZkluUmFuZ2UiLCJsYXN0R29vZEtub3duUmVzdWx0SW5kZXgiLCJsYXN0R29vZEtub3duUmVzdWx0U2l6ZSIsInJlcGxhY2VDaGFyQXQiLCJpZ25vcmUiLCJjbGFtcCIsImxlZnRGb3JtYXR0ZWRQYXJ0MiIsInJpZ2h0Rm9ybWF0dGVkUGFydDIiLCJpbmRleFdoZXJlUGFzdGVkVGV4dEhhc0JlZW5JbnNlcnRlZCIsImluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSIsInNlbGVjdGVkVGV4dCIsImNvdW50Q2hhckluVGV4dCIsInZhbHVlSGFzQmVlblNldCIsInZhbHVlSGFzQmVlbkNsYW1wZWQiLCJjbGFtcGVkVmFsdWUiLCJjbGFtcFRvUmFuZ2VMaW1pdHMiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwiY3VycmVudFVuZm9ybWF0dGVkVmFsdWUiLCJpc1doZWVsVXBFdmVudCIsImlzV2hlZWxEb3duRXZlbnQiLCJzdGVwIiwiYWRkQW5kUm91bmRUb05lYXJlc3RBdXRvIiwic3VidHJhY3RBbmRSb3VuZFRvTmVhcmVzdEF1dG8iLCJfc2V0U2VsZWN0aW9uIiwiZHJvcHBlZFRleHQiLCJkYXRhVHJhbnNmZXIiLCJjbGVhbmVkVmFsdWUiLCJ1bmZvcm1hdE90aGVyIiwiY2hhcmFjdGVyIiwiaG92ZXJlZEVsZW1lbnQiLCJpc01hbmFnZWRCeUF1dG9OdW1lcmljIiwiYW5FbGVtZW50IiwiYWxsb3dlZFRhZ0xpc3QiLCJjdXJyZW50RWxlbWVudFRhZyIsIl9pc0VsZW1lbnRUYWdTdXBwb3J0ZWQiLCJfaXNJbnB1dEVsZW1lbnQiLCJfaXNJbnB1dFR5cGVTdXBwb3J0ZWQiLCJoYXNBdHRyaWJ1dGUiLCJmb3JjZWRJbml0aWFsVmFsdWUiLCJjdXJyZW50VmFsdWUiLCJ1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSIsIkluZmluaXR5IiwidG9TdHJpcCIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJtSW50UG9zIiwiTWF0aCIsIm1JbnROZWciLCJfbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCIsIlN0cmluZyIsIl9jb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyIsImdldERlZmF1bHRDb25maWciLCJkYXRhc2V0IiwiY2FyZXRGaXgiLCJfdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzIiwiX2NvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbiIsIl9jb3JyZWN0Q2FyZXRQb3NpdGlvbk9uRm9jdXNBbmRTZWxlY3RPbkZvY3VzT3B0aW9ucyIsIl9ydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QiLCJfY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMiLCJfY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbiIsIl9zZXRBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJfc2V0VHJhaWxpbmdOZWdhdGl2ZVNpZ25JbmZvIiwicmVnZXgiLCJfY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMiLCJfc2V0QnJhY2tldHMiLCJ2YWxpZGF0ZSIsImlzRW1wdHlPYmoiLCJfa2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkiLCJ0ZXh0Iiwic3Vic3RyaW5nIiwiX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJzdHJpcFplcm9zIiwiSHlwaGVuIiwiZGVueSIsIm51bTAiLCJudW1wYWQwIiwibSIsIlJlZ0V4cCIsImFOZWdSZWdBdXRvU3RyaXAiLCJpc1Bhc3RlIiwiX25vcm1hbGl6ZVBhcnRzIiwibm9ybWFsaXplZExlZnQiLCJub3JtYWxpemVkUmlnaHQiLCJub3JtYWxpemVkTmV3VmFsdWUiLCJfdHJ1bmNhdGVEZWNpbWFsUGxhY2VzIiwidGVzdFZhbHVlIiwiY3VycmVuY3lTeW1ib2xMZW4iLCJoYXNOZWciLCJfZ2V0U2lnblBvc2l0aW9uIiwic2lnblBvc2l0aW9uIiwiY3VycmVuY3lTeW1ib2xQb3NpdGlvbiIsIm9sZFBhcnRzIiwic3Vic3RyIiwiX3NldFZhbHVlUGFydHMiLCJqb2luIiwibWV0YUtleSIsIl9jaGVja1Bhc3RlIiwiX3Nob3VsZFNraXBFdmVudEtleSIsImEiLCJjIiwidiIsIngiLCJfZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiTGVmdEFycm93IiwiUmlnaHRBcnJvdyIsIl9kaXJlY3Rpb25LZXlzIiwiX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduIiwiTnVtcGFkRG90IiwiZXZlbnROdW1iZXIiLCJzdWJQYXJ0cyIsIm5lZ2F0aXZlU2lnbiIsImxlZnRBciIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiaXNBcmcxRWxlbWVudCIsImlzQXJnMVN0cmluZyIsImlzQXJnMk9iamVjdCIsImlzT2JqZWN0IiwiaXNBcmcyTnVtYmVyIiwiaXNOdW1iZXJPckFyYWJpYyIsImlzQXJnMk51bGwiLCJpc0FyZzJFbXB0eVN0cmluZyIsImlzQXJnM09iamVjdCIsImlzQXJnM051bGwiLCJxdWVyeVNlbGVjdG9yIiwiZm9ybU5vZGUiLCJpbnB1dExpc3QiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImF1dG9OdW1lcmljSW5wdXRzIiwiaW5wdXRFbGVtZW50cyIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsInRlc3QiLCJfaXNJbkdsb2JhbExpc3QiLCJ3ZWFrTWFwTmFtZSIsIndpbmRvdyIsIldlYWtNYXAiLCJhdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lIiwiX2NyZWF0ZVdlYWtNYXAiLCJfY3JlYXRlR2xvYmFsTGlzdCIsIl9nZXRGcm9tR2xvYmFsTGlzdCIsInNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIiwib3JpZ2luYWxPcHRpb25zIiwiaXNPcmlnaW5hbE9wdGlvbkFuT2JqZWN0IiwiaXNUcnVlT3JGYWxzZVN0cmluZyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJkb05vRm9yY2VDYXJldFBvc2l0aW9uIiwiY29tbWEiLCJkb3QiLCJub3JtYWxTcGFjZSIsInRoaW5TcGFjZSIsIm5hcnJvd05vQnJlYWtTcGFjZSIsIm5vQnJlYWtTcGFjZSIsIm5vU2VwYXJhdG9yIiwiYXBvc3Ryb3BoZSIsImFyYWJpY1Rob3VzYW5kc1NlcGFyYXRvciIsImRvdEFib3ZlIiwibWlkZGxlRG90IiwiYXJhYmljRGVjaW1hbFNlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3JLZXlTeW1ib2wiLCJjZWlsaW5nIiwiZmxvb3IiLCJwYXJzZUZsb2F0Iiwidk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyIsImhhbGZVcFN5bW1ldHJpYyIsImhhbGZVcEFzeW1tZXRyaWMiLCJoYWxmRG93blN5bW1ldHJpYyIsImhhbGZEb3duQXN5bW1ldHJpYyIsImhhbGZFdmVuQmFua2Vyc1JvdW5kaW5nIiwidXBSb3VuZEF3YXlGcm9tWmVybyIsImRvd25Sb3VuZFRvd2FyZFplcm8iLCJ0b0NlaWxpbmdUb3dhcmRQb3NpdGl2ZUluZmluaXR5IiwidG9GbG9vclRvd2FyZE5lZ2F0aXZlSW5maW5pdHkiLCJ0b05lYXJlc3QwNSIsInRvTmVhcmVzdDA1QWx0IiwidXBUb05leHQwNSIsImRvd25Ub05leHQwNSIsInBhcmVudGhlc2VzIiwiYnJhY2tldHMiLCJjaGV2cm9ucyIsImN1cmx5QnJhY2VzIiwiYW5nbGVCcmFja2V0cyIsImphcGFuZXNlUXVvdGF0aW9uTWFya3MiLCJoYWxmQnJhY2tldHMiLCJ3aGl0ZVNxdWFyZUJyYWNrZXRzIiwicXVvdGF0aW9uTWFya3MiLCJndWlsbGVtZXRzIiwicHJlc3MiLCJhbGxvdyIsInN0cmluZyIsIm51bWJlciIsIm5lZ2F0aXZlRG90IiwibmVnYXRpdmVDb21tYSIsImRvdE5lZ2F0aXZlIiwiY29tbWFOZWdhdGl2ZSIsInBsdXMiLCJwZXJjZW50IiwicnVsZSIsImlzVmFsaWQiLCJwcmVkZWZpbmVkT3B0aW9ucyIsInZhbHVlT3JEb21FbGVtZW50IiwidmFsdWVTdHJpbmciLCJmb3JtYXR0ZWRWYWx1ZSIsIm51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQiLCJpc051bWJlclN0cmljdCIsIl9jb252ZXJ0VG9OdW1lcmljU3RyaW5nIiwidW53YW50ZWRDaGFyYWN0ZXJzIiwiTmFOIiwibG9jYWxpemVkVmFsdWUiLCJsb2NhbGl6ZSIsImRlY2ltYWxQbGFjZXMiLCJza2lwRmlyc3RBdXRvU3RyaXAiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJudW1SZWdBdXRvU3RyaXAiLCJpbnRlZ2VyUGFydCIsImRlY2ltYWxQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsInN0cmlwUmVnIiwiX2FkZEJyYWNrZXRzIiwicmVhcnJhbmdlU2lnbnNBbmRWYWx1ZU9yZGVyIiwiX21lcmdlQ3VycmVuY3lTaWduTmVnYXRpdmVQb3NpdGl2ZVNpZ25BbmRWYWx1ZSIsImxhc3RJbmRleE9mIiwiY29udmVydFRvTnVtYmVyIiwidGVtcCIsImxvY2FsZSIsInNpZ25PbkVtcHR5IiwiaW5wdXRWYWx1ZSIsImlzTmVnYXRpdmVXaXRoQnJhY2tldHMiLCJkaWdpdGFsR3JvdXAiLCJ0d28iLCJ0d29TY2FsZWQiLCJmb3VyIiwidGhyZWUiLCJfdG9nZ2xlTmVnYXRpdmVCcmFja2V0Iiwicm91bmRlZElucHV0VmFsdWUiLCJfcm91bmRDbG9zZVRvMDUiLCJfcHJlcGFyZVZhbHVlRm9yUm91bmRpbmciLCJwcmVwYXJlZFZhbHVlIiwiaW5wdXRWYWx1ZUhhc0FEb3QiLCJoYXNEZWNpbWFscyIsInZpcnR1YWxEZWNpbWFsUG9zaXRpb24iLCJ0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJpbnB1dFZhbHVlUm91bmRlZCIsImNoZWNrRGVjaW1hbFBsYWNlcyIsInplcm9zIiwiX3RydW5jYXRlWmVyb3MiLCJyb3VuZGVkU3RyTGVuZ3RoIiwibGFzdERpZ2l0IiwiaW5wdXRWYWx1ZUFycmF5Iiwib2RkIiwiX3Nob3VsZFJvdW5kVXAiLCJyb3VuZCIsImNlaWwiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwidmFsUGFyc2UiLCJ0ZXN0TWluTWF4IiwibmFtZUVRIiwiY2EiLCJtb2QiLCJkb05vdFNlbGVjdCIsImFsbE51bWJlcnNSZWciLCJub0FsbE51bWJlcnNSZWciLCJhTmVnUmVnIiwibmVnYXRpdmVTaWduUmVnUGFydCIsImFsbG93ZWQiLCJvbGRPcHRpb25zQ29udmVydGVyIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURlY2ltYWwiLCJhU3RvciIsIm1Sb3VuZCIsImFQYWQiLCJuQnJhY2tldCIsIndFbXB0eSIsImxaZXJvIiwiYUZvcm0iLCJzTnVtYmVyIiwiYW5EZWZhdWx0IiwidW5TZXRPblN1Ym1pdCIsIm91dHB1dFR5cGUiLCJkZWJ1ZyIsIm9wdGlvbiIsInBhcnNlZE1pblZhbHVlIiwicGFyc2VkTWF4VmFsdWUiLCJwYXJzZWRWYWx1ZSIsImV2ZW50S2V5TmFtZSIsImlzRm5LZXlzIiwiX2FsbEZuS2V5cyIsImlzT1NLZXlzIiwiT1NMZWZ0IiwiT1NSaWdodCIsImlzQ29udGV4dE1lbnUiLCJDb250ZXh0TWVudSIsImlzU29tZU5vblByaW50YWJsZUtleXMiLCJfc29tZU5vblByaW50YWJsZUtleXMiLCJpc090aGVyTm9uUHJpbnRhYmxlS2V5cyIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiQ29tbWFuZCIsImlzVW5yZWNvZ25pemFibGVLZXlzIiwiVW5pZGVudGlmaWVkIiwiaW50b0FuQXJyYXkiLCJmb3JtYXRUeXBlIiwic2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyIiwibm9kZU5hbWUiLCJlbGVtZW50IiwiZGlzYWJsZWQiLCJzZWxlY3RlZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImNoZWNrZWQiLCJ2YWx1ZVJlc3VsdCIsImFuT2JqZWN0IiwiZ2V0U2V0dGluZ3MiLCJjdXJyZW50U2V0dGluZ3MiLCJjbG9uZU9iamVjdCIsImZpbmFsUmVzdWx0IiwiX3NlcmlhbGl6ZSIsIm11bHRpcGxlIiwicm9vdEVsZW1lbnQiLCJleGNsdWRlIiwiZmlsdGVyT3V0IiwiaXNJbml0aWFsVmFsdWVBcnJheSIsImlzSW5pdGlhbFZhbHVlTnVtYmVyIiwiaW5pdGlhbFZhbHVlQXJyYXlTaXplIiwiQ3VzdG9tRXZlbnQiLCJldmVudCIsInBhcmFtcyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGV0YWlsIiwiZXZ0IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJFdmVudCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O3FqQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBOztBQUVBOzs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS01BLFc7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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TnVtZXJpYy5qc1xuICpcbiAqIEB2ZXJzaW9uICAgICAgNC4wLjAtYmV0YS4xNlxuICogQGRhdGUgICAgICAgICAyMDE3LTA0LTE5IFVUQyAwOTowMFxuICpcbiAqIEBhdXRob3IgICAgICAgQm9iIEtub3RoZVxuICogQGNvbnRyaWJ1dG9ycyBBbGV4YW5kcmUgQm9ubmVhdSwgU29rb2xvdiBZdXJhIGFuZCBvdGhlcnMsIGNmLiBBVVRIT1JTLm1kXG4gKiBAY29weXJpZ2h0ICAgIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4gKiBAc2luY2UgICAgICAgIDIwMDktMDgtMDlcbiAqXG4gKiBAc3VtbWFyeSAgICAgIGF1dG9OdW1lcmljIGlzIGEgc3RhbmRhbG9uZSBKYXZhc2NyaXB0IGxpYnJhcnlcbiAqICAgICAgICAgICAgICAgdGhhdCBwcm92aWRlcyBsaXZlICphcy15b3UtdHlwZSogZm9ybWF0dGluZyBmb3JcbiAqICAgICAgICAgICAgICAgaW50ZXJuYXRpb25hbCBudW1iZXJzIGFuZCBjdXJyZW5jaWVzLlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZSA6IFNvbWUgZnVuY3Rpb25zIGFyZSBib3Jyb3dlZCBmcm9tIGJpZy5qc1xuICogQGxpbmsgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gKlxuICogUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vYXV0b051bWVyaWMvYXV0b051bWVyaWNcbiAqXG4gKiBAbGljZW5zZSAgICAgIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogQGxpbmsgICAgICAgICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGdsb2JhbCBtb2R1bGUgKi9cblxuLy9UT0RPIFByZXZlbnQgaGF2aW5nIHRvIGVudGVyIHJlbGF0aXZlIHBhdGggaW4gdGhlIGpzIGZpbGVzIChpZS4gdXNpbmcgYC4vQXV0b051bWVyaWNIZWxwZXJgIGluc3RlYWQgb2YganVzdCBgQXV0b051bWVyaWNIZWxwZXJgKSAoY2YuIGh0dHA6Ly9tb2R1c2NyZWF0ZS5jb20vZXM2LWVzMjAxNS1pbXBvcnQtbm8tcmVsYXRpdmUtcGF0aC13ZWJwYWNrLylcbmltcG9ydCBBdXRvTnVtZXJpY0hlbHBlciBmcm9tICcuL0F1dG9OdW1lcmljSGVscGVyJztcbmltcG9ydCBBdXRvTnVtZXJpY0VudW0gZnJvbSAnLi9BdXRvTnVtZXJpY0VudW0nO1xuXG4vKipcbiAqIENsYXNzIGRlY2xhcmF0aW9uIGZvciB0aGUgQXV0b051bWVyaWMgb2JqZWN0LlxuICpcbiAqIEFuIEF1dG9OdW1lcmljIGVsZW1lbnQgaXMgYW4gb2JqZWN0IHdyYXBwZXIgdGhhdCBrZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIGVsZW1lbnQgaXQgbWFuYWdlcyAodXN1YWxseSBhbiA8aW5wdXQ+IG9uZSksIGFuZCBwcm92aWRlcyBhdXRvTnVtZXJpYy1zcGVjaWZpYyB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgQXV0b051bWVyaWMge1xuICAgIC8vVE9ETyBVc2UgdGhlIGJldHRlciBub3RhdGlvbiBgZXhwb3J0IGRlZmF1bHQgY2xhc3NgIHdoZW4gd2VicGFjayBhbmQgYmFiZWwgd2lsbCBhbGxvdyBpdCAoY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svaXNzdWVzLzcwNilcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBBdXRvTnVtZXJpYyBvYmplY3Qgb250byB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQsIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIGFuZCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycyB0byBpdC5cbiAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50KTsgLy8gV2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIHsgb3B0aW9ucyB9KTsgLy8gV2l0aCBvbmUgb3B0aW9uIG9iamVjdFxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCBudWxsLCB7IG9wdGlvbnMgfSk7IC8vIFdpdGggb25lIG9wdGlvbiBvYmplY3QsIGFuZCBhIGZhaWxlZCBpbml0aWFsIHZhbHVlXG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQpLmZyZW5jaCgpOyAvLyBXaXRoIG9uZSBwcmUtZGVmaW5lZCBsYW5ndWFnZSBvYmplY3RcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCkuZnJlbmNoKHsgb3B0aW9ucyB9KTsvLyBXaXRoIG9uZSBwcmUtZGVmaW5lZCBsYW5ndWFnZSBvYmplY3QgYW5kIGFkZGl0aW9uYWwgb3B0aW9ucyB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG4gICAgICpcbiAgICAgKiAvLyAuLi5vciBpbml0IGFuZCBzZXQgdGhlIHZhbHVlIGluIG9uZSBjYWxsIDpcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgMTIzNDUuNzg5KTsgLy8gV2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBhbmQgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJzEyMzQ1Ljc4OScsIHsgb3B0aW9ucyB9KTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgMTIzNDUuNzg5KS5mcmVuY2goeyBvcHRpb25zIH0pO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KS5mcmVuY2goeyBvcHRpb25zIH0pOyAvLyBOb3QgcmVhbGx5IGhlbHBmdWwsIGJ1dCBwb3NzaWJsZVxuICAgICAqXG4gICAgICogLy8gVGhlIEF1dG9OdW1lcmljIGNvbnN0cnVjdG9yIGNsYXNzIGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyBhcyBhIGNzcyBzZWxlY3Rvci4gVW5kZXIgdGhlIGhvb2QgdGhpcyB1c2UgYFF1ZXJ5U2VsZWN0b3JgIGFuZCBsaW1pdCBpdHNlbGYgdG8gb25seSB0aGUgZmlyc3QgZWxlbWVudCBpdCBmaW5kcy5cbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnKTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCB7IG9wdGlvbnMgfSk7XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgMTIzNDUuNzg5KTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCBudWxsLCB7IG9wdGlvbnMgfSk7IC8vIFdpdGggYSBmYWlsZWQgaW5pdGlhbCB2YWx1ZVxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIDEyMzQ1Ljc4OSkuZnJlbmNoKHsgb3B0aW9ucyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fG51bWJlcnxzdHJpbmd9IGFyZzFcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzNcbiAgICAgKiBAdGhyb3dzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJnMSA9IG51bGwsIGFyZzIgPSBudWxsLCBhcmczID0gbnVsbCkge1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBJbml0aWFsaXphdGlvblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBhcmd1bWVudHNcbiAgICAgICAgY29uc3QgeyBkb21FbGVtZW50LCBpbml0aWFsVmFsdWUsIHVzZXJPcHRpb25zIH0gPSBBdXRvTnVtZXJpYy5fc2V0QXJndW1lbnRzVmFsdWVzKGFyZzEsIGFyZzIsIGFyZzMpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3ModXNlck9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgLy9UT0RPIElmIGBzdHlsZVJ1bGVzYCBpcyBub3QgbnVsbCwgYWRkIGJ5IGRlZmF1bHQgYSBjbGFzcyAnYXV0b051bWVyaWMnIHRoYXQgYWRkcyB0cmFuc2l0aW9uIHRvIGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IgcHJvcGVydGllc1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgRE9NIGVsZW1lbnQgaXMgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX2NoZWNrRWxlbWVudCgpO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBBdXRvTnVtZXJpYyBvYmplY3RcbiAgICAgICAgLy8gTm90ZTogVGhpcyB2YXJpYWJsZSBpcyBuZWVkZWQgYW5kIG5vdCBhIGR1cGxpY2F0ZSBvZiBgaW5pdGlhbFZhbHVlT25LZXlkb3duYCBub3IgYHZhbHVlT25Gb2N1c2Agc2luY2UgaXQgc2VydmVzIGEgZGlmZmVyZW50IHB1cnBvc2UgYW5kIGhhcyBhIGRpZmZlcmVudCBsaWZlY3ljbGVcbiAgICAgICAgdGhpcy5zYXZlZENhbmNlbGxhYmxlVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHVuZG8vcmVkbyB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5oaXN0b3J5VGFibGUgPSBbXTsgLy8gS2VlcCB0cmFjayBvZiAqYWxsKiB2YWxpZCBzdGF0ZXMgb2YgdGhlIGVsZW1lbnQgdmFsdWVcbiAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCA9IC0xOyAvLyBQb2ludGVyIHRvIHRoZSBjdXJyZW50IHVuZG8vcmVkbyBzdGF0ZS4gVGhpcyB3aWxsIGJlIHNldCB0byAnMCcgZHVyaW5nIGluaXRpYWxpemF0aW9uIHNpbmNlIGl0IGZpcnN0IGFkZHMgaXRzZWxmLlxuICAgICAgICB0aGlzLm9uR29pbmdSZWRvID0gZmFsc2U7IC8vIFZhcmlhYmxlIHRoYXQga2VlcHMgdHJhY2sgaWYgYSAncmVkbycgaXMgb25nb2luZyAoaW4gb3JkZXIgdG8gcHJldmVudCBhbiAndW5kbycgdG8gYmUgbGF1bmNoIHdoZW4gcmVsZWFzaW5nIHRoZSBzaGlmdCBrZXkgYmVmb3JlIHRoZSBjdHJsIGtleSBhZnRlciBhICdyZWRvJyBzaG9ydGN1dClcblxuICAgICAgICAvLyBTZXQgdGhlIGluaXRpYWwgdmFsdWUgaWYgaXQgZXhpc3RzIGFuZCBpZiB0aGUgYGZvcm1hdE9uUGFnZUxvYWRgIG9wdGlvbiB3aWxsIGFsbG93IGl0XG4gICAgICAgIGlmICghdGhpcy5ydW5PbmNlICYmIHRoaXMuc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCkge1xuICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSBlbGVtZW50IHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50cyBsaXN0ZW5lcnMgb25seSBvbiBpbnB1dCBlbGVtZW50c1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0RWxlbWVudCB8fCB0aGlzLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Mubm9FdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIC8vWFhYIEhlcmUgd2UgbWFrZSBzdXJlIHRoZSBnbG9iYWwgbGlzdCBpcyBjcmVhdGVkIGFmdGVyIGNyZWF0aW5nIHRoZSBldmVudCBsaXN0ZW5lcnMsIHRvIG9ubHkgY3JlYXRlIHRoZSBldmVudCBsaXN0ZW5lcnMgb24gYGRvY3VtZW50YCBvbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0UmVhZE9ubHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlIGluaXRpYWwgdmFsdWVzIChodG1sIGF0dHJpYnV0ZSArIGVsZW1lbnQudmFsdWUpIGZvciB0aGUgcHJpc3RpbmUgdGVzdFxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbFZhbHVlcyhpbml0aWFsVmFsdWUpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIFRyYWNraW5nXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWRcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jcmVhdGVMb2NhbExpc3QpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgZXZlcnkgQXV0b051bWVyaWMgZWxlbWVudHMgdGhhdCB0aGlzIG9iamVjdCBpbml0aWFsaXplZFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTG9jYWxMaXN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBBdXRvTnVtZXJpYyBlbGVtZW50cyBpbiB0aGUgY3VycmVudCB3ZWIgcGFnZVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9hZGRUb0dsb2JhbExpc3QodGhpcyk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0gTWV0aG9kc1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGdsb2JhbCBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5nbG9iYWwgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgc2FtZSBnaXZlbiBlbGVtZW50IHZhbHVlIGZvciBlYWNoIGVsZW1lbnRzIGluIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QsIGFuZCBmb3JtYXQgdGhvc2UgZWxlbWVudHMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG5ld1ZhbHVlIFRoZSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEEgc2V0dGluZ3Mgb2JqZWN0IHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCBzZXR0aW5ncy4gTm90ZTogdGhlIHVwZGF0ZSBpcyBkb25lIG9ubHkgaWYgdGhlIGBuZXdWYWx1ZWAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiAobmV3VmFsdWUsIG9wdGlvbnMgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3Quc2V0KG5ld1ZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBnaXZlbiB2YWx1ZSBkaXJlY3RseSBhcyB0aGUgRE9NIGVsZW1lbnQgdmFsdWUsIHdpdGhvdXQgZm9ybWF0dGluZyBpdCBiZWZvcmVoYW5kLlxuICAgICAgICAgICAgICogVGhpcyBzZXRzIHRoZSBzYW1lIHVuZm9ybWF0dGVkIHZhbHVlIGZvciBlYWNoIGVsZW1lbnRzIGluIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0VW5mb3JtYXR0ZWQ6ICh2YWx1ZSwgb3B0aW9ucyA9IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5zZXRVbmZvcm1hdHRlZCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgb2YgdGhlIGBnZXROdW1lcmljU3RyaW5nKClgIGZ1bmN0aW9uLCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGFueW1vcmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHVuZm9ybWF0dGVkIHZhbHVlcyAoYXMgYSBzdHJpbmcpIG9mIGVhY2ggQXV0b051bWVyaWMgZWxlbWVudCBvZiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldE51bWVyaWNTdHJpbmc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXROdW1lcmljU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZXMgKGFzIGEgc3RyaW5nKSBvZiBlYWNoIEF1dG9OdW1lcmljIGVsZW1lbnQgb2YgdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRGb3JtYXR0ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXRGb3JtYXR0ZWQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnQgdW5mb3JtYXR0ZWQgdmFsdWVzIChhcyBhIHJlYWwgSmF2YXNjcmlwdCBudW1iZXIpLCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TnVtYmVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYU5PYmplY3QuZ2V0TnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWVzIChmb2xsb3dpbmcgdGhlIGBvdXRwdXRGb3JtYXRgIHNldHRpbmcpIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0IGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TG9jYWxpemVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYU5PYmplY3QuZ2V0TG9jYWxpemVkKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yY2UgZWFjaCBlbGVtZW50IG9mIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QgdG8gcmVmb3JtYXQgaXRzIHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlZm9ybWF0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QucmVmb3JtYXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGFuZCBrZWVwIG9ubHkgdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSAoYXMgYSBudW1lcmljU3RyaW5nKSBpbiBlYWNoIGVsZW1lbnRzIG9mIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdW5mb3JtYXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC51bmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgdGhlIGZvcm1hdHRpbmcgYW5kIGtlZXAgb25seSB0aGUgbG9jYWxpemVkIHVuZm9ybWF0dGVkIHZhbHVlIGluIHRoZSBlbGVtZW50LCB3aXRoIHRoZSBvcHRpb24gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3V0cHV0Rm9ybWF0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHVuZm9ybWF0TG9jYWxpemVkOiAoZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LnVuZm9ybWF0TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIEF1dG9OdW1lcmljIHNldHRpbmdzLCBhbmQgaW1tZWRpYXRlbHkgZm9ybWF0IHRoZSBlbGVtZW50cyBhY2NvcmRpbmdseSwgZm9yIGVhY2ggZWxlbWVudHMgb2YgdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zIFRoaXMgY2FuIGJlIGVpdGhlciBvbmUgb3IgbW9yZSBvcHRpb24gb2JqZWN0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGU6ICguLi5uZXdPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QudXBkYXRlKC4uLm5ld09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gYHRydWVgIGlzICphbGwqIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzIGFyZSBwcmlzdGluZSwgaWYgdGhlaXIgcmF3IHZhbHVlIGhhc24ndCBjaGFuZ2VkLlxuICAgICAgICAgICAgICogQnkgZGVmYXVsdCwgdGhpcyByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGlzIHN0aWxsIHRoZSBzYW1lIGV2ZW4gaWYgdGhlIGZvcm1hdHRlZCBvbmUgaGFzIGNoYW5nZWQgKGR1ZSB0byBhIGNvbmZpZ3VyYXRpb24gdXBkYXRlIGZvciBpbnN0YW5jZSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja09ubHlSYXdWYWx1ZSBJZiBzZXQgdG8gYHRydWVgLCB0aGUgcHJpc3RpbmUgdmFsdWUgaXMgZG9uZSBvbiB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlLCBub3QgdGhlIGZvcm1hdHRlZCBvbmUuIElmIHNldCB0byBgZmFsc2VgLCB0aGlzIGFsc28gY2hlY2tzIHRoYXQgdGhlIGZvcm1hdHRlZCB2YWx1ZSBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1ByaXN0aW5lOiAoY2hlY2tPbmx5UmF3VmFsdWUgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByaXN0aW5lICYmICFhTk9iamVjdC5pc1ByaXN0aW5lKGNoZWNrT25seVJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmlzdGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmlzdGluZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXhlY3V0ZSB0aGUgYGNsZWFyKClgIG1ldGhvZCBvbiBlYWNoIEF1dG9OdW1lcmljIG9iamVjdCBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZUNsZWFyQWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNsZWFyOiAoZm9yY2VDbGVhckFsbCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QuY2xlYXIoZm9yY2VDbGVhckFsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4ZWN1dGUgdGhlIGByZW1vdmUoKWAgbWV0aG9kIG9uIGVhY2ggQXV0b051bWVyaWMgb2JqZWN0IGluIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4ZWN1dGUgdGhlIGB3aXBlKClgIG1ldGhvZCBvbiBlYWNoIEF1dG9OdW1lcmljIG9iamVjdCBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdpcGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC53aXBlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4ZWN1dGUgdGhlIGBudWtlKClgIG1ldGhvZCBvbiBlYWNoIEF1dG9OdW1lcmljIG9iamVjdCBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG51a2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5udWtlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIEF1dG9OdW1lcmljIG9iamVjdCAob3IgRE9NIGVsZW1lbnQpIGlzIGluIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR8QXV0b051bWVyaWN9IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFzOiBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QgaW5zdGFuY2VvZiBBdXRvTnVtZXJpYykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0Lmhhcyhkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdC5ub2RlKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuaGFzKGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYW4gZXhpc3RpbmcgQXV0b051bWVyaWMgb2JqZWN0IChvciBET00gZWxlbWVudCkgdG8gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdCwgdXNpbmcgdGhlIERPTSBlbGVtZW50IGFzIHRoZSBrZXkuXG4gICAgICAgICAgICAgKiBUaGlzIG1hbmFnZXMgdGhlIGNhc2Ugd2hlcmUgYGFkZE9iamVjdGAgaXMgdXNlZCBvbiBhbiBBdXRvTnVtZXJpYyBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBtdWx0aXBsZSBlbGVtZW50cyBpbiBpdHMgbG9jYWwgbGlzdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR8QXV0b051bWVyaWN9IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZE9iamVjdDogZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHNhbWUgZGF0YSwgd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGFzIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGxldCBkb21FbGVtZW50O1xuICAgICAgICAgICAgICAgIGxldCBvdGhlckF1dG9OdW1lcmljT2JqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCBpbnN0YW5jZW9mIEF1dG9OdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdC5ub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QgPSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QgPSBBdXRvTnVtZXJpYy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGF1dG9OdW1lcmljIG9iamVjdCBoYXMgYSBsb2NhbCBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNMb2NhbExpc3QoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVMb2NhbExpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgYXV0b051bWVyaWMgb2JqZWN0IGhhcyBhIGxvY2FsIGxpc3QuLi5cbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJBTkxvY2FsTGlzdCA9IG90aGVyQXV0b051bWVyaWNPYmplY3QuX2dldExvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlckFOTG9jYWxMaXN0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGlmIHRoZSBvdGhlciBBdXRvTnVtZXJpYyBvYmplY3QgaGFzIGFuIGVtcHR5IGxvY2FsIGxpc3QsIHRoZW4gcG9wdWxhdGUgaXRzZWxmIHRvIGl0XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBvdGhlckFOTG9jYWxMaXN0ID0gb3RoZXJBdXRvTnVtZXJpY09iamVjdC5fZ2V0TG9jYWxMaXN0KCk7IC8vIFVwZGF0ZSB0aGUgb3RoZXIgbG9jYWwgbGlzdFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtZXJnZWRMb2NhbExpc3RzO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlckFOTG9jYWxMaXN0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLklmIGl0IGRvZXMsIG1lcmdlIHRoZSBsb2NhbCBsaXN0cyB0b2dldGhlclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMb2NhbExpc3RzID0gQXV0b051bWVyaWNIZWxwZXIubWVyZ2VNYXBzKHRoaXMuX2dldExvY2FsTGlzdCgpLCBvdGhlckFOTG9jYWxMaXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5JZiBub3QsIGp1c3Qgc2V0IHRoZSBjdXJyZW50IGxvY2FsIGxpc3Qgb250byB0aGUgb3RoZXIgQXV0b051bWVyaWMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGUgQXV0b051bWVyaWMgb2JqZWN0LCBvdGhlcndpc2UgdGhlIGBfYWRkVG9Mb2NhbExpc3RgIGZ1bmN0aW9uIHdvdWxkIG5vdCBjb3JyZWN0bHkgYWRkIHRoZSBBdXRvTnVtZXJpYyBvYmplY3Qgc2luY2Ugd2Ugd291bGQgbm90IGhhdmUgYSByZWZlcmVuY2UgdG8gaXQsIGJ1dCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBvYmplY3Qgb24gd2hpY2ggaXMgY2FsbGVkIHRoaXMgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0xvY2FsTGlzdChkb21FbGVtZW50LCBvdGhlckF1dG9OdW1lcmljT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTG9jYWxMaXN0cyA9IHRoaXMuX2dldExvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVzdWx0aW5nIGxpc3QsIG9uIGFsbCB0aGUgb2JqZWN0cyBvZiB0aGF0IGxvY2FsIGxpc3QgKHNvIHRoYXQgd2UgY2FuIGluZGlmZmVyZW50bHkgdXNlIGBpbml0KClgIG9uIGFueSBvYmplY3QgYmVsb25naW5nIHRvIHRoYXQgbGlzdClcbiAgICAgICAgICAgICAgICBtZXJnZWRMb2NhbExpc3RzLmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5fc2V0TG9jYWxMaXN0KG1lcmdlZExvY2FsTGlzdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIEF1dG9OdW1lcmljIG9iamVjdCAob3IgRE9NIGVsZW1lbnQpIGZyb20gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdCwgdXNpbmcgdGhlIERPTSBlbGVtZW50IGFzIHRoZSBrZXkuXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIHJlbW92ZSB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBvYmplY3QgZnJvbSB0aGUgbG9jYWwgbGlzdCwgYSB3YXJuaW5nIGlzIHNob3duLCBidXQgdGhlIGRlbGV0aW9uIGlzIHN0aWxsIGRvbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlcyA6XG4gICAgICAgICAgICAgKiAtIElmIHRoZSBjdXJyZW50IG9iamVjdCByZW1vdmVzIGl0c2VsZiwgdGhlbiBpdCdzIHJlbW92ZWQgZnJvbSB0aGUgc2hhcmVkIGxvY2FsIGxpc3QsIHRoZW4gYSBuZXcgZW1wdHkgbG9jYWwgbGlzdCBpcyB1c2VkL2NyZWF0ZWRcbiAgICAgICAgICAgICAqIC0gSWYgYW5vdGhlciBvYmplY3QgcmVtb3ZlIHRoaXMgb2JqZWN0LCB0aGVuIGEgbG9jYWwgbGlzdCB3aXRoIG9ubHkgdGhpcyBvYmplY3QgaXMgdXNlZC9jcmVhdGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEF1dG9OdW1lcmljfSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdFxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwQ3VycmVudEFOT2JqZWN0IElmIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBmdW5jdGlvbiB3aWxsIGFsc28gcmVtb3ZlIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIG9iamVjdCBpZiBhc2tlZCwgb3RoZXJ3aXNlIGl0IHdpbGwgaWdub3JlIGl0IGFuZCBwcmludCBhIHdhcm5pbmcgbWVzc2FnZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVPYmplY3Q6IChkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCwga2VlcEN1cnJlbnRBTk9iamVjdCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgc2FtZSBkYXRhLCB3aGF0ZXZlciB0aGUgdXNlciBwYXNzZWQgYXMgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGRvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyQXV0b051bWVyaWNPYmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0IGluc3RhbmNlb2YgQXV0b051bWVyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0Lm5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJBdXRvTnVtZXJpY09iamVjdCA9IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJBdXRvTnVtZXJpY09iamVjdCA9IEF1dG9OdW1lcmljLmdldEF1dG9OdW1lcmljRWxlbWVudChkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvdGhlciBvYmplY3QgZnJvbSB0aGUgbG9jYWwgbGlzdFxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDb21wbGV0ZUxvY2FsTGlzdCA9IHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5kZWxldGUoZG9tRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIGxpc3QgZm9yIGFsbCBvYmplY3RzIGluIGl0XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbXBsZXRlTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5fc2V0TG9jYWxMaXN0KHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwQ3VycmVudEFOT2JqZWN0ICYmIGRvbUVsZW1lbnQgPT09IHRoaXMubm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgYnkgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBvYmplY3QgbG9jYWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICBvdGhlckF1dG9OdW1lcmljT2JqZWN0Ll9zZXRMb2NhbExpc3QobmV3IE1hcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBieSBhbm90aGVyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGxvY2FsIGxpc3QgZm9yIHRoZSByZW1vdmVkIG9iamVjdCwgd2l0aCBvbmx5IHRoaXMgb2JqZWN0IGluIGl0XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzaGFyZWQgbGlzdCwgZWZmZWN0aXZlbHkgZW1wdHlpbmcgaXQuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIGNhbGxpbmcgYGRldGFjaCgpYCBvbiBlYWNoIG9mIGl0cyBlbGVtZW50cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBFYWNoQU5PYmplY3RJbkl0c093bkxpc3QgSWYgc2V0IHRvIGB0cnVlYCwgdGhlbiBpbnN0ZWFkIG9mIGNvbXBsZXRlbHkgZW1wdHlpbmcgdGhlIGxvY2FsIGxpc3Qgb2YgZWFjaCBBdXRvTnVtZXJpYyBvYmplY3RzLCBlYWNoIG9uZSBvZiB0aG9zZSBrZWVwcyBpdHNlbGYgaW4gaXRzIG93biBsb2NhbCBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVtcHR5OiAoa2VlcEVhY2hBTk9iamVjdEluSXRzT3duTGlzdCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbENvbXBsZXRlTG9jYWxMaXN0ID0gdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdDtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgbGlzdCBmb3IgYWxsIG9iamVjdHMgaW4gaXRcbiAgICAgICAgICAgICAgICBpbml0aWFsQ29tcGxldGVMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZWVwRWFjaEFOT2JqZWN0SW5JdHNPd25MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5fY3JlYXRlTG9jYWxMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC5fc2V0TG9jYWxMaXN0KG5ldyBNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgQXV0b051bWVyaWMgRE9NIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpemVkIGJ5IGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50czogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFOT2JqZWN0Lm5vZGUoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gdGhlIGBNYXBgIG9iamVjdCBkaXJlY3RseVxuICAgICAgICAgICAgICogQHJldHVybnMge01hcH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TGlzdDogKCkgPT4gdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNpemU6ICgpID0+IHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3Quc2l6ZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYWxsb3cgdG8gY2hhbmdlIGVhY2ggc2V0dGluZyBvbmUgYnkgb25lXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBvcHRpb25zLCB3ZSBkZWZpbmUgaWYgd2UgbmVlZCB0byByZWZvcm1hdCB0aGUgZWxlbWVudCBjb250ZW50IChkb2VzIGNoYW5naW5nIHRoZSBvcHRpb25zIHNob3VsZCBjaGFuZ2UgdGhlIHdheSBpdHMgdmFsdWUgaXMgZGlzcGxheWVkPykuXG4gICAgICAgICAqIElmIHllcywgdGhlbiB3ZSB1c2UgdGhlIGB1cGRhdGUoKWAgZm9yIGZvcmNlIGEgcmVmb3JtYXQsIG90aGVyd2lzZSwgd2UganVzdCB1cGRhdGUgdGhlIGBzZXR0aW5nc2Agb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCBhbnkgb3B0aW9ucyBzZXQgcHJldmlvdXNseSwgYnkgb3ZlcndyaXRpbmcgdGhlbSB3aXRoIHRoZSBkZWZhdWx0IHNldHRpbmdzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXNldCAgICAgICAgICAgICAgICAgICAgICAgIDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldHRpbmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShBdXRvTnVtZXJpYy5kZWZhdWx0U2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsb3dEZWNpbWFsUGFkZGluZyAgICAgICAgICA6IGFsbG93RGVjaW1hbFBhZGRpbmcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgYWxsb3dEZWNpbWFsUGFkZGluZyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkZvY3VzICA6IGNhcmV0UG9zaXRpb25PbkZvY3VzID0+IHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID0gY2FyZXRQb3NpdGlvbk9uRm9jdXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVMb2NhbExpc3QgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbExpc3QgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0ID0gY3JlYXRlTG9jYWxMaXN0O1xuXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBsb2NhbCBsaXN0IHdoZW4gdGhpcyBpcyBzZXQgdG8gYGZhbHNlYCwgY3JlYXRlIGl0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCBhbmQgdGhlcmUgaXMgbm90IHByZS1leGlzdGluZyBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzTG9jYWxMaXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlTG9jYWxMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IGN1cnJlbmN5U3ltYm9sID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGN1cnJlbmN5U3ltYm9sIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IGRlY2ltYWxDaGFyYWN0ZXIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgZGVjaW1hbENoYXJhY3RlciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlID0gZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlICAgICAgICA6IGRlY2ltYWxQbGFjZXNPdmVycmlkZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDogZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGUgICAgICAgICA6IGRlZmF1bHRWYWx1ZU92ZXJyaWRlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGRlZmF1bHRWYWx1ZU92ZXJyaWRlIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwU3BhY2luZyAgICAgICAgICA6IGRpZ2l0YWxHcm91cFNwYWNpbmcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgZGlnaXRhbEdyb3VwU3BhY2luZyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiBkaWdpdEdyb3VwU2VwYXJhdG9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGRpZ2l0R3JvdXBTZXBhcmF0b3IgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbXB0eUlucHV0QmVoYXZpb3IgICAgICAgICAgIDogZW1wdHlJbnB1dEJlaGF2aW9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGVtcHR5SW5wdXRCZWhhdmlvciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiBmYWlsT25Vbmtub3duT3B0aW9uID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZhaWxPblVua25vd25PcHRpb24gPSBmYWlsT25Vbmtub3duT3B0aW9uOyAvL0ZJWE1FIMOgIHRlc3RlclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICA6IGZvcm1hdE9uUGFnZUxvYWQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCA9IGZvcm1hdE9uUGFnZUxvYWQ7IC8vRklYTUUgw6AgdGVzdGVyXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0NhbmNlbGxhYmxlICAgICAgICAgICAgICAgIDogaXNDYW5jZWxsYWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5pc0NhbmNlbGxhYmxlID0gaXNDYW5jZWxsYWJsZTsgLy9GSVhNRSDDoCB0ZXN0ZXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgICAgOiBsZWFkaW5nWmVybyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBsZWFkaW5nWmVybyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiBtYXhpbXVtVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgbWF4aW11bVZhbHVlIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICA6IG1pbmltdW1WYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBtaW5pbXVtVmFsdWUgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RpZnlWYWx1ZU9uV2hlZWwgICAgICAgICAgIDogbW9kaWZ5VmFsdWVPbldoZWVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vZGlmeVZhbHVlT25XaGVlbCA9IG1vZGlmeVZhbHVlT25XaGVlbDsgLy9GSVhNRSDDoCB0ZXN0ZXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgOiBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vRXZlbnRMaXN0ZW5lcnMgICAgICAgICAgICAgOiBub0V2ZW50TGlzdGVuZXJzID0+IHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgICAgICAgICBpZiAobm9FdmVudExpc3RlbmVycyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5ub0V2ZW50TGlzdGVuZXJzLm5vRXZlbnRzICYmIHRoaXMuc2V0dGluZ3Mubm9FdmVudExpc3RlbmVycyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5ub0V2ZW50TGlzdGVuZXJzLmFkZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvbmNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBub0V2ZW50TGlzdGVuZXJzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9TZXBhcmF0b3JPbkZvY3VzICAgICAgICAgICA6IG5vU2VwYXJhdG9yT25Gb2N1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBub1NlcGFyYXRvck9uRm9jdXMgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgIDogb25JbnZhbGlkUGFzdGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPSBvbkludmFsaWRQYXN0ZTsgLy9GSVhNRSDDoCB0ZXN0ZXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiBvdXRwdXRGb3JtYXQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub3V0cHV0Rm9ybWF0ID0gb3V0cHV0Rm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IG92ZXJyaWRlTWluTWF4TGltaXRzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG92ZXJyaWRlTWluTWF4TGltaXRzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZE9ubHkgICAgICAgICAgICAgICAgICAgICA6IHJlYWRPbmx5ID0+IHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVhZE9ubHkoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgICAgOiByb3VuZGluZ01ldGhvZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyByb3VuZGluZ01ldGhvZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgICAgOiBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZURlY2ltYWxQbGFjZXMgICAgICAgICAgIDogc2NhbGVEZWNpbWFsUGxhY2VzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNjYWxlRGVjaW1hbFBsYWNlcyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxlRGl2aXNvciAgICAgICAgICAgICAgICAgOiBzY2FsZURpdmlzb3IgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc2NhbGVEaXZpc29yIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGVTeW1ib2wgICAgICAgICAgICAgICAgICA6IHNjYWxlU3ltYm9sID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNjYWxlU3ltYm9sIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IHNlbGVjdE51bWJlck9ubHkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2VsZWN0TnVtYmVyT25seSA9IHNlbGVjdE51bWJlck9ubHk7IC8vRklYTUUgw6AgdGVzdGVyXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RPbkZvY3VzICAgICAgICAgICAgICAgIDogc2VsZWN0T25Gb2N1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zZWxlY3RPbkZvY3VzID0gc2VsZWN0T25Gb2N1czsgLy9GSVhNRSDDoCB0ZXN0ZXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZVNwYWNlcyAgICAgICAgICAgICAgOiBzZXJpYWxpemVTcGFjZXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2VyaWFsaXplU3BhY2VzID0gc2VyaWFsaXplU3BhY2VzOyAvL0ZJWE1FIMOgIHRlc3RlclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1Bvc2l0aXZlU2lnbiAgICAgICAgICAgICA6IHNob3dQb3NpdGl2ZVNpZ24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc2hvd1Bvc2l0aXZlU2lnbiB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiBzaG93V2FybmluZ3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2hvd1dhcm5pbmdzID0gc2hvd1dhcm5pbmdzOyAvL0ZJWE1FIMOgIHRlc3RlclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVSdWxlcyAgICAgICAgICAgICAgICAgICA6IHN0eWxlUnVsZXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3R5bGVSdWxlcyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiBzdWZmaXhUZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHN1ZmZpeFRleHQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmZvcm1hdE9uSG92ZXIgICAgICAgICAgICAgIDogdW5mb3JtYXRPbkhvdmVyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25Ib3ZlciA9IHVuZm9ybWF0T25Ib3ZlcjsgLy9GSVhNRSDDoCB0ZXN0ZXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB1bmZvcm1hdE9uU3VibWl0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQgPSB1bmZvcm1hdE9uU3VibWl0OyAvL0ZJWE1FIMOgIHRlc3RlclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2hlZWxTdGVwICAgICAgICAgICAgICAgICAgICA6IHdoZWVsU3RlcCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy53aGVlbFN0ZXAgPSB3aGVlbFN0ZXA7IC8vRklYTUUgw6AgdGVzdGVyXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhdXRvTnVtZXJpYyB2ZXJzaW9uIG51bWJlciAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICc0LjAuMC1iZXRhLjE2JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBwYXJhbWV0ZXJzIGdpdmVuIHRvIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QsIGFuZCBvdXRwdXQgdGhlIHRocmVlIHZhcmlhYmxlcyB0aGF0IGFyZSBuZWVkZWQgdG8gZmluaXNoIGluaXRpYWxpemluZyBpdCA6XG4gICAgICogLSBkb21FbGVtZW50IDogVGhlIHRhcmdldCBET00gZWxlbWVudFxuICAgICAqIC0gaW5pdGlhbFZhbHVlIDogVGhlIGluaXRpYWwgdmFsdWUsIG9yIGBudWxsYCBpZiBub25lIGlzIGdpdmVuXG4gICAgICogLSB1c2VyT3B0aW9ucyA6IFRoZSBvcHRpb24gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfSBhcmcxXG4gICAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl8bnVtYmVyfHN0cmluZ3xudWxsfSBhcmcyXG4gICAgICogQHBhcmFtIHtvYmplY3R8QXJyYXl8bnVtYmVyfHN0cmluZ3xudWxsfSBhcmczXG4gICAgICogQHJldHVybnMge3tkb21FbGVtZW50OiAqLCBpbml0aWFsVmFsdWU6ICosIHVzZXJPcHRpb25zOiAqfX1cbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3NldEFyZ3VtZW50c1ZhbHVlcyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIC8vIEJhc2ljIGNoZWNrIG9uIHRoZSBhcmd1bWVudCBjb3VudFxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGFyZzEpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKCdBdCBsZWFzdCBvbmUgdmFsaWQgcGFyYW1ldGVyIGlzIG5lZWRlZCBpbiBvcmRlciB0byBpbml0aWFsaXplIGFuIEF1dG9OdW1lcmljIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgYXJndW1lbnRzIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgQXV0b051bWVyaWMgb2JqZWN0IHdpdGggdGhlIHJpZ2h0IHZhbHVlc1xuICAgICAgICAvLyBUZXN0IHRoZSBhcmd1bWVudCB0eXBlc1xuICAgICAgICBjb25zdCBpc0FyZzFFbGVtZW50ID0gQXV0b051bWVyaWNIZWxwZXIuaXNFbGVtZW50KGFyZzEpO1xuICAgICAgICBjb25zdCBpc0FyZzFTdHJpbmcgPSBBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhhcmcxKTtcblxuICAgICAgICBjb25zdCBpc0FyZzJPYmplY3QgPSBBdXRvTnVtZXJpY0hlbHBlci5pc09iamVjdChhcmcyKTtcbiAgICAgICAgY29uc3QgaXNBcmcyTnVtYmVyID0gQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXJPckFyYWJpYyhhcmcyKSB8fCBhcmcyID09PSAnJztcbiAgICAgICAgY29uc3QgaXNBcmcyTnVsbCA9IEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChhcmcyKTtcbiAgICAgICAgY29uc3QgaXNBcmcyRW1wdHlTdHJpbmcgPSBBdXRvTnVtZXJpY0hlbHBlci5pc0VtcHR5U3RyaW5nKGFyZzIpO1xuXG4gICAgICAgIGNvbnN0IGlzQXJnM09iamVjdCA9IEF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KGFyZzMpO1xuICAgICAgICBjb25zdCBpc0FyZzNOdWxsID0gQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGFyZzMpO1xuXG4gICAgICAgIC8vIEdpdmVuIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCwgc29ydCB0aGUgZGF0YSBhbmQgcmV0dXJuIGEgc3RhYmxlIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgbGV0IGRvbUVsZW1lbnQ7XG4gICAgICAgIGxldCB1c2VyT3B0aW9ucztcbiAgICAgICAgbGV0IGluaXRpYWxWYWx1ZTtcblxuICAgICAgICBpZiAoaXNBcmcxRWxlbWVudCAmJiBpc0FyZzJOdWxsICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50KTsgLy8gV2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBkb21FbGVtZW50ID0gYXJnMTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxRWxlbWVudCAmJiBpc0FyZzJOdW1iZXIgJiYgaXNBcmczTnVsbCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIDEyMzQ1Ljc4OSk7IC8vIFdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgYW5kIGFuIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAnMTIzNDUuNzg5Jyk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gYXJnMTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZzI7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxRWxlbWVudCAmJiBpc0FyZzJPYmplY3QgJiYgaXNBcmczTnVsbCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIHsgb3B0aW9ucyB9KTsgLy8gV2l0aCBvbmUgb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMUVsZW1lbnQgJiYgKGlzQXJnMk51bGwgfHwgaXNBcmcyRW1wdHlTdHJpbmcpICYmIGlzQXJnM09iamVjdCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIG51bGwsIHsgb3B0aW9ucyB9KTsgLy8gV2l0aCBvbmUgb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmczO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJOdWxsICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJPYmplY3QgJiYgaXNBcmczTnVsbCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiAoaXNBcmcyTnVsbCB8fCBpc0FyZzJFbXB0eVN0cmluZykgJiYgaXNBcmczT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCBudWxsLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcmcxKTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IGFyZzM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxU3RyaW5nICYmIGlzQXJnMk51bWJlciAmJiBpc0FyZzNOdWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAxMjM0NS43ODkpO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJzEyMzQ1Ljc4OScpO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJycpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBhcmcyO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJOdW1iZXIgJiYgaXNBcmczT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsICcxMjM0NS43ODknLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAnJywgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBhcmcyO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmczO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMUVsZW1lbnQgJiYgaXNBcmcyTnVtYmVyICYmIGlzQXJnM09iamVjdCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIDEyMzQ1Ljc4OSwgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsICcxMjM0NS43ODknLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJycsIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBhcmcxO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gYXJnMjtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zID0gYXJnMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwYXJhbWV0ZXJzIGdpdmVuIHRvIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgYXJlIG5vdCB2YWxpZCwgJyR7YXJnMX0nLCAnJHthcmcyfScgYW5kICcke2FyZzN9JyBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzZWxlY3RvciAnJHthcmcxfScgZGlkIG5vdCBzZWxlY3QgYW55IHZhbGlkIERPTSBlbGVtZW50LiBQbGVhc2UgY2hlY2sgb24gd2hpY2ggZWxlbWVudCB5b3UgY2FsbGVkIEF1dG9OdW1lcmljLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZG9tRWxlbWVudCwgaW5pdGlhbFZhbHVlLCB1c2VyT3B0aW9ucyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGluaXRpYWwgZWxlbWVudCB2YWx1ZXMgZm9yIGxhdGVyIHVzZSBpbiB0aGUgcHJpc3RpbmUgdGVzdC5cbiAgICAgKiBUaG9zZSB2YWx1ZXMgYXJlIDpcbiAgICAgKiAtIHRoZSBodG1sIGF0dHJpYnV0ZSAoaWUuIDxpbnB1dCB2YWx1ZT0nNDInPiksIGFuZFxuICAgICAqIC0gdGhlIHNjcmlwdCBgdmFsdWVgIChpZS4gYGxldCBkb21FbGVtZW50LnZhbHVlYClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxudW1iZXJ8c3RyaW5nfSBpbml0aWFsVmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlSW5pdGlhbFZhbHVlcyhpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgdmVyeSBmaXJzdCBpbml0aWFsIHZhbHVlcyAoaW4gdGhlIGh0bWwgYXR0cmlidXRlIGFuZCBzZXQgYnkgdGhlIHNjcmlwdCkuIFRoaXMgaXMgbmVlZGVkIHRvIGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHByaXN0aW5lLlxuICAgICAgICAvLyBTYXZlIHRoZSBodG1sIGF0dHJpYnV0ZSAndmFsdWUnXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlSHRtbEF0dHJpYnV0ZSA9IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5pbml0aWFsVmFsdWVIdG1sQXR0cmlidXRlKSkge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGVtcHR5IHZhbHVlIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIGBudWxsYCwgc2luY2UgaWYgdGhlIGluaXRpYWwgdmFsdWUgaXMgbnVsbCwgdGhlIGVtcHR5IHN0cmluZyBpcyB1c2VkXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZUh0bWxBdHRyaWJ1dGUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlICdzY3JpcHQnIHZhbHVlXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHRoaXMuaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgICAgLy8gU2FtZSBhcyBhYm92ZVxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHJlZmVyZW5jZXMgdG8gdGhlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zLCBzbyB3ZSBjYW4gdGhlbiBjbGVhbmx5IHJlbW92ZXMgdGhvc2UgbGlzdGVuZXJzIGlmIG5lZWRlZFxuICAgICAgICAvLyBUaGF0IHdvdWxkIG5vdCBiZSBwb3NzaWJsZSBpZiB3ZSB1c2VkIGNsb3N1cmVzIGRpcmVjdGx5IGluIHRoZSBldmVudCBoYW5kbGVyIGRlY2xhcmF0aW9uc1xuICAgICAgICB0aGlzLl9vbkZvY3VzSW5GdW5jID0gZSA9PiB7IHRoaXMuX29uRm9jdXNJbihlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMgPSBlID0+IHsgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlcihlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Gb2N1c0Z1bmMgPSAoKSA9PiB7IHRoaXMuX29uRm9jdXMoKTsgfTtcbiAgICAgICAgdGhpcy5fb25LZXlkb3duRnVuYyA9IGUgPT4geyB0aGlzLl9vbktleWRvd24oZSk7IH07XG4gICAgICAgIHRoaXMuX29uS2V5cHJlc3NGdW5jID0gZSA9PiB7IHRoaXMuX29uS2V5cHJlc3MoZSk7IH07XG4gICAgICAgIHRoaXMuX29uSW5wdXRGdW5jID0gZSA9PiB7IHRoaXMuX29uSW5wdXQoZSk7IH07XG4gICAgICAgIHRoaXMuX29uS2V5dXBGdW5jID0gZSA9PiB7IHRoaXMuX29uS2V5dXAoZSk7IH07XG4gICAgICAgIHRoaXMuX29uQmx1ckZ1bmMgPSBlID0+IHsgdGhpcy5fb25CbHVyKGUpOyB9O1xuICAgICAgICB0aGlzLl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZUZ1bmMgPSBlID0+IHsgdGhpcy5fb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoZSk7IH07XG4gICAgICAgIHRoaXMuX29uUGFzdGVGdW5jID0gZSA9PiB7IHRoaXMuX29uUGFzdGUoZSk7IH07XG4gICAgICAgIHRoaXMuX29uV2hlZWxGdW5jID0gZSA9PiB7IHRoaXMuX29uV2hlZWwoZSk7IH07XG4gICAgICAgIHRoaXMuX29uRm9ybVN1Ym1pdEZ1bmMgPSBlID0+IHsgdGhpcy5fb25Gb3JtU3VibWl0KGUpOyB9O1xuICAgICAgICB0aGlzLl9vbktleWRvd25HbG9iYWxGdW5jID0gZSA9PiB7IHRoaXMuX29uS2V5ZG93bkdsb2JhbChlKTsgfTtcbiAgICAgICAgdGhpcy5fb25LZXl1cEdsb2JhbEZ1bmMgPSBlID0+IHsgdGhpcy5fb25LZXl1cEdsb2JhbChlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Ecm9wRnVuYyA9IGUgPT4geyB0aGlzLl9vbkRyb3AoZSk7IH07XG5cbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9vbkZvY3VzSW5GdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNJbkFuZE1vdXNlRW50ZXJGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25GdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX29uS2V5cHJlc3NGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uSW5wdXRGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCB0aGlzLl9vblBhc3RlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9vbldoZWVsRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMuX29uRHJvcEZ1bmMsIGZhbHNlKTtcblxuICAgICAgICBjb25zdCBwYXJlbnRGb3JtID0gdGhpcy5mb3JtKCk7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHBhcmVudEZvcm0pKSB7XG4gICAgICAgICAgICBwYXJlbnRGb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdC5hdXRvTnVtZXJpYycsIHRoaXMuX29uRm9ybVN1Ym1pdEZ1bmMsIGZhbHNlKTsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBvbmUgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUga2V5dXAgZXZlbnQgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgd2hpY2ggd2lsbCBiZSBzaGFyZWQgYnkgYWxsIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50c1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljLl9kb2VzR2xvYmFsTGlzdEV4aXN0cygpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duR2xvYmFsRnVuYywgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbktleXVwR2xvYmFsRnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aGUgYXV0b051bWVyaWMtcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBET00gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX29uRm9jdXNJbkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9vbkZvY3VzSW5BbmRNb3VzZUVudGVyRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5fb25LZXlwcmVzc0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25JbnB1dEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25LZXl1cEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkJsdXJGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuX29uUGFzdGVGdW5jLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX29uV2hlZWxGdW5jLCBmYWxzZSk7XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bkdsb2JhbEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbktleXVwR2xvYmFsRnVuYywgZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudEZvcm0gPSB0aGlzLmZvcm0oKTtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwocGFyZW50Rm9ybSkpIHtcbiAgICAgICAgICAgIHBhcmVudEZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VibWl0LmF1dG9OdW1lcmljJywgdGhpcy5fb25Gb3JtU3VibWl0RnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBlbGVtZW50IGF0dHJpYnV0ZSAncmVhZG9ubHknIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFJlYWRPbmx5KCkge1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0RWxlbWVudCAmJiB0aGlzLnNldHRpbmdzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY3VycmVudCByYXcgdmFsdWUgaW50byB0aGUgaGlzdG9yeSB0YWJsZSwgYWxvbmcgd2l0aCB0aGUgc2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIGRvbmUgc29tZSB1bmRvcyBhbmQgdHJpZXMgdG8gZW50ZXI6XG4gICAgICogLSBhIG5ldyBhbmQgZGlmZmVyZW50IG51bWJlciB0aGFuIHRoZSAnbmV4dCcgc3RhdGUsIHRoaXMgZHJvcHMgdGhlIHJlc3Qgb2YgdGhlIGhpc3RvcnkgdGFibGVcbiAgICAgKiAtIHRoZSB2ZXJ5IHNhbWUgbnVtYmVyIHRoYXQgcmVzdWx0IGluIHRoZSBzYW1lIHJhd1ZhbHVlIHRoYW4gdGhlICduZXh0JyBzdGF0ZSwgd2Ugb25seSBtb3ZlIHRoZSBoaXN0b3J5IHRhYmxlIHBvaW50ZXIgdG8gdGhlIG5leHQgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpc3RvcnlUYWJsZUFkZCgpIHtcbiAgICAgICAgLy9UT0RPIEFkZCBhIGB0aGlzLnNldHRpbmdzLnNhdmVTZWxlY3Rpb25zSW50b0hpc3RvcnlgIG9wdGlvbiB0byBwcmV2ZW50IHNhdmluZyB0aGUgc2VsZWN0aW9ucyAoaW4gb3JkZXIgdG8gZ2FpbiBwZXJmb3JtYW5jZSlcbiAgICAgICAgY29uc3QgaXNFbXB0eUhpc3RvcnlUYWJsZSA9IHRoaXMuaGlzdG9yeVRhYmxlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgLy8gT25seSBhZGQgYSBuZXcgdmFsdWUgaWYgaXQncyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJldmlvdXMgb25lICh0byBwcmV2ZW50IGluZmluaXRlbHkgYWRkaW5nIHZhbHVlcyBvbiBtb3VzZW92ZXIgZm9yIGluc3RhbmNlKVxuICAgICAgICBpZiAoaXNFbXB0eUhpc3RvcnlUYWJsZSB8fCB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlICE9PSB0aGlzLl9oaXN0b3J5VGFibGVDdXJyZW50VmFsdWVVc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFRyaW0gdGhlIGhpc3RvcnkgdGFibGUgaWYgdGhlIHVzZXIgY2hhbmdlZCB0aGUgdmFsdWUgb2YgYW4gaW50ZXJtZWRpYXJ5IHN0YXRlXG4gICAgICAgICAgICBsZXQgYWRkTmV3SGlzdG9yeVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eUhpc3RvcnlUYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWUgdW5kbyBoYXMgYmVlbiBkb25lIGFuZCB0aGUgdXNlciB0eXBlIHRoZSBleGFjdCBzYW1lIGRhdGEgdGhhbiB0aGUgbmV4dCBlbnRyeSBhZnRlciB0aGUgY3VycmVudCBoaXN0b3J5IHBvaW50ZXIsIGRvIG5vIGRyb3AgdGhlIHJlc3Qgb2YgdGhlICdyZWRvJyBsaXN0LCBhbmQganVzdCBhZHZhbmNlIHRoZSBoaXN0b3J5VGFibGVJbmRleFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRIaXN0b3J5U3RhdGVJbmRleCA9IHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SGlzdG9yeVN0YXRlSW5kZXggPCB0aGlzLmhpc3RvcnlUYWJsZS5sZW5ndGggJiYgdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSA9PT0gdGhpcy5oaXN0b3J5VGFibGVbbmV4dEhpc3RvcnlTdGF0ZUluZGV4XS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlucHV0IHJlc3VsdCBpbiB0aGUgc2FtZSBzdGF0ZSB0aGFuIHRoZSBuZXh0IG9uZSwgZG8gbm90IHJlbW92ZSB0aGUgbmV4dCBoaXN0b3J5IHN0YXRlcyBub3IgYWRkIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBhZGROZXdIaXN0b3J5U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBhZnRlciB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5hcnJheVRyaW0odGhpcy5oaXN0b3J5VGFibGUsIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGlzdG9yeSBwb2ludGVyXG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZUluZGV4Kys7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IGhpc3Rvcnkgc3RhdGUsIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKGFkZE5ld0hpc3RvcnlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHNlbGVjdGlvbiBpbmZvXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb24uZW5kO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgdGhlIG5ldyByYXcgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgcmF3VmFsdWUgYW5kIHNlbGVjdGlvbiBzdGFydC9lbmRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2V0dGluZ3MucmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWxlY3Rpb24gZm9yIHRoaXMgZWxlbWVudCBpcyB0ZW1wb3JhcnksIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgbmV4dCBoaXN0b3J5IHN0YXRlIHdpbGwgYmUgcmVjb3JkZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoYXQgd2F5LCB3ZSBhcmUgYWx3YXlzIHN1cmUgd2Ugc2F2ZSB0aGUgbGFzdCBjYXJldCBvciBzZWxlY3Rpb24gcG9zaXRpb25zIGp1c3QgYmVmb3JlIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLiBPdGhlcndpc2Ugd2Ugd291bGQgb25seSBzYXZlIHRob3NlIHBvc2l0aW9ucyB3aGVuIHRoZSB2YWx1ZSBpcyBmaXJzdCBjaGFuZ2VkLCBhbmQgd291bGQgbm90IHRha2UgaW50byBhY2NvdW50IHRoYXQgdGhlIHVzZXIgY291bGQgbW92ZSB0aGUgY2FyZXQgYXJvdW5kIGFmdGVyd2FyZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlLCB0aGlzIGlzIG5lZWRlZCBpZiB0aGUgdXNlciBjaGFuZ2UgdGhlIGVsZW1lbnQgdmFsdWUsIGFuZCBpbW1lZGlhdGVseSB1bmRvIGl0IDsgaWYgaGUgdGhlbiBkb2VzIGEgcmVkbywgaGUnbGwgc2VlIHRoZSB2YWx1ZSBhbmQgdGhlIHJpZ2h0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBzdW0gdXA7IFRoZSBzZWxlY3Rpb24gcG9zaXRpb24gYXJlIG5vdCBhbHdheXMgKzEgY2hhcmFjdGVyLCBzaW5jZSBpdCBjb3VsZCBhbHNvIGJlICcyJyBpZiBhIGdyb3VwIHNlcGFyYXRvciBpcyBhZGRlZCB3aGVuIGVudGVyaW5nIG9uZSBjaGFyYWN0ZXIuIFRoYXQncyB3aHkgdGhlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZSBjYXJldC9zZWxlY3Rpb24gcG9zaXRpb24gaXMgdXBkYXRlZCBvbiBlYWNoIGBrZXl1cGAgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNlbGVjdGlvblN0YXJ0ICsgMSwgLy8gSGVyZSB3ZSBhZGQgb25lIHNpbmNlIHRoZSB1c2VyIGFkZGVkIG9uZSBjaGFyYWN0ZXIgdG9vXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgOiB0aGlzLnNlbGVjdGlvbkVuZCArIDEsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvbiBpbiB0aGUgcHJldmlvdXMgZW50cnksIGluIG9yZGVyIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgY2FyZXQvc2VsZWN0aW9uIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlUYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlW3RoaXMuaGlzdG9yeVRhYmxlSW5kZXggLSAxXS5zdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlW3RoaXMuaGlzdG9yeVRhYmxlSW5kZXggLSAxXS5lbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpbWl0IHRoZSBoaXN0b3J5IHRhYmxlIHNpemUgYWNjb3JkaW5nIHRvIHRoZSBgaGlzdG9yeVNpemVgIG9wdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVRhYmxlLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MuaGlzdG9yeVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5VGFibGVGb3JnZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVnIGZ1bmN0aW9uIGZvciB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLypcbiAgICBfZGVidWdIaXN0b3J5VGFibGUoKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IG1hcms7XG4gICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlLmZvckVhY2goaGlzdG9yeSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaXN0b3J5VGFibGVJbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICAgIG1hcmsgPSAnPiAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHttYXJrfSR7aSsrfTogJHtoaXN0b3J5LnZhbHVlfSAke2hpc3Rvcnkuc3RhcnR9fCR7aGlzdG9yeS5lbmR9IFtvbkdvaW5nUmVkbzogJHt0aGlzLm9uR29pbmdSZWRvfV1gKTsgLy9ERUJVR1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqICdVbmRvJyBvciAnUmVkbycgdGhlIGxhc3QvbmV4dCB1c2VyIGVudHJ5IGluIHRoZSBoaXN0b3J5IHRhYmxlLlxuICAgICAqIFRoaXMgZG9lcyBub3QgbW9kaWZ5IHRoZSBoaXN0b3J5IHRhYmxlLCBvbmx5IHRoZSBwb2ludGVyIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1bmRvIElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhpcyBmdW5jdGlvbiBkb2VzIGFuICdVbmRvJywgb3RoZXJ3aXNlIGl0IGRvZXMgYSAnUmVkbydcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaXN0b3J5VGFibGVVbmRvT3JSZWRvKHVuZG8gPSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGVjaztcbiAgICAgICAgaWYgKHVuZG8pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgJ3VuZG8nIGlmIHRoZXJlIGFyZSBzb21lIGluZm8gdG8gdW5kb1xuICAgICAgICAgICAgY2hlY2sgPSB0aGlzLmhpc3RvcnlUYWJsZUluZGV4ID4gMDtcbiAgICAgICAgICAgIGlmIChjaGVjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgJ3JlZG8nIGlmIHRoZXJlIGFyZSBzb21lIGluZm8gdG8gcmVkbyBhdCB0aGUgZW5kIG9mIHRoZSBoaXN0b3J5IHRhYmxlXG4gICAgICAgICAgICBjaGVjayA9IHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggKyAxIDwgdGhpcy5oaXN0b3J5VGFibGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIGJhY2tcbiAgICAgICAgICAgIGNvbnN0IHVuZG9JbmZvID0gdGhpcy5oaXN0b3J5VGFibGVbdGhpcy5oaXN0b3J5VGFibGVJbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldCh1bmRvSW5mby52YWx1ZSwgbnVsbCwgZmFsc2UpOyAvLyBuZXh0IG9yIHByZXZpb3VzIHJhdyB2YWx1ZVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHNlbGVjdGlvbiBiYWNrXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCwgdW5kb0luZm8uc3RhcnQsIHVuZG9JbmZvLmVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAnVW5kbycgdGhlIGxhc3QgdXNlciBlbnRyeSBieSBnb2luZyBiYWNrIG9uZSBlbnRyeSBpbiB0aGUgaGlzdG9yeSB0YWJsZS5cbiAgICAgKiBUaGlzIGtlZXBzIHRoZSBmb2xsb3dpbmcgZW50cmllcyBpbiBvcmRlciB0byBhbGxvdyBmb3IgYSAncmVkbycuXG4gICAgICogVGhpcyBkb2VzIG5vdCBtb2RpZnkgdGhlIGhpc3RvcnkgdGFibGUsIG9ubHkgdGhlIHBvaW50ZXIgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlzdG9yeVRhYmxlVW5kbygpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVRhYmxlVW5kb09yUmVkbyh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAnUmVkbycgdGhlIG5leHQgdXNlciBlbnRyeSBpbiB0aGUgaGlzdG9yeSB0YWJsZS5cbiAgICAgKiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgaGlzdG9yeSB0YWJsZSwgb25seSB0aGUgcG9pbnRlciB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaXN0b3J5VGFibGVSZWRvKCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5VGFibGVVbmRvT3JSZWRvKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgaGlzdG9yeSB0YWJsZSB0byBpdHMgaW5pdGlhbCBzdGF0ZSwgYW5kIHNlbGVjdCB0aGUgdmFsdWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvKlxuICAgIHJlc2V0SGlzdG9yeVRhYmxlKCkgeyAvL0ZJWE1FIFRlc3QgdGhpc1xuICAgICAgICB0aGlzLnNldCh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlID0gW3tcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJhd1ZhbHVlIGFuZCBzZWxlY3Rpb24gc3RhcnQvZW5kXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSxcbiAgICAgICAgICAgIHN0YXJ0OiBzZWxlY3Rpb24uc3RhcnQsXG4gICAgICAgICAgICBlbmQgIDogc2VsZWN0aW9uLmVuZCxcbiAgICAgICAgfV07XG4gICAgfVxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSBoaXN0b3J5IHRhYmxlIGZvcmdldCBpdHMgZmlyc3QgTiBlbGVtZW50cywgc2hpZnRpbmcgaXRzIGluZGV4ZXMgaW4gdGhlIHByb2Nlc3MuXG4gICAgICogYE5gIGJlaW5nIGdpdmVuIGFzIHRoZSBgbnVtYmVyT2ZFbnRyaWVzVG9Gb3JnZXRgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJPZkVudHJpZXNUb0ZvcmdldFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8QXJyYXk8b2JqZWN0Pn0gVGhlIGRpc2NhcmRlZCBvYmplY3RzLCBpbiBhbiBBcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaXN0b3J5VGFibGVGb3JnZXQobnVtYmVyT2ZFbnRyaWVzVG9Gb3JnZXQgPSAxKSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ZWRBd2F5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZFbnRyaWVzVG9Gb3JnZXQ7IGkrKykge1xuICAgICAgICAgICAgc2hpZnRlZEF3YXkucHVzaCh0aGlzLmhpc3RvcnlUYWJsZS5zaGlmdCgpKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGlzdG9yeSB0YWJsZSBpbmRleCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtb3JlIHRpbWVzIHRoYW4gdGhlcmUgaXMgc3RhdGVzIGluIHRoZSBoaXN0b3J5IHRhYmxlXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hpZnRlZEF3YXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hpZnRlZEF3YXlbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hpZnRlZEF3YXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50bHkgdXNlZCB2YWx1ZSBmcm9tIHRoZSBoaXN0b3J5IHRhYmxlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlzdG9yeVRhYmxlQ3VycmVudFZhbHVlVXNlZCgpIHtcbiAgICAgICAgbGV0IGluZGV4VG9Vc2UgPSB0aGlzLmhpc3RvcnlUYWJsZUluZGV4O1xuICAgICAgICBpZiAoaW5kZXhUb1VzZSA8IDApIHtcbiAgICAgICAgICAgIGluZGV4VG9Vc2UgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh0aGlzLmhpc3RvcnlUYWJsZVtpbmRleFRvVXNlXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5oaXN0b3J5VGFibGVbaW5kZXhUb1VzZV0udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBgc3R5bGVSdWxlc2Agb3B0aW9uIGFuZCBydW4gdGhlIHRlc3QgZm9yIGVhY2ggZ2l2ZW4gcnVsZXMsIGVpdGhlciBwcmUtZGVmaW5lZCBvbmVzIGxpa2UgYHBvc2l0aXZlYCwgYG5lZ2F0aXZlYCBhbmQgYHJhbmdlc2AsIG9yIHVzZXIgZGVmaW5lZCBjYWxsYmFja3Mgd2l0aGluIHRoZSBgdXNlckRlZmluZWRgIGF0dHJpYnV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYXJzZVN0eWxlUnVsZXMoKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzKSB8fCB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3Bvc2l0aXZlJyBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLnBvc2l0aXZlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmF3VmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENTU0NsYXNzKHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy5wb3NpdGl2ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNTU0NsYXNzKHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy5wb3NpdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnbmVnYXRpdmUnIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMubmVnYXRpdmUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDU1NDbGFzcyh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMubmVnYXRpdmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDU1NDbGFzcyh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMubmVnYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3JhbmdlcycgYXR0cmlidXRlXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy5yYW5nZXMpICYmIHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy5yYW5nZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlID49IHJhbmdlLm1pbiAmJiB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlIDwgcmFuZ2UubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENTU0NsYXNzKHJhbmdlLmNsYXNzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDU1NDbGFzcyhyYW5nZS5jbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAndXNlckRlZmluZWQnIGF0dHJpYnV0ZVxuICAgICAgICAvL1RPRE8gQWxzbyBwYXNzIHRoZSBvbGQgcmF3IHZhbHVlIGFzIGEgcGFyYW1ldGVyLCBhbmQgbm90IG9ubHkgdGhlIG5ldyByYXcgdmFsdWVcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLnVzZXJEZWZpbmVkKSAmJiB0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMudXNlckRlZmluZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMudXNlckRlZmluZWQuZm9yRWFjaCh1c2VyT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbih1c2VyT2JqZWN0LmNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IGZvciB0aGUgdHlwZSBvZiB0aGUgYGNsYXNzZXNgIGF0dHJpYnV0ZSwgd2hpY2ggY2hhbmdlcyB0aGUgZnVuY3Rpb24gYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKHVzZXJPYmplY3QuY2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmICdjbGFzc2VzJyBpcyBhIHN0cmluZywgc2V0IGl0IGlmIGB0cnVlYCwgcmVtb3ZlIGl0IGlmIGBmYWxzZWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT2JqZWN0LmNhbGxiYWNrKHRoaXMuc2V0dGluZ3MucmF3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0FycmF5KHVzZXJPYmplY3QuY2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT2JqZWN0LmNsYXNzZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ2NsYXNzZXMnIGlzIGFuIGFycmF5IHdpdGggb25seSAyIGVsZW1lbnRzLCBzZXQgdGhlIGZpcnN0IGNsYXNzIGlmIGB0cnVlYCwgdGhlIHNlY29uZCBpZiBgZmFsc2VgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPYmplY3QuY2FsbGJhY2sodGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDU1NDbGFzcyh1c2VyT2JqZWN0LmNsYXNzZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDU1NDbGFzcyh1c2VyT2JqZWN0LmNsYXNzZXNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlck9iamVjdC5jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmV0dXJucyBhbiBhcnJheSBvZiBpbmRleGVzIHRvIHVzZSBvbiB0aGUgYGNsYXNzZXNgIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tSZXN1bHQgPSB1c2VyT2JqZWN0LmNhbGxiYWNrKHRoaXMuc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0FycmF5KGNhbGxiYWNrUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBtdWx0aXBsZSBpbmRleGVzIGFyZSByZXR1cm5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT2JqZWN0LmNsYXNzZXMuZm9yRWFjaCgodXNlckNsYXNzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShpbmRleCwgY2FsbGJhY2tSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModXNlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0ludChjYWxsYmFja1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb25seSBvbmUgaW5kZXggaXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9iamVjdC5jbGFzc2VzLmZvckVhY2goKHVzZXJDbGFzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gY2FsbGJhY2tSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDU1NDbGFzcyh1c2VyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDU1NDbGFzcyh1c2VyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChjYWxsYmFja1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT2JqZWN0LmNsYXNzZXMuZm9yRWFjaCh1c2VyQ2xhc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGNhbGxiYWNrIHJlc3VsdCBpcyBub3QgYW4gYXJyYXkgbm9yIGEgdmFsaWQgYXJyYXkgaW5kZXgsICR7dHlwZW9mIGNhbGxiYWNrUmVzdWx0fSBnaXZlbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1RoZSBjbGFzc2VzIGF0dHJpYnV0ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBgc3R5bGVSdWxlc2Agb3B0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT2JqZWN0LmNsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiAnY2xhc3NlcycgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGVuIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCB0aGUgQXV0b051bWVyaWMgb2JqZWN0IHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9iamVjdC5jYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1RoZSBjYWxsYmFjay9jbGFzc2VzIHN0cnVjdHVyZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBgc3R5bGVSdWxlc2Agb3B0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlIGdpdmVuIFxcYHN0eWxlUnVsZXNcXGAgY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24sICR7dHlwZW9mIGNhbGxiYWNrfSBnaXZlbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZ2l2ZW4gQ1NTIGNsYXNzIHRvIHRoZSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzc05hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDU1NDbGFzcyhjc3NDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIENTUyBjbGFzcyBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzc05hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDU1NDbGFzcyhjc3NDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGFyZSB0aGUgcHVibGljIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiBlYWNoIGF1dG9OdW1lcmljLW1hbmFnZWQgZWxlbWVudFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgQXV0b051bWVyaWMgc2V0dGluZ3MsIGFuZCBpbW1lZGlhdGVseSBmb3JtYXQgdGhlIGVsZW1lbnQgYWNjb3JkaW5nbHkuXG4gICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIHBhcmFtZXRlcihzKSBpcyBlaXRoZXIgb25lIG9yIG1hbnkgb2JqZWN0cyB0aGF0IGVhY2ggY29udGFpbnMgc29tZSBzZXR0aW5ncywgaWUuIDpcbiAgICAgKiB7XG4gICAgICogICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLFxuICAgICAqICAgICBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIixcbiAgICAgKiAgICAgY3VycmVuY3lTeW1ib2w6ICfigqwgJyxcbiAgICAgKiB9XG4gICAgICogSWYgbXVsdGlwbGUgb3B0aW9ucyBhcmUgcGFzc2VkLCB0aGUgbGF0dGVyIG92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgb25lcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC51cGRhdGUoeyBvcHRpb25zIH0pIC8vIFVwZGF0ZXMgdGhlIHNldHRpbmdzXG4gICAgICogQGV4YW1wbGUgYW5FbGVtZW50LnVwZGF0ZSh7IG9wdGlvbnMxIH0sIHsgb3B0aW9uczIgfSkgLy8gVXBkYXRlcyB0aGUgc2V0dGluZ3Mgd2l0aCBtdWx0aXBsZSBvcHRpb24gb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld09wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgdXBkYXRlKC4uLm5ld09wdGlvbnMpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgaW5wdXQgdmFsdWVcbiAgICAgICAgY29uc3QgbnVtZXJpY1N0cmluZyA9IHRoaXMuc2V0dGluZ3MucmF3VmFsdWU7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYSBzaW5nbGUgb3B0aW9uIG9iamVjdCB3aXRoIHRoZSBzZXR0aW5ncyBmcm9tIHRoZSBsYXR0ZXIgb3ZlcndyaXRpbmcgdGhvc2UgZnJvbSB0aGUgZm9ybWVyXG4gICAgICAgIGxldCBvcHRpb25zVG9Vc2UgPSB7fTtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShuZXdPcHRpb25zKSB8fCBuZXdPcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdPcHRpb25zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zLmZvckVhY2gob3B0aW9uT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnNUb1VzZSwgb3B0aW9uT2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3Mob3B0aW9uc1RvVXNlLCB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1VuYWJsZSB0byB1cGRhdGUgdGhlIHNldHRpbmdzLCB0aG9zZSBhcmUgaW52YWxpZC4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWUgd2l0aCB0aGUgbmV3IHNldHRpbmdzXG4gICAgICAgIC8vIE5vdGU6IHdlIGFsd2F5cyBgc2V0YCwgZXZlbiB3aGVuIGBudW1lcmljU3RyaW5nYCBpcyB0aGUgZW1wdHkgc3RyaW5nICcnLCBzaW5jZSBgZW1wdHlJbnB1dEJlaGF2aW9yYCAoc2V0IHRvIGBhbHdheXNgIG9yIGB6ZXJvYCkgY2FuIGNoYW5nZSBob3cgdGhlIGVtcHR5IGlucHV0IGlzIGZvcm1hdHRlZFxuICAgICAgICB0aGlzLnNldChudW1lcmljU3RyaW5nKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBjdXJyZW50IGF1dG9OdW1lcmljIHNldHRpbmdzIGluIGVmZmVjdC5cbiAgICAgKiBZb3UgY2FuIHRoZW4gZGlyZWN0bHkgYWNjZXNzIGVhY2ggb3B0aW9uIGJ5IHVzaW5nIGl0cyBuYW1lIDogYGFuRWxlbWVudC5nZXRTZXR0aW5ncygpLm9wdGlvbk5hbWVBdXRvQ29tcGxldGVkYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYW5FbGVtZW50LmdldFNldHRpbmdzKClcbiAgICAgKiBhbkVsZW1lbnQuZ2V0U2V0dGluZ3MoKS5kZWNpbWFsQ2hhcmFjdGVyIC8vIFJldHVybiB0aGUgZGVjaW1hbENoYXJhY3RlciBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW55IHZhbGlkIG9wdGlvbiBuYW1lIGNhbiBiZSB1c2VkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIGVsZW1lbnQgdmFsdWUsIGFuZCBmb3JtYXQgaXQgaW1tZWRpYXRlbHkuXG4gICAgICogQWRkaXRpb25hbGx5LCB0aGlzIGBzZXQoKWAgbWV0aG9kIGNhbiBhY2NlcHQgb3B0aW9ucyB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGN1cnJlbnQgQXV0b051bWVyaWMgZWxlbWVudCwgdGFraW5nIHByZWNlZGVuY2Ugb3ZlciBhbnkgcHJldmlvdXMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQuc2V0KCcxMjM0NS42NycpIC8vIEZvcm1hdHMgdGhlIHZhbHVlXG4gICAgICogQGV4YW1wbGUgYW5FbGVtZW50LnNldCgxMjM0NS42NykgLy8gRm9ybWF0cyB0aGUgdmFsdWVcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQuc2V0KDEyMzQ1LjY3LCB7IGRlY2ltYWxDaGFyYWN0ZXIgOiAnLCcgfSkgLy8gVXBkYXRlIHRoZSBzZXR0aW5ncyBhbmQgZm9ybWF0cyB0aGUgdmFsdWUgaW4gb25lIGdvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG5ld1ZhbHVlIFRoZSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNldHRpbmdzIG9iamVjdCB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgc2V0dGluZ3MuIE5vdGU6IHRoZSB1cGRhdGUgaXMgZG9uZSBvbmx5IGlmIHRoZSBgbmV3VmFsdWVgIGlzIGRlZmluZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlQ2hhbmdlVG9IaXN0b3J5IElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIGNoYW5nZSBpcyByZWNvcmRlZCBpbiB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKiBAdGhyb3dzXG4gICAgICovXG4gICAgc2V0KG5ld1ZhbHVlLCBvcHRpb25zID0gbnVsbCwgc2F2ZUNoYW5nZVRvSGlzdG9yeSA9IHRydWUpIHtcbiAgICAgICAgLy9UT0RPIEFkZCB0aGUgYHNhdmVTZXR0aW5nc2Agb3B0aW9ucy4gSWYgYHRydWVgLCB0aGVuIHdoZW4gYG9wdGlvbnNgIGlzIHBhc3NlZCwgdGhlbiBpdCBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgYHRoaXMuc2V0dGluZ3NgLiBJZiBgZmFsc2VgIHRoZSBgb3B0aW9uc2AgYXJlIG9ubHkgdXNlZCBvbmNlIGFuZCBgdGhpcy5zZXR0aW5nc2AgaXMgbm90IG1vZGlmaWVkXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG9wdGlvbnMgdXBkYXRlIGlzIGRvbmUgb25seSBpZiB0aGUgYG5ld1ZhbHVlYCBpcyBub3QgbnVsbFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3Mob3B0aW9ucywgdHJ1ZSk7IC8vIFdlIGRvIG5vdCBjYWxsIGB1cGRhdGVgIGhlcmUgc2luY2UgdGhpcyB3b3VsZCBjYWxsIGBzZXRgIHRvb1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fdG9OdW1lcmljVmFsdWUobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBpZiAoaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoJycsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiB0aGlzLnNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybykge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgdmFsdWUgemVybyBpbnNpZGUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IHRoaXMuY29uc3RydWN0b3IuX2NoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdGVzdCBpcyBuZWVkZWQgYnkgdGhlIHNob3dQb3NpdGl2ZVNpZ24gb3B0aW9uXG4gICAgICAgICAgICBjb25zdCBpc1plcm8gPSBBdXRvTnVtZXJpY0hlbHBlci5pc1plcm9Pckhhc05vVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJvdW5kaW5nIGRvZXMgbm90IGhhcHBlbiB0d2ljZVxuICAgICAgICAgICAgICAgIGxldCBoYXNCZWVuUm91bmRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gUm91bmRzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wRGVjaW1hbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBEZWNpbWFsID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fcm91bmRWYWx1ZSh2YWx1ZSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0JlZW5Sb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0ZW1wRGVjaW1hbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgcmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JvdW5kVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSA9IHRoaXMuX3RyaW1MZWFkaW5nQW5kVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSk7IC8vIE1vdmUgdGhlIGBzZXRSYXdWYWx1ZWAgY2FsbCBhZnRlciB0aGUgYHNldEVsZW1lbnRWYWx1ZWAgb25lXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fdG9OdW1lcmljVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gdGhpcy5zZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBEZWNpbWFsID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcih0aGlzLnNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JvdW5kVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmVlblJvdW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUm91bmRzIGlmIHRoaXMgaGFzIG5vdCBiZWVuIGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICghaGFzQmVlblJvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZFZhbHVlKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZXMgcmF3VmFsdWUgaW5jbHVkaW5nIHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gRmluZCBhIGJldHRlciB3YXkgdG8gcHJldmVudCBwb3RlbnRpYWxseSBvdmVyd3JpdGluZyB0aGUgYHJhd1ZhbHVlYCB2YXJpYWJsZSAodGhhdCBjb3VsZCBoYXZlIGFscmVhZHkgYmVlbiBzZXQgZmV3IGxpbmVzIGFib3ZlKVxuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSA9IHRoaXMuX3RyaW1MZWFkaW5nQW5kVHJhaWxpbmdaZXJvcyh2YWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCB0aGlzLnNldHRpbmdzLCB0aGlzLmlzRm9jdXNlZCwgcmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5zZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgdGhpcy5zZXR0aW5ncy5zY2FsZVN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICYmICh0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgdGhpcy5zZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJ3NldCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCBiYWNrIHRoZSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBvcHRpb24gdG8gaXRzIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHRoaXMuc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzICYmICF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHRlbXBEZWNpbWFsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRBbmRSYXdWYWx1ZSh2YWx1ZSwgcmF3VmFsdWUsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm1pblJhbmdlRXhjZWVkZWQsIHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubWF4UmFuZ2VFeGNlZWRlZCwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3RoaXMuc2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHt0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCdyZW1vdmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKCcnLCBzYXZlQ2hhbmdlVG9IaXN0b3J5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVyZSwgYHZhbHVlYCBlcXVhbCB0aGUgZW1wdHkgc3RyaW5nIGAnJ2BcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmFsd2F5cykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbmN5IHN5bWJvbCBhcyBwZXIgZW1wdHlJbnB1dEJlaGF2aW9yXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRBbmRSYXdWYWx1ZShyZXN1bHQsICcnLCBzYXZlQ2hhbmdlVG9IaXN0b3J5KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIHZhbHVlIGRpcmVjdGx5IGFzIHRoZSBET00gZWxlbWVudCB2YWx1ZSwgd2l0aG91dCBmb3JtYXR0aW5nIGl0IGJlZm9yZWhhbmQuXG4gICAgICogWW91IGNhbiBhbHNvIHNldCB0aGUgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgc2V0dGluZyBpbiBvbmUgZ28gKHRoZSB2YWx1ZSB3aWxsIGFnYWluIG5vdCBiZSBmb3JtYXR0ZWQgaW1tZWRpYXRlbHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBzZXRVbmZvcm1hdHRlZCh2YWx1ZSwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgLy9UT0RPIFNob3VsZCB3ZSB1c2UgYEF1dG9OdW1lcmljLnVuZm9ybWF0KClgIGhlcmUgYW5kIHNldCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IGluIGNhc2UgYHZhbHVlYCBpcyBmb3JtYXR0ZWQ/XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG9wdGlvbnMgdXBkYXRlIGlzIGRvbmUgb25seSBpZiB0aGUgYHZhbHVlYCBpcyBub3QgbnVsbFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3Mob3B0aW9ucywgdHJ1ZSk7IC8vIFdlIGRvIG5vdCBjYWxsIGB1cGRhdGVgIGhlcmUgc2luY2UgdGhpcyB3b3VsZCBjYWxsIGBzZXRgIHRvb1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JlbW92ZUJyYWNrZXRzKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhzdHJpcHBlZFZhbHVlLCB0aGlzLnNldHRpbmdzLCB0cnVlLCB0aGlzLmlzRm9jdXNlZCk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihub3JtYWxpemVkVmFsdWUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgb25lLCBpdCdzIG5vdCBhIG51bWVyaWMgc3RyaW5nIG5vciBhIHJlY29nbml6ZWQgY3VycmVuY3kuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbihub3JtYWxpemVkVmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYG5vcm1hbGl6ZWRWYWx1ZWAgaXMgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB2YWx1ZSBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cyBbJHt0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZX0sICR7dGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gdmFsdWUgZGlyZWN0bHkgYXMgdGhlIERPTSBlbGVtZW50IHZhbHVlLCB3aXRob3V0IGZvcm1hdHRpbmcgaXQgYmVmb3JlaGFuZCwgYW5kIHdpdGhvdXQgY2hlY2tpbmcgaXRzIHZhbGlkaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfG51bGx9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0IG9uIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlQ2hhbmdlVG9IaXN0b3J5IElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIGNoYW5nZSBpcyByZWNvcmRlZCBpbiB0aGUgaGlzdG9yeSBhcnJheSwgb3RoZXJ3aXNlIGl0IGlzIG5vdFxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgc2F2ZUNoYW5nZVRvSGlzdG9yeSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudEFuZFJhd1ZhbHVlKG5ld1ZhbHVlLCBzYXZlQ2hhbmdlVG9IaXN0b3J5KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSByYXcgdmFsdWUgaW5zaWRlIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHJhd1ZhbHVlIFRoZSBudW1lcmljIHZhbHVlIGFzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCBsaWtlIGEgYE51bWJlcmBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNhdmVDaGFuZ2VUb0hpc3RvcnkgSWYgc2V0IHRvIGB0cnVlYCwgdGhlbiB0aGUgY2hhbmdlIGlzIHJlY29yZGVkIGluIHRoZSBoaXN0b3J5IGFycmF5LCBvdGhlcndpc2UgaXQgaXMgbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0UmF3VmFsdWUocmF3VmFsdWUsIHNhdmVDaGFuZ2VUb0hpc3RvcnkgPSB0cnVlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmF3IHZhbHVlXG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmF3VmFsdWUgPSByYXdWYWx1ZTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGVsZW1lbnQgc3R5bGUgb3IgdXNlIHRoZSByZWxldmFudCBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5fcGFyc2VTdHlsZVJ1bGVzKCk7XG5cbiAgICAgICAgaWYgKHNhdmVDaGFuZ2VUb0hpc3RvcnkpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgaW4gdGhlIGhpc3RvcnkgdGhlIGxhc3Qga25vd24gcmF3IHZhbHVlIGFuZCBmb3JtYXR0ZWQgcmVzdWx0IHNlbGVjdGlvblxuICAgICAgICAgICAgdGhpcy5faGlzdG9yeVRhYmxlQWRkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIHZhbHVlIG9uIHRoZSBET00gZWxlbWVudCwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGByYXdWYWx1ZWAuXG4gICAgICogVGhpcyBzZW5kIGFuICdhdXRvTnVtZXJpYzpmb3JtYXR0ZWQnIGV2ZW50IGlmIHRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG9sZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG5ld0VsZW1lbnRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRFbGVtZW50VmFsdWUobmV3RWxlbWVudFZhbHVlKSB7XG4gICAgICAgIC8vVE9ETyBVc2UgYW4gaW50ZXJuYWwgYXR0cmlidXRlIHRvIHRyYWNrIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbGVtZW50IGBmb3JtYXR0ZWRWYWx1ZWAgKGxpa2UgaXRzIGNvdW50ZXJwYXJ0IGByYXdWYWx1ZWApLiBUaGlzIHdvdWxkIGFsbG93IHVzIHRvIGF2b2lkIGNhbGxpbmcgYGdldEVsZW1lbnRWYWx1ZWAgbWFueSB0aW1lc1xuICAgICAgICAvLyBgb2xkRWxlbWVudFZhbHVlYCBpcyB0aGUgcHJldmlvdXMgdmFsdWUgdGhhdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBUaGlzIGlzIHVzZWQgdG8gZGVjaWRlIGlmIGFuIGV2ZW50IHNob3VsZCBiZSBzZW50IG9yIG5vdC5cbiAgICAgICAgY29uc3Qgb2xkRWxlbWVudFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKG5ld0VsZW1lbnRWYWx1ZSAhPT0gb2xkRWxlbWVudFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIG5ld0VsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLmZvcm1hdHRlZCwgdGhpcy5kb21FbGVtZW50LCB7IG9sZFZhbHVlOiBvbGRFbGVtZW50VmFsdWUsIG5ld1ZhbHVlOiBuZXdFbGVtZW50VmFsdWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIHZhbHVlIG9uIHRoZSBET00gZWxlbWVudCwgYW5kIHRoZSByYXcgdmFsdWUgb24gYHRoaXMuc2V0dGluZ3MucmF3VmFsdWVgLCBpZiBib3RoIGFyZSBnaXZlbi5cbiAgICAgKiBJZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiwgdGhlbiBib3RoIHRoZSBET00gZWxlbWVudCB2YWx1ZSBhbmQgdGhlIHJhdyB2YWx1ZSBhcmUgc2V0IHdpdGggdGhhdCB2YWx1ZS5cbiAgICAgKiBUaGUgdGhpcmQgYXJndW1lbnQgYHNhdmVDaGFuZ2VUb0hpc3RvcnlgIGRlZmluZXMgaWYgdGhlIGNoYW5nZSBzaG91bGQgYmUgcmVjb3JkZWQgaW4gdGhlIGhpc3RvcnkgYXJyYXkuXG4gICAgICogTm90ZTogaWYgdGhlIHNlY29uZCBhcmd1bWVudCBgcmF3VmFsdWVgIGlzIGEgYm9vbGVhbiwgd2UgY29uc2lkZXIgdGhhdCBpcyByZWFsbHkgaXMgdGhlIGBzYXZlQ2hhbmdlVG9IaXN0b3J5YCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbmV3RWxlbWVudFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG51bGx8Ym9vbGVhbn0gcmF3VmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNhdmVDaGFuZ2VUb0hpc3RvcnlcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWxlbWVudEFuZFJhd1ZhbHVlKG5ld0VsZW1lbnRWYWx1ZSwgcmF3VmFsdWUgPSBudWxsLCBzYXZlQ2hhbmdlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgcmF3VmFsdWUgPSBuZXdFbGVtZW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgc2F2ZUNoYW5nZVRvSGlzdG9yeSA9IHJhd1ZhbHVlO1xuICAgICAgICAgICAgcmF3VmFsdWUgPSBuZXdFbGVtZW50VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL1hYWCBUaGUgb3JkZXIgaGVyZSBpcyBpbXBvcnRhbnQgOyB0aGUgdmFsdWUgc2hvdWxkIGZpcnN0IGJlIHNldCBvbiB0aGUgZWxlbWVudCwgdGhlbiBhbmQgb25seSB0aGVuIHdlIHNob3VsZCB1cGRhdGUgdGhlIHJhdyB2YWx1ZVxuICAgICAgICAvLyBJbiB0aGUgYHNldCgpYCBmdW5jdGlvbiwgd2UgbWFrZSBzdXJlIHRvIGNhbGwgYF9zZXRSYXdWYWx1ZWAgKmFmdGVyKiBgc2V0RWxlbWVudFZhbHVlYCBzbyB0aGF0IGlmIGBfc2V0UmF3VmFsdWVgIGNhbGxzIGEgY2FsbGJhY2sgdGhhdCBtb2RpZnkgdGhlIGByYXdWYWx1ZWAsIHRoZW4gdGhlIG5ldyB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5IChhZnRlciBgc2V0RWxlbWVudFZhbHVlYCBicmllZmx5IHNldCBpdHMgdmFsdWUgZmlyc3QpXG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShuZXdFbGVtZW50VmFsdWUpO1xuICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZShyYXdWYWx1ZSwgc2F2ZUNoYW5nZVRvSGlzdG9yeSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgdGhlIGBnZXROdW1lcmljU3RyaW5nKClgIGZ1bmN0aW9uLlxuICAgICAqIERldmVsb3BlcnMgc2hvdWxkIHVzZSBvbmUgb2YgdGhlIG1vcmUgZXhwbGljaXQgZnVuY3Rpb24gbmFtZXMgdG8gZ2V0IHdoYXQgdGhleSB3YW50IDpcbiAgICAgKiAtIGEgbnVtZXJpYyBzdHJpbmcgOiBgZ2V0TnVtZXJpY1N0cmluZygpYFxuICAgICAqIC0gYSBmb3JtYXR0ZWQgc3RyaW5nIDogYGdldEZvcm1hdHRlZCgpYFxuICAgICAqIC0gYSBudW1iZXIgOiBgZ2V0TnVtYmVyKClgLCBvclxuICAgICAqIC0gYSBsb2NhbGl6ZWQgbnVtZXJpYyBzdHJpbmcgOiBgZ2V0TG9jYWxpemVkKClgXG4gICAgICpcbiAgICAgKiBAdXNhZ2UgYW5FbGVtZW50LmdldCgpO1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtZXJpY1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAdXNhZ2UgYW5FbGVtZW50LmdldE51bWVyaWNTdHJpbmcoKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TnVtZXJpY1N0cmluZygpIHtcbiAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIG51bWVyaWMgc3RyaW5nXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IGdldHMgcmlkIG9mIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwbGFjZXMgc2luY2UgdGhlIGN1cnJlbnQgbWV0aG9kIGRvZXMgbm90IHBhZCBkZWNpbWFsc1xuICAgICAgICByZXR1cm4gQXV0b051bWVyaWNIZWxwZXIudHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXModGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgQXV0b051bWVyaWMgZWxlbWVudCBhcyBhIHN0cmluZ1xuICAgICAqXG4gICAgICogQHVzYWdlIGFuRWxlbWVudC5nZXRGb3JtYXR0ZWQoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgIGlmICghKCd2YWx1ZScgaW4gdGhpcy5kb21FbGVtZW50IHx8ICd0ZXh0Q29udGVudCcgaW4gdGhpcy5kb21FbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGAudmFsdWVgIG9yIGAudGV4dENvbnRlbnQnIGV4aXN0cyBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aG9zZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKCdVbmFibGUgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgc3RyaW5nIGZyb20gdGhlIGVsZW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlbGVtZW50IHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgcmVhbCBKYXZhc2NyaXB0IG51bWJlci5cbiAgICAgKiBXYXJuaW5nOiBUaGlzIGNhbiBsZWFkIHRvIHByZWNpc2lvbiBwcm9ibGVtcyB3aXRoIGJpZyBudW1iZXJzIHRoYXQgc2hvdWxkIGJlIHN0b3JlZCBhcyBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHVzYWdlIGFuRWxlbWVudC5nZXROdW1iZXIoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXROdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXROdW1lcmljU3RyaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX3RvTG9jYWxlKHZhbHVlLCAnbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGJ1dCBmb2xsb3dpbmcgdGhlIGBvdXRwdXRGb3JtYXRgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxuICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHVzYWdlIGFuRWxlbWVudC5nZXRMb2NhbGl6ZWQoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNFbXB0eVN0cmluZyh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhlcmUgSSB1c2UgYHRoaXMuc2V0dGluZ3MucmF3VmFsdWVgIGluc3RlYWQgb2YgYHRoaXMuZ2V0TnVtZXJpY1N0cmluZygpYCBzaW5jZSB0aGUgY3VycmVudCBpbnB1dCB2YWx1ZSBjb3VsZCBiZSB1bmZvcm1hdHRlZCB3aXRoIGEgbG9jYWxpemF0aW9uIChpZS4gJzEyMzQ1NjcsODktJykuXG4gICAgICAgICAgICAvLyBJIGFsc28gY29udmVydCB0aGUgcmF3VmFsdWUgdG8gYSBudW1iZXIsIHRoZW4gYmFjayB0byBhIHN0cmluZyBpbiBvcmRlciB0byBkcm9wIHRoZSBkZWNpbWFsIHBhcnQgaWYgdGhlIHJhd1ZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAgICAgICAgICB2YWx1ZSA9ICcnK051bWJlcih0aGlzLnNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiB0aGlzLnNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmtlZXApIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG91dHB1dEZvcm1hdFRvVXNlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGZvcmNlZE91dHB1dEZvcm1hdCkpIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gdGhpcy5zZXR0aW5ncy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRGb3JtYXRUb1VzZSA9IGZvcmNlZE91dHB1dEZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl90b0xvY2FsZSh2YWx1ZSwgb3V0cHV0Rm9ybWF0VG9Vc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHRoZSBlbGVtZW50IHRvIHJlZm9ybWF0IGl0cyB2YWx1ZSBhZ2FpbiAoanVzdCBpbiBjYXNlIHRoZSBmb3JtYXR0aW5nIGhhcyBiZWVuIGxvc3QpLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgcmlnaHQgYWZ0ZXIgYSBmb3JtIHN1Ym1pc3Npb24gZm9yIGluc3RhbmNlIChhZnRlciBhIHByZXZpb3VzIGNhbGwgdG8gYHVuZm9ybWF0YCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQucmVmb3JtYXQoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHJlZm9ybWF0KCkge1xuICAgICAgICAvLyBgdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGB0aGlzLmRvbUVsZW1lbnQudmFsdWVgIGJlY2F1c2Ugd2hlbiB0aGUgY29udGVudCBpcyBgdW5mb3JtYXRMb2NhbGl6ZWRgLCBpdCBjYW4gYmVjb21lIGEgc3RyaW5nIHRoYXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciBlYXNpbHlcbiAgICAgICAgdGhpcy5zZXQodGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGFuZCBrZWVwIG9ubHkgdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSBpbiB0aGUgZWxlbWVudCAoYXMgYSBudW1lcmljU3RyaW5nKVxuICAgICAqIE5vdGU6IHRoaXMgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgJ3VuU2V0KCknIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZ3MgKGllLiBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIpLCB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXG4gICAgICogQGV4YW1wbGUgYW5FbGVtZW50LnVuZm9ybWF0KClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICB1bmZvcm1hdCgpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHRoaXMuZ2V0TnVtZXJpY1N0cmluZygpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZvcm1hdHRpbmcgYW5kIGtlZXAgb25seSB0aGUgbG9jYWxpemVkIHVuZm9ybWF0dGVkIHZhbHVlIGluIHRoZSBlbGVtZW50LCB3aXRoIHRoZSBvcHRpb24gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3V0cHV0Rm9ybWF0IGlmIG5lZWRlZFxuICAgICAqXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycy5cbiAgICAgKiBUYWtlIGEgbG9vayBhdCB0aGUgYG91dHB1dEZvcm1hdGAgb3B0aW9uIGRlZmluaXRpb24gaW4gdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHVuZm9ybWF0TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHRoaXMuZ2V0TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgdGhlIHNhbWUgYXMgd2hlbiB0aGUgZWxlbWVudCBnb3QgaW5pdGlhbGl6ZWQuXG4gICAgICogTm90ZTogQnkgZGVmYXVsdCwgdGhpcyByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGlzIHN0aWxsIHRoZSBzYW1lIGV2ZW4gaWYgdGhlIGZvcm1hdHRlZCBvbmUgaGFzIGNoYW5nZWQgKGR1ZSB0byBhIGNvbmZpZ3VyYXRpb24gdXBkYXRlIGZvciBpbnN0YW5jZSkuXG4gICAgICogSW4gb3JkZXIgdG8gdGVzdCBpZiB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIHRoZSBzYW1lICh3aGljaCBtZWFucyBuZWl0aGVyIHRoZSByYXcgdmFsdWUgbm9yIHRoZSBzZXR0aW5ncyBoYXZlIGJlZW4gY2hhbmdlZCksIHRoZW4geW91IG11c3QgcGFzcyBgZmFsc2VgIGFzIGl0cyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tPbmx5UmF3VmFsdWUgSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHByaXN0aW5lIHZhbHVlIGlzIGRvbmUgb24gdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSwgbm90IHRoZSBmb3JtYXR0ZWQgb25lLiAgSWYgc2V0IHRvIGBmYWxzZWAsIHRoaXMgYWxzbyBjaGVja3MgdGhhdCB0aGUgZm9ybWF0dGVkIHZhbHVlIGhhc24ndCBjaGFuZ2VkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUHJpc3RpbmUoY2hlY2tPbmx5UmF3VmFsdWUgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChjaGVja09ubHlSYXdWYWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pbml0aWFsVmFsdWUgPT09IHRoaXMuZ2V0TnVtZXJpY1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pbml0aWFsVmFsdWVIdG1sQXR0cmlidXRlID09PSB0aGlzLmdldEZvcm1hdHRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGZvcm1hdHRlZCBlbGVtZW50IGNvbnRlbnQsIGJhc2VkIG9uIHRoZSBgc2VsZWN0TnVtYmVyT25seWAgb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc2VsZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWxlY3ROdW1iZXJPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE51bWJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFNlbGVjdEFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSB3aG9sZSBlbGVtZW50IGNvbnRlbnQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc3ltYm9sKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWZhdWx0U2VsZWN0QWxsKCkge1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCwgMCwgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb25seSB0aGUgbnVtYmVycyBpbiB0aGUgZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudCwgbGVhdmluZyBvdXQgdGhlIGN1cnJlbmN5IHN5bWJvbCwgd2hhdGV2ZXIgdGhlIHZhbHVlIG9mIHRoZSBgc2VsZWN0TnVtYmVyT25seWAgb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc2VsZWN0TnVtYmVyKCkge1xuICAgICAgICAvL1RPRE8gTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gaXMgb2sgd2hlbiBzaG93UG9zaXRpdmVTaWduIGlzIHNldCB0byBgdHJ1ZWAgKHNlbGVjdCB0aGUgbmVnYXRpdmUgc2lnbiwgYnV0IG5vdCB0aGUgcG9zaXRpdmUgb25lKVxuICAgICAgICBjb25zdCB1bmZvcm1hdHRlZFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdW5mb3JtYXR0ZWRWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sU2l6ZSA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ7XG4gICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZSh1bmZvcm1hdHRlZFZhbHVlKSk/MDoxO1xuICAgICAgICBjb25zdCBzdWZmaXhUZXh0TGVuID0gdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50O1xuXG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQgJiYgbmVnTGVuID09PSAxICYmIGN1cnJlbmN5U3ltYm9sU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gY3VycmVuY3lTeW1ib2xTaXplICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gY3VycmVuY3lTeW1ib2xTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCkge1xuICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBzdWZmaXhUZXh0TGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OlxuICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChzdWZmaXhUZXh0TGVuICsgY3VycmVuY3lTeW1ib2xTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xTaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xTaXplICsgbmVnTGVuICsgc3VmZml4VGV4dExlbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbFNpemUgKyBzdWZmaXhUZXh0TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xTaXplICsgc3VmZml4VGV4dExlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCwgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgdGhlIGludGVnZXIgcGFydCBpbiB0aGUgZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudCwgd2hhdGV2ZXIgdGhlIHZhbHVlIG9mIGBzZWxlY3ROdW1iZXJPbmx5YFxuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHNlbGVjdEludGVnZXIoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGNvbnN0IGlzUG9zaXRpdmUgPSB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlID49IDA7XG5cbiAgICAgICAgLy8gTmVnYXRpdmUgb3IgcG9zaXRpdmUgc2lnbiwgaWYgYW55XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCB8fFxuICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4ICYmXG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXggfHxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSkpKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiBpc1Bvc2l0aXZlKSB8fCAgLy8gVGhpcyBvbmx5IGV4Y2x1ZGUgdGhlIHBvc2l0aXZlIHNpZ24gZnJvbSBiZWluZyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICghaXNQb3NpdGl2ZSAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQpKSB7IC8vIEFuZCB0aGlzIGV4Y2x1ZGUgdGhlIG5lZ2F0aXZlIHNpZ24gZnJvbSBiZWluZyBzZWxlY3RlZCBpbiB0aGlzIHNwZWNpYWwgY2FzZSA6ICct4oKsIDEuMjM0LDU3c3VmZml4VGV4dCdcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1cnJlbmN5IHN5bWJvbFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIGVuZCBwb3NpdGlvblxuICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgbGV0IGVuZCA9IGVsZW1lbnRWYWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBObyBkZWNpbWFsIGNoYXJhY3RlciBmb3VuZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgZW5kID0gZWxlbWVudFZhbHVlLmxlbmd0aCAtIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBlbGVtZW50VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmFpbGluZyBuZWdhdGl2ZSBzaWduXG4gICAgICAgICAgICBpZiAoIWlzUG9zaXRpdmUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXggfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdm9pZCBzZWxlY3RpbmcgdGhlIHN1ZmZpeCB0ZXN0XG4gICAgICAgICAgICBlbmQgPSBlbmQgLSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvbmx5IHRoZSBkZWNpbWFsIHBhcnQgaW4gdGhlIGZvcm1hdHRlZCBlbGVtZW50IGNvbnRlbnQsIHdoYXRldmVyIHRoZSB2YWx1ZSBvZiBgc2VsZWN0TnVtYmVyT25seWBcbiAgICAgKiBNdWx0aXBsZSBjYXNlcyBhcmUgcG9zc2libGUgOlxuICAgICAqICsxLjIzNCw1N3N1ZmZpeFRleHRcbiAgICAgKlxuICAgICAqIOKCrCArMS4yMzQsNTdzdWZmaXhUZXh0XG4gICAgICogK+KCrCAxLjIzNCw1N3N1ZmZpeFRleHRcbiAgICAgKiDigqwgMS4yMzQsNTcrc3VmZml4VGV4dFxuICAgICAqXG4gICAgICogMS4yMzQsNTcrIOKCrHN1ZmZpeFRleHRcbiAgICAgKiAxLjIzNCw1NyDigqwrc3VmZml4VGV4dFxuICAgICAqICsxLjIzNCw1NyDigqxzdWZmaXhUZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc2VsZWN0RGVjaW1hbCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkuaW5kZXhPZih0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICBsZXQgZW5kO1xuXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkZWNpbWFsIGNoYXJhY3RlciBoYXMgbm90IGJlZW4gZm91bmQsIHdlIGRlc2VsZWN0IGFsbFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEEgZGVjaW1hbCBjaGFyYWN0ZXIgaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyAxOyAvLyBXZSBhZGQgMSB0byBleGNsdWRlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBmcm9tIHRoZSBzZWxlY3Rpb25cblxuICAgICAgICAgICAgbGV0IGRlY2ltYWxDb3VudDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmICF0aGlzLmlzRm9jdXNlZCkpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ291bnQgPSB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbENvdW50ID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIE51bWJlcihkZWNpbWFsQ291bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIG9mIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fVxuICAgICAqL1xuICAgIG5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudCByZWZlcmVuY2Ugb2YgdGhlIHBhcmVudCBub2RlIG9mIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fE5vZGV9XG4gICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIGVsZW1lbnQgZnJvbSB0aGUgc2hhcmVkIGxvY2FsICdpbml0JyBsaXN0LlxuICAgICAqIFRoaXMgbWVhbnMgYW55IGNoYW5nZXMgbWFkZSBvbiB0aGF0IGxvY2FsIHNoYXJlZCBsaXN0IHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIHRvIHRoYXQgZWxlbWVudCBhbnltb3JlLlxuICAgICAqIE5vdGUgOiBUaGUgdXNlciBjYW4gcHJvdmlkZSBhbm90aGVyIEF1dG9OdW1lcmljIGVsZW1lbnQsIGFuZCBkZXRhY2ggdGhpcyBvbmUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljfSBvdGhlckFuRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBkZXRhY2gob3RoZXJBbkVsZW1lbnQgPSBudWxsKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGxldCBkb21FbGVtZW50VG9EZXRhY2g7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG90aGVyQW5FbGVtZW50KSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudFRvRGV0YWNoID0gb3RoZXJBbkVsZW1lbnQubm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tRWxlbWVudFRvRGV0YWNoID0gdGhpcy5kb21FbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUxvY2FsTGlzdChkb21FbGVtZW50VG9EZXRhY2gpOyAvL0ZJWE1FIFdoYXQgaGFwcGVucyBpZiB0aGUgc2VsZWN0ZWQgZG9tIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Q/XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBBdXRvTnVtZXJpYyBlbGVtZW50IHRvIHRoZSBzaGFyZWQgbG9jYWwgJ2luaXQnIGxpc3QuXG4gICAgICogV2hlbiBkb2luZyB0aGF0LCBieSBkZWZhdWx0IHRoZSBET00gY29udGVudCBpcyBsZWZ0IHVudG91Y2hlZC5cbiAgICAgKiBUaGUgdXNlciBjYW4gZm9yY2UgYSByZWZvcm1hdCB3aXRoIHRoZSBuZXcgc2hhcmVkIGxpc3Qgb3B0aW9ucyBieSBwYXNzaW5nIGEgc2Vjb25kIGFyZ3VtZW50IHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IG90aGVyQW5FbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSByZUZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBhdHRhY2gob3RoZXJBbkVsZW1lbnQsIHJlRm9ybWF0ID0gdHJ1ZSkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICB0aGlzLl9hZGRUb0xvY2FsTGlzdChvdGhlckFuRWxlbWVudC5ub2RlKCkpOyAvL0ZJWE1FIFNob3VsZCB3ZSBtYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgaW4gdGhlIGxpc3Q/XG4gICAgICAgIGlmIChyZUZvcm1hdCkge1xuICAgICAgICAgICAgb3RoZXJBbkVsZW1lbnQudXBkYXRlKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGFuZCByZXR1cm4gdGhlIGdpdmVuIHZhbHVlLCBvciBzZXQgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBnaXZlbiBET00gZWxlbWVudCBpZiBvbmUgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgdXNlIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MuXG4gICAgICogVGhlIHVzZXIgY2FuIG92ZXJyaWRlIGFueSBvcHRpb24gb2YgaXRzIGNob29zaW5nIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IHZhbHVlT3JFbGVtZW50XG4gICAgICogQHBhcmFtIHtudWxsfG9iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZm9ybWF0T3RoZXIodmFsdWVPckVsZW1lbnQsIG9wdGlvbk92ZXJyaWRlID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0T3JVbmZvcm1hdE90aGVyKHRydWUsIHZhbHVlT3JFbGVtZW50LCBvcHRpb25PdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgYW5kIHJldHVybiB0aGUgcmF3IG51bWVyaWMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHZhbHVlLCBvciBkaXJlY3RseSBzZXQgdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGdpdmVuIERPTSBlbGVtZW50IGlmIG9uZSBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyB1c2UgdGhlIGN1cnJlbnQgZWxlbWVudCBzZXR0aW5ncy5cbiAgICAgKiBUaGUgdXNlciBjYW4gb3ZlcnJpZGUgYW55IG9wdGlvbiBvZiBpdHMgY2hvb3NpbmcgYnkgcGFzc2luZyBhbiBvcHRpb24gb2JqZWN0LlxuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gc3RyaW5nT3JFbGVtZW50XG4gICAgICogQHBhcmFtIHtudWxsfG9iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdW5mb3JtYXRPdGhlcihzdHJpbmdPckVsZW1lbnQsIG9wdGlvbk92ZXJyaWRlID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0T3JVbmZvcm1hdE90aGVyKGZhbHNlLCBzdHJpbmdPckVsZW1lbnQsIG9wdGlvbk92ZXJyaWRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBlaXRoZXIgZm9ybWF0IG9yIHVuZm9ybWF0IHRoZSB2YWx1ZSBvZiBhbm90aGVyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAtIEZvcm1hdCBhbmQgcmV0dXJuIHRoZSBnaXZlbiB2YWx1ZSwgb3Igc2V0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaWYgb25lIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiAtIFVuZm9ybWF0IGFuZCByZXR1cm4gdGhlIHJhdyBudW1lcmljIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB2YWx1ZSwgb3IgZGlyZWN0bHkgc2V0IHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBnaXZlbiBET00gZWxlbWVudCBpZiBvbmUgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyB1c2UgdGhlIGN1cnJlbnQgZWxlbWVudCBzZXR0aW5ncy5cbiAgICAgKiBUaGUgdXNlciBjYW4gb3ZlcnJpZGUgYW55IG9wdGlvbiBvZiBpdHMgY2hvb3NpbmcgYnkgcGFzc2luZyBhbiBvcHRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0Zvcm1hdHRpbmcgSWYgc2V0IHRvIGB0cnVlYCwgdGhlbiB0aGUgbWV0aG9kIGZvcm1hdHMsIG90aGVyd2lzZSBpZiBzZXQgdG8gYGZhbHNlYCwgaXQgdW5mb3JtYXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IHZhbHVlT3JTdHJpbmdPckVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bGx8b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRPclVuZm9ybWF0T3RoZXIoaXNGb3JtYXR0aW5nLCB2YWx1ZU9yU3RyaW5nT3JFbGVtZW50LCBvcHRpb25PdmVycmlkZSA9IG51bGwpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIGN1cnJlbnQgZWxlbWVudCBzZXR0aW5ncyB0ZW1wb3JhcmlseVxuICAgICAgICBsZXQgc2V0dGluZ3NUb1VzZTtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9uT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1RvVXNlID0gdGhpcy5fY2xvbmVBbmRNZXJnZVNldHRpbmdzKG9wdGlvbk92ZXJyaWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHRpbmdzVG9Vc2UgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiB0aGUgdW5mb3JtYXR0aW5nIGlzIGRvbmUuLi5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRWxlbWVudCh2YWx1ZU9yU3RyaW5nT3JFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gLi4uZWl0aGVyIGRpcmVjdGx5IG9uIHRoZSBET00gZWxlbWVudCB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHZhbHVlT3JTdHJpbmdPckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzRm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljLmZvcm1hdChlbGVtZW50VmFsdWUsIHNldHRpbmdzVG9Vc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWMudW5mb3JtYXQoZWxlbWVudFZhbHVlLCBzZXR0aW5nc1RvVXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHZhbHVlT3JTdHJpbmdPckVsZW1lbnQsIHJlc3VsdCk7IC8vVE9ETyBVc2UgYHVuZm9ybWF0QW5kU2V0YCBhbmQgYGZvcm1hdEFuZFNldGBpbnN0ZWFkXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLi4ub3Igb24gdGhlIGdpdmVuIHZhbHVlXG4gICAgICAgIGlmIChpc0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljLmZvcm1hdCh2YWx1ZU9yU3RyaW5nT3JFbGVtZW50LCBzZXR0aW5nc1RvVXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljLnVuZm9ybWF0KHZhbHVlT3JTdHJpbmdPckVsZW1lbnQsIHNldHRpbmdzVG9Vc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGN1cnJlbnQgQXV0b051bWVyaWMgZWxlbWVudCBzZXR0aW5ncyB0byBpbml0aWFsaXplIHRoZSBET00gZWxlbWVudChzKSBnaXZlbiBhcyBhIHBhcmFtZXRlci5cbiAgICAgKiBEb2luZyBzbyB3aWxsICpsaW5rKiB0aGUgQXV0b051bWVyaWMgZWxlbWVudHMgdG9nZXRoZXIgc2luY2UgdGhleSB3aWxsIHNoYXJlIHRoZSBzYW1lIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKiAoY2YuIHByb3RvdHlwZSBwYXR0ZXJuIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvdG90eXBlX3BhdHRlcm4pXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGBpbml0YCBlaXRoZXIgYSBzaW5nbGUgRE9NIGVsZW1lbnQgKGluIHRoYXQgY2FzZSBhbiBBdXRvTnVtZXJpYyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZCksIG9yIGFuIGFycmF5IG9mIERPTSBlbGVtZW50cyBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhIENTUyBzZWxlY3Rvci4gSW4gdGhlIGxhdHRlciBjYXNlcywgYW4gYXJyYXkgb2YgQXV0b051bWVyaWMgb2JqZWN0cyB3aWxsIHRoZW4gYmUgcmV0dXJuZWQgKG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vdGhpbmcgZ2V0cyBzZWxlY3RlZCBieSB0aGUgQ1NTIHNlbGVjdG9yKS5cbiAgICAgKlxuICAgICAqIFVzZSBjYXNlIDogT25jZSB5b3UgaGF2ZSBhbiBBdXRvTnVtZXJpYyBlbGVtZW50IGFscmVhZHkgc2V0dXAgY29ycmVjdGx5IHdpdGggdGhlIHJpZ2h0IG9wdGlvbnMsIHlvdSBjYW4gdXNlIGl0IGFzIG1hbnkgdGltZXMgeW91IHdhbnQgdG8gaW5pdGlhbGl6ZSBhcyBtYW55IG90aGVyIERPTSBlbGVtZW50cyBhcyBuZWVkZWQuXG4gICAgICogTm90ZSA6IHRoaXMgd29ya3Mgb25seSBvbiBlbGVtZW50cyB0aGF0IGNhbiBiZSBtYW5hZ2VkIGJ5IGF1dG9OdW1lcmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEFycmF5PEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnQ+fHN0cmluZ30gZG9tRWxlbWVudE9yQXJyYXlPclN0cmluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXR0YWNoZWQgSWYgc2V0IHRvIGBmYWxzZWAsIHRoZW4gdGhlIG5ld2x5IGdlbmVyYXRlZCBBdXRvTnVtZXJpYyBlbGVtZW50IHdpbGwgbm90IHNoYXJlIHRoZSBzYW1lIGxvY2FsIGVsZW1lbnQgbGlzdFxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY3xbQXV0b051bWVyaWNdfVxuICAgICAqL1xuICAgIGluaXQoZG9tRWxlbWVudE9yQXJyYXlPclN0cmluZywgYXR0YWNoZWQgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXR1cm5BU2luZ2xlQXV0b051bWVyaWNPYmplY3QgPSBmYWxzZTsgLy8gQnkgZGVmYXVsdCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIEF1dG9OdW1lcmljIG9iamVjdHNcbiAgICAgICAgbGV0IGRvbUVsZW1lbnRzQXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcpKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50c0FycmF5ID0gWy4uLiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcpXTsgLy8gQ29udmVydCBhIE5vZGVMaXN0IHRvIGFuIEFycmF5XG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNFbGVtZW50KGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcpKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50c0FycmF5LnB1c2goZG9tRWxlbWVudE9yQXJyYXlPclN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm5BU2luZ2xlQXV0b051bWVyaWNPYmplY3QgPSB0cnVlOyAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBvbmx5IG9uZSBET00gZWxlbWVudCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0FycmF5KGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcpKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50c0FycmF5ID0gZG9tRWxlbWVudE9yQXJyYXlPclN0cmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBwYXJhbWV0ZXJzIHRvIHRoZSAnaW5pdCcgZnVuY3Rpb24gYXJlIGludmFsaWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tRWxlbWVudHNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYE5vIHZhbGlkIERPTSBlbGVtZW50cyB3ZXJlIGdpdmVuIGhlbmNlIG5vIEF1dG9OdW1lcmljIG9iamVjdCB3ZXJlIGluc3RhbnRpYXRlZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2NhbExpc3QgPSB0aGlzLl9nZXRMb2NhbExpc3QoKTtcbiAgICAgICAgY29uc3QgYXV0b051bWVyaWNPYmplY3RzQXJyYXkgPSBbXTtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSAoYW5kIGxpbmsgZGVwZW5kaW5nIG9uIGBhdHRhY2hlZGApIGVhY2ggQXV0b051bWVyaWMgb2JqZWN0c1xuICAgICAgICBkb21FbGVtZW50c0FycmF5LmZvckVhY2goZG9tRWxlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBuZXcgQXV0b051bWVyaWMgZWxlbWVudFxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDcmVhdGVMb2NhbExpc3RTZXR0aW5nID0gdGhpcy5zZXR0aW5ncy5jcmVhdGVMb2NhbExpc3Q7XG4gICAgICAgICAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgdG8ga25vdyBpZiB3ZSBzaG91bGQgY3JlYXRlIHRoZSBsb2NhbCBsaXN0IGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb24gKHNpbmNlIHdlJ2xsIHJlbW92ZSBpdCBhZnRlcndhcmRzKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0F1dG9OdW1lcmljRWxlbWVudCA9ICBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGRvbUVsZW1lbnQpLCB0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjb21tb24gc2hhcmVkIGxvY2FsIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBjcmVhdGUgYSBkZXRhY2hlZCBuZXcgQXV0b051bWVyaWMgZWxlbWVudCwgdGhlbiBza2lwIHRoZSBmb2xsb3dpbmcgc3RlcCB0aGF0IGJpbmQgdGhlIHR3byBlbGVtZW50cyB0b2dldGhlciBieSBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAxKSBTZXQgdGhlIGxvY2FsIGxpc3QgcmVmZXJlbmNlIHRvIHBvaW50IHRvIHRoZSBpbml0aWFsaXplcidzIG9uZVxuICAgICAgICAgICAgICAgIG5ld0F1dG9OdW1lcmljRWxlbWVudC5fc2V0TG9jYWxMaXN0KGN1cnJlbnRMb2NhbExpc3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gMikgQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGF0IGV4aXN0aW5nIGxpc3RcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0xvY2FsTGlzdChkb21FbGVtZW50LCBuZXdBdXRvTnVtZXJpY0VsZW1lbnQpOyAvLyBIZXJlIHdlIHVzZSB0aGUgKm5ldyogQXV0b051bWVyaWMgb2JqZWN0IHJlZmVyZW5jZSB0byBhZGQgdG8gdGhlIGxvY2FsIGxpc3QsIHNpbmNlIHdlJ2xsIG5lZWQgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIG1ldGhvZHMgdG8gcG9pbnRzIHRvIHRoYXQgbmV3IEF1dG9OdW1lcmljIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNyZWF0ZUxvY2FsTGlzdCA9IG9yaWdpbmFsQ3JlYXRlTG9jYWxMaXN0U2V0dGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXV0b051bWVyaWNPYmplY3RzQXJyYXkucHVzaChuZXdBdXRvTnVtZXJpY0VsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmV0dXJuQVNpbmdsZUF1dG9OdW1lcmljT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBJZiBhIHNpbmdsZSBET00gZWxlbWVudCB3YXMgdXNlZCBhcyB0aGUgcGFyYW1ldGVyLCB0aGVuIHdlIHJldHVybiBhbiBBdXRvTnVtZXJpYyBvYmplY3QgZGlyZWN0bHlcbiAgICAgICAgICAgIHJldHVybiBhdXRvTnVtZXJpY09iamVjdHNBcnJheVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC4uLm90aGVyd2lzZSB3ZSByZXR1cm4gYW4gQXJyYXkgb2YgQXV0b051bWVyaWMgb2JqZWN0c1xuICAgICAgICByZXR1cm4gYXV0b051bWVyaWNPYmplY3RzQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGVsZW1lbnQgdmFsdWUgZWl0aGVyIHRvIHRoZSBlbXB0eSBzdHJpbmcgJycsIG9yIHRoZSBjdXJyZW5jeSBzaWduLCBkZXBlbmRpbmcgb24gdGhlIGBlbXB0eUlucHV0QmVoYXZpb3JgIG9wdGlvbiB2YWx1ZS5cbiAgICAgKiBJZiB5b3Ugc2V0IHRoZSBgZm9yY2VDbGVhckFsbGAgYXJndW1lbnQgdG8gYHRydWVgLCB0aGVuIHRoZSBgZW1wdHlJbnB1dEJlaGF2aW9yYCBvcHRpb24gaXMgb3ZlcnJpZGRlbiBhbmQgdGhlIHdob2xlIGlucHV0IGlzIGNsZWFyLCBpbmNsdWRpbmcgYW55IGN1cnJlbmN5IHNpZ24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlQ2xlYXJBbGxcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgY2xlYXIoZm9yY2VDbGVhckFsbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmb3JjZUNsZWFyQWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wb3JhcnlGb3JjZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvcjogQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuZm9jdXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXQoJycsIHRlbXBvcmFyeUZvcmNlZE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQoJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBhdXRvTnVtZXJpYyBkYXRhIGFuZCBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgZWxlbWVudCwgYnV0IGtlZXAgdGhlIGVsZW1lbnQgY29udGVudCBpbnRhY3QuXG4gICAgICogVGhpcyBhbHNvIGNsZWFycyB0aGUgdmFsdWUgZnJvbSBzZXNzaW9uU3RvcmFnZSAob3IgY29va2llLCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0cykuXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQucmVtb3ZlKClcbiAgICAgKi9cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuX3NhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJ3JlbW92ZScpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuXG4gICAgICAgIC8vIEFsc28gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGxpc3RcbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUxvY2FsTGlzdCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAvLyBBbHNvIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBnbG9iYWwgQXV0b051bWVyaWMgbGlzdFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9yZW1vdmVGcm9tR2xvYmFsTGlzdCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGF1dG9OdW1lcmljIGRhdGEgYW5kIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBlbGVtZW50LCBhbmQgcmVzZXQgaXRzIHZhbHVlIHRvIHRoZSBlbXB0eSBzdHJpbmcgJycuXG4gICAgICogVGhpcyBhbHNvIGNsZWFycyB0aGUgdmFsdWUgZnJvbSBzZXNzaW9uU3RvcmFnZSAob3IgY29va2llLCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0cykuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQud2lwZSgpXG4gICAgICovXG4gICAgd2lwZSgpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKCcnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGF1dG9OdW1lcmljIGRhdGEgYW5kIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBlbGVtZW50LCBhbmQgZGVsZXRlIHRoZSBET00gZWxlbWVudCBhbHRvZ2V0aGVyXG4gICAgICovXG4gICAgbnVrZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIH1cblxuXG4gICAgLy8gU3BlY2lhbCBmdW5jdGlvbnMgdGhhdCByZWFsbHkgd29yayBvbiB0aGUgcGFyZW50IDxmb3JtPiBlbGVtZW50LCBpbnN0ZWFkIG9mIHRoZSA8aW5wdXQ+IGVsZW1lbnQgaXRzZWxmXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSByZXR1cm4gYG51bGxgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEZvcm1FbGVtZW50fG51bGx9XG4gICAgICovXG4gICAgZm9ybSgpIHtcbiAgICAgICAgLy9UT0RPIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgPGZvcm0+IGluIGB0aGlzLmZvcm1gIHNvIHdlIGRvIG5vdCBoYXZlIHRvIHNlYXJjaCBpdCBvbiBlYWNoIGNhbGw/XG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvbUVsZW1lbnQ7XG4gICAgICAgIGxldCB0YWdOYW1lO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIHVzaW5nIHRlbXBsYXRlcyB3aXRoIGZyYW1ld29ya3MgbGlrZSBWdWUuanMsIHdoZXJlIHRoZSBpbnB1dCBlbGVtZW50IGNhbiBiZSAnZGV0YWNoZWQnIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBET00gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhZ05hbWUgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0YWdOYW1lICE9PSAnZm9ybScpO1xuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24gd2l0aCB0aGUgZm9ybSBpbnB1dCB2YWx1ZXMgYmVpbmcgdW5mb3JtYXR0ZWQuXG4gICAgICogVGhpcyBzdHJpbmcgY2FuIGJlIHVzZWQgYXMgYSBxdWVyeSBmb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1OdW1lcmljU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fc2VyaWFsaXplTnVtZXJpY1N0cmluZyh0aGlzLmZvcm0oKSwgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbiB3aXRoIHRoZSBmb3JtIGlucHV0IHZhbHVlcyBiZWluZyBmb3JtYXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1Gb3JtYXR0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVGb3JtYXR0ZWQodGhpcy5mb3JtKCksIHRoaXMuc2V0dGluZ3Muc2VyaWFsaXplU3BhY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24gd2l0aCB0aGUgZm9ybSBpbnB1dCB2YWx1ZXMsIHdpdGggbG9jYWxpemVkIHZhbHVlcy5cbiAgICAgKiBUaGUgZGVmYXVsdCBvdXRwdXQgZm9ybWF0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgdGhlIG9wdGlvbiBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtTG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgbGV0IG91dHB1dEZvcm1hdFRvVXNlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGZvcmNlZE91dHB1dEZvcm1hdCkpIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gdGhpcy5zZXR0aW5ncy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRGb3JtYXRUb1VzZSA9IGZvcmNlZE91dHB1dEZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVMb2NhbGl6ZWQodGhpcy5mb3JtKCksIHRoaXMuc2V0dGluZ3Muc2VyaWFsaXplU3BhY2VzLCBvdXRwdXRGb3JtYXRUb1VzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIGZvcm0gPGlucHV0PiBlbGVtZW50LlxuICAgICAqIFRob3NlIG9iamVjdHMgYXJlIG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlIGB7IG5hbWU6IGZvbywgdmFsdWU6ICc0MicgfWAsIHdoZXJlIHRoZSBgbmFtZWAgaXMgdGhlIERPTSBlbGVtZW50IG5hbWUsIGFuZCB0aGUgYHZhbHVlYCBpcyBhbiB1bmZvcm1hdHRlZCBudW1lcmljIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmb3JtQXJyYXlOdW1lcmljU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fc2VyaWFsaXplTnVtZXJpY1N0cmluZ0FycmF5KHRoaXMuZm9ybSgpLCB0aGlzLnNldHRpbmdzLnNlcmlhbGl6ZVNwYWNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIGZvcm0gPGlucHV0PiBlbGVtZW50LlxuICAgICAqIFRob3NlIG9iamVjdHMgYXJlIG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlIGB7IG5hbWU6IGZvbywgdmFsdWU6ICc0MicgfWAsIHdoZXJlIHRoZSBgbmFtZWAgaXMgdGhlIERPTSBlbGVtZW50IG5hbWUsIGFuZCB0aGUgYHZhbHVlYCBpcyB0aGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmb3JtQXJyYXlGb3JtYXR0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVGb3JtYXR0ZWRBcnJheSh0aGlzLmZvcm0oKSwgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGFuIG9iamVjdCBmb3IgZWFjaCBmb3JtIDxpbnB1dD4gZWxlbWVudC5cbiAgICAgKiBUaG9zZSBvYmplY3RzIGFyZSBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSBgeyBuYW1lOiBmb28sIHZhbHVlOiAnNDInIH1gLCB3aGVyZSB0aGUgYG5hbWVgIGlzIHRoZSBET00gZWxlbWVudCBuYW1lLCBhbmQgdGhlIGB2YWx1ZWAgaXMgdGhlIGxvY2FsaXplZCBudW1lcmljIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZvcm1BcnJheUxvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsKSB7XG4gICAgICAgIGxldCBvdXRwdXRGb3JtYXRUb1VzZTtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChmb3JjZWRPdXRwdXRGb3JtYXQpKSB7XG4gICAgICAgICAgICBvdXRwdXRGb3JtYXRUb1VzZSA9IHRoaXMuc2V0dGluZ3Mub3V0cHV0Rm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0VG9Vc2UgPSBmb3JjZWRPdXRwdXRGb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fc2VyaWFsaXplTG9jYWxpemVkQXJyYXkodGhpcy5mb3JtKCksIHRoaXMuc2V0dGluZ3Muc2VyaWFsaXplU3BhY2VzLCBvdXRwdXRGb3JtYXRUb1VzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmb3JtIGlucHV0IHZhbHVlcy5cbiAgICAgKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgdGhlIGBmb3JtQXJyYXlOdW1lcmljU3RyaW5nKClgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtSnNvbk51bWVyaWNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmZvcm1BcnJheU51bWVyaWNTdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmb3JtIGlucHV0IHZhbHVlcy5cbiAgICAgKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgdGhlIGBmb3JtQXJyYXlGb3JtYXR0ZWQoKWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1Kc29uRm9ybWF0dGVkKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5mb3JtQXJyYXlGb3JtYXR0ZWQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmb3JtIGlucHV0IHZhbHVlcy5cbiAgICAgKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgdGhlIGBmb3JtQXJyYXlMb2NhbGl6ZWQoKWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBmb3JjZWRPdXRwdXRGb3JtYXQgSWYgc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBgbnVsbGAsIHRoZW4gdGhpcyBpcyB1c2VkIGFzIGFuIG92ZXJyaWRpbmcgb3V0cHV0Rm9ybWF0IG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybUpzb25Mb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5mb3JtQXJyYXlMb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgYWxsIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzIHRoYXQgYXJlIGEgY2hpbGQgb2YgdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudCBvZiB0aGlzIERPTSBlbGVtZW50LCB0byBudW1lcmljIHN0cmluZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtVW5mb3JtYXQoKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuY29uc3RydWN0b3IuX2dldENoaWxkQU5JbnB1dEVsZW1lbnQodGhpcy5mb3JtKCkpO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoaW5wdXQpLnVuZm9ybWF0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZm9ybWF0IGFsbCB0aGUgYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50cyB0aGF0IGFyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQgPGZvcm0+IGVsZW1lbnQgb2YgdGhpcyBET00gZWxlbWVudCwgdG8gbG9jYWxpemVkIHN0cmluZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtVW5mb3JtYXRMb2NhbGl6ZWQoKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuY29uc3RydWN0b3IuX2dldENoaWxkQU5JbnB1dEVsZW1lbnQodGhpcy5mb3JtKCkpO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoaW5wdXQpLnVuZm9ybWF0TG9jYWxpemVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZm9ybWF0IGFsbCB0aGUgYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50cyB0aGF0IGFyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQgPGZvcm0+IGVsZW1lbnQgb2YgdGhpcyBET00gZWxlbWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1SZWZvcm1hdCgpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0Q2hpbGRBTklucHV0RWxlbWVudCh0aGlzLmZvcm0oKSk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLmdldEF1dG9OdW1lcmljRWxlbWVudChpbnB1dCkucmVmb3JtYXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW5wdXQgdmFsdWVzIHRvIG51bWVyaWMgc3RyaW5ncywgc3VibWl0IHRoZSBmb3JtLCB0aGVuIHJlZm9ybWF0IHRob3NlIGJhY2suXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgdGFrZSBhIGNhbGxiYWNrLCBvciBub3QuIElmIGl0IGRvZXNuJ3QsIHRoZSBkZWZhdWx0IGBmb3JtLnN1Ym1pdCgpYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHJ1bnMgYGNhbGxiYWNrKHZhbHVlKWAgd2l0aCBgdmFsdWVgIGJlaW5nIGVxdWFsIHRvIHRoZSByZXN1bHQgb2YgYGZvcm1OdW1lcmljU3RyaW5nKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0TnVtZXJpY1N0cmluZyhjYWxsYmFjayA9IG51bGwpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybVVuZm9ybWF0KCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0oKS5zdWJtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybVJlZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybU51bWVyaWNTdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgdGhlIGZvcm0gd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWVzLlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIHRha2UgYSBjYWxsYmFjaywgb3Igbm90LiBJZiBpdCBkb2Vzbid0LCB0aGUgZGVmYXVsdCBgZm9ybS5zdWJtaXQoKWAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuXG4gICAgICogT3RoZXJ3aXNlLCBpdCBydW5zIGBjYWxsYmFjayh2YWx1ZSlgIHdpdGggYHZhbHVlYCBiZWluZyBlcXVhbCB0byB0aGUgcmVzdWx0IG9mIGBmb3JtRm9ybWF0dGVkKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0Rm9ybWF0dGVkKGNhbGxiYWNrID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtKCkuc3VibWl0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUZvcm1hdHRlZCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGlucHV0IHZhbHVlcyB0byBsb2NhbGl6ZWQgc3RyaW5ncywgc3VibWl0IHRoZSBmb3JtLCB0aGVuIHJlZm9ybWF0IHRob3NlIGJhY2suXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgdGFrZSBhIGNhbGxiYWNrLCBvciBub3QuIElmIGl0IGRvZXNuJ3QsIHRoZSBkZWZhdWx0IGBmb3JtLnN1Ym1pdCgpYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHJ1bnMgYGNhbGxiYWNrKHZhbHVlKWAgd2l0aCBgdmFsdWVgIGJlaW5nIGVxdWFsIHRvIHRoZSByZXN1bHQgb2YgYGZvcm1Mb2NhbGl6ZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBmb3JjZWRPdXRwdXRGb3JtYXQgSWYgc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBgbnVsbGAsIHRoZW4gdGhpcyBpcyB1c2VkIGFzIGFuIG92ZXJyaWRpbmcgb3V0cHV0Rm9ybWF0IG9wdGlvblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdExvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsLCBjYWxsYmFjayA9IG51bGwpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybVVuZm9ybWF0TG9jYWxpemVkKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0oKS5zdWJtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybVJlZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUxvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIG51bWVyaWMgc3RyaW5ncyBmcm9tIHRoZSBgPGlucHV0PmAgZWxlbWVudHMsIGFuZCBwYXNzIGl0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgdGhlIGFycmF5IGlzIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvIGBmb3JtQXJyYXlOdW1lcmljU3RyaW5nKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdEFycmF5TnVtZXJpY1N0cmluZyhjYWxsYmFjaykgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUFycmF5TnVtZXJpY1N0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZXMgZnJvbSB0aGUgYDxpbnB1dD5gIGVsZW1lbnRzLCBhbmQgcGFzcyBpdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICogVW5kZXIgdGhlIGhvb2QsIHRoZSBhcnJheSBpcyBnZW5lcmF0ZWQgdmlhIGEgY2FsbCB0byBgZm9ybUFycmF5Rm9ybWF0dGVkKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdEFycmF5Rm9ybWF0dGVkKGNhbGxiYWNrKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtQXJyYXlGb3JtYXR0ZWQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBsb2NhbGl6ZWQgc3RyaW5ncyBmcm9tIHRoZSBgPGlucHV0PmAgZWxlbWVudHMsIGFuZCBwYXNzIGl0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgdGhlIGFycmF5IGlzIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvIGBmb3JtQXJyYXlMb2NhbGl6ZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1TdWJtaXRBcnJheUxvY2FsaXplZChjYWxsYmFjaywgZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUFycmF5TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBKU09OIHN0cmluZyB3aXRoIHRoZSBudW1lcmljIHN0cmluZ3MgdmFsdWVzIGZyb20gdGhlIGA8aW5wdXQ+YCBlbGVtZW50cywgYW5kIHBhc3MgaXQgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICAqIFVuZGVyIHRoZSBob29kLCB0aGUgYXJyYXkgaXMgZ2VuZXJhdGVkIHZpYSBhIGNhbGwgdG8gYGZvcm1Kc29uTnVtZXJpY1N0cmluZygpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1TdWJtaXRKc29uTnVtZXJpY1N0cmluZyhjYWxsYmFjaykgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUpzb25OdW1lcmljU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBKU09OIHN0cmluZyB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZXMgZnJvbSB0aGUgYDxpbnB1dD5gIGVsZW1lbnRzLCBhbmQgcGFzcyBpdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICogVW5kZXIgdGhlIGhvb2QsIHRoZSBhcnJheSBpcyBnZW5lcmF0ZWQgdmlhIGEgY2FsbCB0byBgZm9ybUpzb25Gb3JtYXR0ZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0SnNvbkZvcm1hdHRlZChjYWxsYmFjaykgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUpzb25Gb3JtYXR0ZWQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIEpTT04gc3RyaW5nIHdpdGggdGhlIGxvY2FsaXplZCBzdHJpbmdzIHZhbHVlcyBmcm9tIHRoZSBgPGlucHV0PmAgZWxlbWVudHMsIGFuZCBwYXNzIGl0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgdGhlIGFycmF5IGlzIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvIGBmb3JtSnNvbkxvY2FsaXplZCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gZm9yY2VkT3V0cHV0Rm9ybWF0IElmIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYG51bGxgLCB0aGVuIHRoaXMgaXMgdXNlZCBhcyBhbiBvdmVycmlkaW5nIG91dHB1dEZvcm1hdCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdEpzb25Mb2NhbGl6ZWQoY2FsbGJhY2ssIGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLmZvcm1Kc29uTG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgdGhlIGdpdmVuIEF1dG9OdW1lcmljIGVsZW1lbnQsIGFuZCB1cGRhdGUgdGhlIGBob3ZlcmVkV2l0aEFsdGAgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljfSBhbkVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfdW5mb3JtYXRBbHRIb3ZlcmVkKGFuRWxlbWVudCkge1xuICAgICAgICBhbkVsZW1lbnQuaG92ZXJlZFdpdGhBbHQgPSB0cnVlO1xuICAgICAgICBhbkVsZW1lbnQudW5mb3JtYXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZvcm1hdCB0aGUgZ2l2ZW4gQXV0b051bWVyaWMgZWxlbWVudCwgYW5kIHVwZGF0ZSB0aGUgYGhvdmVyZWRXaXRoQWx0YCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IGFuRWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9yZWZvcm1hdEFsdEhvdmVyZWQoYW5FbGVtZW50KSB7XG4gICAgICAgIGFuRWxlbWVudC5ob3ZlcmVkV2l0aEFsdCA9IGZhbHNlO1xuICAgICAgICBhbkVsZW1lbnQucmVmb3JtYXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYXV0b051bWVyaWMgZWxlbWVudHMsIGNoaWxkIG9mIHRoZSA8Zm9ybT4gZWxlbWVudCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtTm9kZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0Q2hpbGRBTklucHV0RWxlbWVudChmb3JtTm9kZSkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBjb25zdCBpbnB1dExpc3QgPSBmb3JtTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcblxuICAgICAgICAvLyBMb29wIHRoaXMgbGlzdCBhbmQga2VlcCBvbmx5IHRoZSBpbnB1dHMgdGhhdCBhcmUgbWFuYWdlZCBieSBBdXRvTnVtZXJpY1xuICAgICAgICBjb25zdCBhdXRvTnVtZXJpY0lucHV0cyA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5wdXRMaXN0LCAwKTtcbiAgICAgICAgaW5wdXRFbGVtZW50cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgYXV0b051bWVyaWNJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhdXRvTnVtZXJpY0lucHV0cztcbiAgICB9XG5cbiAgICAvLyBTdGF0aWMgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIGdpdmVuIGRvbUVsZW1lbnQgaXMgYWxyZWFkeSBtYW5hZ2VkIGJ5IEF1dG9OdW1lcmljIChpZiBpdCBoYXMgYmVlbiBpbml0aWFsaXplZCBvbiB0aGUgY3VycmVudCBwYWdlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdChkb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luR2xvYmFsTGlzdChkb21FbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBXZWFrTWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2Vha01hcE5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfY3JlYXRlV2Vha01hcCh3ZWFrTWFwTmFtZSkge1xuICAgICAgICB3aW5kb3dbd2Vha01hcE5hbWVdID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsaXN0IG9mIGFsbCB0aGUgQXV0b051bWVyaWMgZWxlbWVudHMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgb24gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBkZXRlcm1pbmUgaWYgYSBnaXZlbiBkb20gZWxlbWVudCBpcyBhbHJlYWR5IG1hbmFnZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICogVGhpcyB1c2VzIGEgV2Vha01hcCBpbiBvcmRlciB0byBsaW1pdCBwb3RlbnRpYWwgZ2FyYmFnZSBjb2xsZWN0aW9uIHByb2JsZW1zLlxuICAgICAqIChjZi4gbXkgdGVzdHMgb24gaHR0cDovL2NvZGVwZW4uaW8vQW5vdGhlckxpbnV4VXNlci9wZW4vcFJRR2FNP2VkaXRvcnM9MTAxMSlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfY3JlYXRlR2xvYmFsTGlzdCgpIHtcbiAgICAgICAgLy8gVGhlIGNoZWNrIHRoYXQgdGhpcyBnbG9iYWwgbGlzdCBkb2VzIG5vdCBleGlzdHMgYWxyZWFkeSBpcyBkb25lIGluIHRoZSBhZGQgYW5kIHJlbW92ZSBmdW5jdGlvbnMgYWxyZWFkeVxuICAgICAgICB0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWUgPSAnYXV0b051bWVyaWNHbG9iYWxMaXN0JzsgLy9YWFggVGhpcyBsb29rcyB3ZWlyZCB0byBzZXQgYSB2YXJpYWJsZSBvbiBgdGhpcy5gIGluIGEgc3RhdGljIG1ldGhvZCwgYnV0IHRoYXQgcmVhbGx5IGRlY2xhcmUgdGhhdCB2YXJpYWJsZSBsaWtlIGEgc3RhdGljIHByb3BlcnR5XG4gICAgICAgIC8vIE5vdGU6IEkgc2hvdWxkIG5vdCBnZXQgYW55IG1lbW9yeSBsZWFrcyBmb3IgcmVmZXJlbmNpbmcgdGhlIERPTSBlbGVtZW50IGluIHRoZSBgdmFsdWVgLCB0aGlzIERPTSBlbGVtZW50IGFsc28gYmVpbmcgdGhlIGBrZXlgLCBhY2NvcmRpbmcgdG8gdGhlIHNwZWMgOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtd2Vha21hcC1vYmplY3RzXG4gICAgICAgIHRoaXMuX2NyZWF0ZVdlYWtNYXAodGhpcy5hdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnbG9iYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9kb2VzR2xvYmFsTGlzdEV4aXN0cygpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB3aW5kb3dbdGhpcy5hdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lXTtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICB0eXBlID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIG9iamVjdCB0byB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IGF1dG9OdW1lcmljT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2FkZFRvR2xvYmFsTGlzdChhdXRvTnVtZXJpY09iamVjdCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RvZXNHbG9iYWxMaXN0RXhpc3RzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUdsb2JhbExpc3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBhdXRvTnVtZXJpY09iamVjdC5ub2RlKCk7XG4gICAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIHRoZSBvYmplY3QgaXMgbm90IGFscmVhZHkgaW4gdGhlIGdsb2JhbCBsaXN0IGJlZm9yZSBhZGRpbmcgaXQuXG4gICAgICAgIC8vIFRoaXMgY291bGQgaGFwcGVuIGlmIGFuIEF1dG9OdW1lcmljIGVsZW1lbnQgaXMgaW5pdGlhbGl6ZWQsIHRoZW4gdGhlIERPTSBlbGVtZW50IGlzIHJlbW92ZWQgZGlyZWN0bHkgdmlhIGByZW1vdmVDaGlsZGAgKGhlbmNlIHRoZSByZWZlcmVuY2UgZG9lcyBub3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgZ2xvYmFsIGxpc3QpLCB0aGVuIGl0IGdldCByZWNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLl9pc0luR2xvYmFsTGlzdChkb21FbGVtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldEZyb21HbG9iYWxMaXN0KGRvbUVsZW1lbnQpID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGlzIEF1dG9OdW1lcmljIG9iamVjdCBhZ2FpbiBzaW5jZSBpdCdzIGFscmVhZHkgaW4gdGhhdCBnbG9iYWwgbGlzdFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJpbnQgYSB3YXJuaW5nIHRvIHdhcm4gdGhhdCB0aGUgZG9tRWxlbWVudCBhbHJlYWR5IGhhcyBhIHJlZmVyZW5jZSBpbiB0aGUgZ2xvYmFsIG1hcCAoYnV0IHdlIGNhbm5vdCBmb3Igc3VyZSBzdGFydHMgZGVsZXRpbmcgdGhvc2Ugb2xkIHJlZmVyZW5jZXMgc2luY2UgdGhleSBjb3VsZCBzdGlsbCBiZSB1c2VkIGJ5IGFub3RoZXIgQXV0b051bWVyaWMgb2JqZWN0KVxuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYEEgcmVmZXJlbmNlIHRvIHRoZSBET00gZWxlbWVudCB5b3UganVzdCBpbml0aWFsaXplZCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC4gUGxlYXNlIG1ha2Ugc3VyZSB0byBub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBET00gZWxlbWVudCBtdWx0aXBsZSB0aW1lcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLnNldChkb21FbGVtZW50LCBhdXRvTnVtZXJpY09iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IGF1dG9OdW1lcmljT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3JlbW92ZUZyb21HbG9iYWxMaXN0KGF1dG9OdW1lcmljT2JqZWN0KSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGlmICh0aGlzLl9kb2VzR2xvYmFsTGlzdEV4aXN0cygpKSB7XG4gICAgICAgICAgICB3aW5kb3dbdGhpcy5hdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lXS5kZWxldGUoYXV0b051bWVyaWNPYmplY3Qubm9kZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5IGBkb21FbGVtZW50YCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICogVGhlIHZhbHVlIGlzIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoZSBET00gZWxlbWVudCBgZG9tRWxlbWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxBdXRvTnVtZXJpY31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0RnJvbUdsb2JhbExpc3QoZG9tRWxlbWVudCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAodGhpcy5fZG9lc0dsb2JhbExpc3RFeGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLmdldChkb21FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBET00gZWxlbWVudCBpcyBpbiB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9pc0luR2xvYmFsTGlzdChkb21FbGVtZW50KSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGlmICghdGhpcy5fZG9lc0dsb2JhbExpc3RFeGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLmhhcyhkb21FbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgTWFwYCB0aGF0IHdpbGwgc3RvcmVzIGFsbCB0aGUgYXV0b051bWVyaWMgZWxlbWVudHMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgZnJvbSB0aGlzIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVMb2NhbExpc3QoKSB7XG4gICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTG9jYWxMaXN0KHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gc29tZSByYXJlIGNhc2VzLCB5b3UgY291bGQgd2FudCB0byBkZWxldGUgdGhlIGxvY2FsIGxpc3QgZ2VuZXJhdGVkIGR1cmluZyB0aGUgZWxlbWVudCBpbml0aWFsaXphdGlvbiAoaW4gb3JkZXIgdG8gdXNlIGFub3RoZXIgb25lIGluc3RlYWQgZm9yIGluc3RhbmNlKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMb2NhbExpc3QoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbG9jYWwgbGlzdCB3aXRoIHRoZSBnaXZlbiBNYXAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXB9IGxvY2FsTGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExvY2FsTGlzdChsb2NhbExpc3QpIHtcbiAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdCA9IGxvY2FsTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxvY2FsIGxpc3QgTWFwIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfE1hcH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMb2NhbExpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaXMgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgYSBsb2NhbCBsaXN0IGRlZmluZWQgYWxyZWFkeSBhbmQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIGl0IChpdHNlbGYgdXN1YWxseSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYXNMb2NhbExpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0IGluc3RhbmNlb2YgTWFwICYmIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3Quc2l6ZSAhPT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIG9iamVjdCB0byB0aGUgbG9jYWwgYXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAqIE5vdGU6IGluIG9yZGVyIHRvIGtlZXAgYSBjb2hlcmVudCBsaXN0LCB3ZSBvbmx5IGFkZCBET00gZWxlbWVudHMgaW4gaXQsIG5vdCB0aGUgYXV0b051bWVyaWMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY30gYXV0b051bWVyaWNPYmplY3QgQSByZWZlcmVuY2UgdG8gdGhlIEF1dG9OdW1lcmljIG9iamVjdCB0aGF0IG1hbmFnZSB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnRcbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9Mb2NhbExpc3QoZG9tRWxlbWVudCwgYXV0b051bWVyaWNPYmplY3QgPSBudWxsKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoYXV0b051bWVyaWNPYmplY3QpKSB7XG4gICAgICAgICAgICBhdXRvTnVtZXJpY09iamVjdCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LnNldChkb21FbGVtZW50LCBhdXRvTnVtZXJpY09iamVjdCk7IC8vIFVzZSB0aGUgRE9NIGVsZW1lbnQgYXMga2V5LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBhcyB0aGUgdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBsb2NhbCBsaXN0IHByb3ZpZGVkIGRvZXMgbm90IGV4aXN0cyB3aGVuIHRyeWluZyB0byBhZGQgYW4gZWxlbWVudC4gWyR7dGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgbG9jYWwgYXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRnJvbUxvY2FsTGlzdChkb21FbGVtZW50KSB7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQodGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZGVsZXRlKGRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0KSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbG9jYWwgbGlzdCBwcm92aWRlZCBkb2VzIG5vdCBleGlzdHMgd2hlbiB0cnlpbmcgdG8gcmVtb3ZlIGFuIGVsZW1lbnQuIFske3RoaXMuYXV0b051bWVyaWNMb2NhbExpc3R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoZSBgbmV3U2V0dGluZ3NgIGdpdmVuIGFzIHBhcmFtZXRlcnMgaW50byB0aGUgY3VycmVudCBlbGVtZW50IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogV0FSTklORzogVXNpbmcgYE9iamVjdC5hc3NpZ24oKWAgaGVyZSBtZWFucyB0aGUgbWVyZ2UgaXMgbm90IHJlY3Vyc2l2ZSBhbmQgb25seSBvbmUgZGVwdGggaXMgbWVyZ2VkLlxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTE4ODEwOC8yODM0ODk4XG4gICAgICogY2YuIHRlc3RzIG9uIGh0dHA6Ly9jb2RlcGVuLmlvL0Fub3RoZXJMaW51eFVzZXIvcGVuL0thSk9ScT9lZGl0b3JzPTAwMTFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdTZXR0aW5nc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21lcmdlU2V0dGluZ3MoLi4ubmV3U2V0dGluZ3MpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNldHRpbmdzLCAuLi5uZXdTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MgbWVyZ2VkIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdTZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xvbmVBbmRNZXJnZVNldHRpbmdzKC4uLm5ld1NldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy5zZXR0aW5ncywgLi4ubmV3U2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIGB0cnVlYCwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBvcmlnaW5hbE9wdGlvbnMgVGhlIHVzZXIgY2FuIHBhc3MgdGhlIG9yaWdpbmFsIG9wdGlvbnMgKGFuZCBub3QgdGhlIG9uZSB0aGF0IGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBhbmQgdGhlIHZhcmlvdXMgdXNhYmlsaXR5IGNvcnJlY3Rpb25zKSwgaW4gb3JkZXIgdG8gYWRkIGNvbXBhdGliaWxpdHkgYW5kIGNvbmZsaWN0cyBjaGVja3MuXG4gICAgICogQHRocm93cyBFcnJvciBUaGlzIHRocm93cyBpZiB0aGUgYHVzZXJPcHRpb25zYCBhcmUgbm90IHZhbGlkXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUsIG9yaWdpbmFsT3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIUF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNPcmlnaW5hbE9wdGlvbkFuT2JqZWN0ID0gQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3Qob3JpZ2luYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKCFpc09yaWdpbmFsT3B0aW9uQW5PYmplY3QgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcmlnaW5hbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgJ29yaWdpbmFsT3B0aW9ucycgcGFyYW1ldGVyIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIGEgdmFsaWQgb3B0aW9uIG9iamVjdCBvciBcXGBudWxsXFxgLCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udmVydE9sZE9wdGlvbnNUb05ld09uZXModXNlck9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldERlZmF1bHRDb25maWcoKSwgdXNlck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0LCB3ZSB0ZXN0IHRoYXQgdGhlIGBzaG93V2FybmluZ3NgIG9wdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93V2FybmluZ3MpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5zaG93V2FybmluZ3MpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdzaG93V2FybmluZ3MnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dXYXJuaW5nc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyB0ZXN0c1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSAmJlxuICAgICAgICAgICAgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5mbG9hdHMpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FsbG93RGVjaW1hbFBhZGRpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScsICd0cnVlJyBvciAnZmxvYXRzJywgWyR7b3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZyAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgU2V0dGluZyAnYWxsb3dEZWNpbWFsUGFkZGluZycgdG8gW2ZhbHNlXSB3aWxsIG92ZXJyaWRlIHRoZSBjdXJyZW50ICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHNldHRpbmcgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuc3RhcnQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmVuZCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbExlZnQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxSaWdodCxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2NhcmV0UG9zaXRpb25PbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBcXGBudWxsXFxgLCAnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJyBvciAnemVybycsIFske29wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBoZXJlIGZvciBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIGFuZCBgc2VsZWN0T25Gb2N1c2Agd2hlcmUgd2UgbmVlZCB0byBjaGVjayB0aGUgb3JpZ2luYWwgbm9uLXRlbXBlcmVkIHZlcnNpb24gb2YgdGhlIG9wdGlvbnMgaW4gb3JkZXIgdG8gY2hlY2sgZm9yIGNvbmZsaWN0cywgc2luY2UgdXNpbmcgdGhlIGRlZmF1bHQgc2V0dGluZ3MgcmVtb3ZlIHRob3NlIGFuZCB3b3VsZCBwcmV2ZW50IHVzIHdhcm5pbmcgdGhlIHVzZXIgdGhhdCBoaXMgb3B0aW9uIG9iamVjdCBpcyBub3QgY29ycmVjdC5cbiAgICAgICAgbGV0IG9wdGlvbnNUb1VzZTtcbiAgICAgICAgaWYgKGlzT3JpZ2luYWxPcHRpb25Bbk9iamVjdCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gb3JpZ2luYWxPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gdGhpcy5fY29ycmVjdENhcmV0UG9zaXRpb25PbkZvY3VzQW5kU2VsZWN0T25Gb2N1c09wdGlvbnModXNlck9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9uc1RvVXNlKSAmJlxuICAgICAgICAgICAgKChvcHRpb25zVG9Vc2UuY2FyZXRQb3NpdGlvbk9uRm9jdXMgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbiAmJlxuICAgICAgICAgICAgb3B0aW9uc1RvVXNlLnNlbGVjdE9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuc2VsZWN0T25Gb2N1cy5zZWxlY3QpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlICdzZWxlY3RPbkZvY3VzJyBvcHRpb24gaXMgc2V0IHRvICdzZWxlY3QnLCB3aGljaCBpcyBpbiBjb25mbGljdCB3aXRoIHRoZSAnY2FyZXRQb3NpdGlvbk9uRm9jdXMnIHdoaWNoIGlzIHNldCB0byAnJHtvcHRpb25zVG9Vc2UuY2FyZXRQb3NpdGlvbk9uRm9jdXN9Jy4gQXMgYSByZXN1bHQsIGlmIHRoaXMgaGFzIGJlZW4gY2FsbGVkIHdoZW4gaW5zdGFudGlhdGluZyBhbiBBdXRvTnVtZXJpYyBvYmplY3QsIHRoZSAnc2VsZWN0T25Gb2N1cycgb3B0aW9uIGlzIGZvcmNlZCB0byAnZG9Ob3RTZWxlY3QnLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuY29tbWEsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuZG90LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vcm1hbFNwYWNlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLnRoaW5TcGFjZSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5uYXJyb3dOb0JyZWFrU3BhY2UsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3Iubm9CcmVha1NwYWNlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vU2VwYXJhdG9yLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmFwb3N0cm9waGUsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuYXJhYmljVGhvdXNhbmRzU2VwYXJhdG9yLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmRvdEFib3ZlLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcsJywgJy4nLCAn2awnLCAny5knLCBcIidcIiwgJyAnLCAnXFx1MjAwOScsICdcXHUyMDJmJywgJ1xcdTAwYTAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlICdub1NlcGFyYXRvck9uRm9jdXMnIG9wdGlvbiBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkaWdpdGFsIGdyb3VwaW5nIGZvciB0aG91c2FuZCBzZXBhcmF0b3Igb3B0aW9uICdkaWdpdGFsR3JvdXBTcGFjaW5nJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5jb21tYSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIubWlkZGxlRG90LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmFyYWJpY0RlY2ltYWxTZXBhcmF0b3IsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuZGVjaW1hbFNlcGFyYXRvcktleVN5bWJvbCxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJywgJywnLCAnwrcnLCAn4o6WJyBvciAn2asnLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciA9PT0gb3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnZGVjaW1hbENoYXJhY3RlcicgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2RpZ2l0R3JvdXBTZXBhcmF0b3InIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGFsdGVybmF0ZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnY3VycmVuY3lTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2x9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXgsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiBvcHRpb24gJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSwgJ3InIChyaWdodCkgb3IgJ251bGwnLCBbJHtvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93UG9zaXRpdmVTaWduKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbikpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzaG93IHBvc2l0aXZlIHNpZ24gb3B0aW9uICdzaG93UG9zaXRpdmVTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93UG9zaXRpdmVTaWdufV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgKG9wdGlvbnMuc3VmZml4VGV4dCAhPT0gJycgJiYgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuc3VmZml4VGV4dCkpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnc3VmZml4VGV4dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuc3VmZml4VGV4dH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cykgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLmNlaWxpbmcsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLmZsb29yLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cy5pZ25vcmUsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ292ZXJyaWRlTWluTWF4TGltaXRzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnY2VpbGluZycsICdmbG9vcicgb3IgJ2lnbm9yZScsIFske29wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcob3B0aW9ucy5tYXhpbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtYXhpbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhvcHRpb25zLm1pbmltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5taW5pbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21pbmltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLm1pbmltdW1WYWx1ZSkgPiBwYXJzZUZsb2F0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gOyAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgfHxcbiAgICAgICAgICAgIChBdXRvTnVtZXJpY0hlbHBlci5pc0ludChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPj0gMCkgfHwgLy8gSWYgaW50ZWdlciBvcHRpb25cbiAgICAgICAgICAgIChBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkpICAvLyBJZiBzdHJpbmcgb3B0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlIGluIHRoZSBjb25zb2xlIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlIGlzIG92ZXJyaWRkZW4gYnkgZGVjaW1hbFBsYWNlc092ZXJyaWRlIChhbmQgbm90IGlmIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlKVxuICAgICAgICBjb25zdCB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzID0gdGhpcy5fbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChvcHRpb25zLm1pbmltdW1WYWx1ZSwgb3B0aW9ucy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgU2V0dGluZyAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyB0byBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gYW5kICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAoIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGVcIlxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHZhbHVlLiBDdXJyZW50bHksIHRoaXMgd2lsbCBsaW1pdCB0aGUgYWJpbGl0eSBvZiB5b3VyIGNsaWVudCB0byBtYW51YWxseSBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVjaW1hbCBwbGFjZXMuIERvIHlvdSByZWFsbHkgd2FudCB0byBkbyB0aGF0P2AsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykgJiYgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzY2FsZSBudW1iZXIgb2YgZGVjaW1hbHMgb3B0aW9uICdzY2FsZURlY2ltYWxQbGFjZXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5zY2FsZVN5bWJvbCkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuc2NhbGVTeW1ib2wpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc2NhbGUgc3ltYm9sIG9wdGlvbiAnc2NhbGVTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc2NhbGVTeW1ib2x9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5vbkludmFsaWRQYXN0ZSwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcixcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuaWdub3JlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5jbGFtcCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUudHJ1bmNhdGUsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnJlcGxhY2UsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcGFzdGUgYmVoYXZpb3Igb3B0aW9uICdvbkludmFsaWRQYXN0ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2Vycm9yJywgJ2lnbm9yZScsICdjbGFtcCcsICd0cnVuY2F0ZScgb3IgJ3JlcGxhY2UnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMub25JbnZhbGlkUGFzdGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMucm91bmRpbmdNZXRob2QsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZlVwU3ltbWV0cmljLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmVXBBc3ltbWV0cmljLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRG93blN5bW1ldHJpYyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZkRvd25Bc3ltbWV0cmljLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRXZlbkJhbmtlcnNSb3VuZGluZyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudXBSb3VuZEF3YXlGcm9tWmVybyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuZG93blJvdW5kVG93YXJkWmVybyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9DZWlsaW5nVG93YXJkUG9zaXRpdmVJbmZpbml0eSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9GbG9vclRvd2FyZE5lZ2F0aXZlSW5maW5pdHksXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b05lYXJlc3QwNUFsdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudXBUb05leHQwNSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuZG93blRvTmV4dDA1LFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ3JvdW5kaW5nTWV0aG9kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMucm91bmRpbmdNZXRob2R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5wYXJlbnRoZXNlcyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuYnJhY2tldHMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLmNoZXZyb25zLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5jdXJseUJyYWNlcyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuYW5nbGVCcmFja2V0cyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuamFwYW5lc2VRdW90YXRpb25NYXJrcyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuaGFsZkJyYWNrZXRzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci53aGl0ZVNxdWFyZUJyYWNrZXRzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5xdW90YXRpb25NYXJrcyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuZ3VpbGxlbWV0cyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicsICd7LH0nLCAn44CILOOAiScsICfvvaIs772jJywgJ+K4pCziuKUnLCAn4p+mLOKfpycsICfigLks4oC6JyBvciAnwqsswrsnLCBbJHtvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvciwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuZm9jdXMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5wcmVzcyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmFsd2F5cyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLnplcm8sXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICdlbXB0eUlucHV0QmVoYXZpb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybyAmJlxuICAgICAgICAgICAgKG9wdGlvbnMubWluaW11bVZhbHVlID4gMCB8fCBvcHRpb25zLm1heGltdW1WYWx1ZSA8IDApKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgJ2VtcHR5SW5wdXRCZWhhdmlvcicgb3B0aW9uIGlzIHNldCB0byAnemVybycsIGJ1dCB0aGlzIHZhbHVlIGlzIG91dHNpZGUgb2YgdGhlIHJhbmdlIGRlZmluZWQgYnkgJ21pbmltdW1WYWx1ZScgYW5kICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfSwgJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5hbGxvdyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8ua2VlcCxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3Igb3B0aW9uICdsZWFkaW5nWmVybycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2FsbG93JywgJ2RlbnknIG9yICdrZWVwJywgWyR7b3B0aW9ucy5sZWFkaW5nWmVyb31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnZm9ybWF0T25QYWdlTG9hZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZm9ybWF0T25QYWdlTG9hZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5oaXN0b3J5U2l6ZSkgfHwgb3B0aW9ucy5oaXN0b3J5U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGhpc3Rvcnkgc2l6ZSBvcHRpb24gJ2hpc3RvcnlTaXplJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5oaXN0b3J5U2l6ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2VsZWN0T25Gb2N1cykgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLnNlbGVjdE9uRm9jdXMpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG9uIGZvY3VzIG9wdGlvbiAnc2VsZWN0T25Gb2N1cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0T25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdkZWZhdWx0VmFsdWVPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuZm9ybWF0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuZm9ybWF0T25TdWJtaXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMub3V0cHV0Rm9ybWF0KSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMub3V0cHV0Rm9ybWF0LCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5zdHJpbmcsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5udW1iZXIsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5kb3QsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5uZWdhdGl2ZURvdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmNvbW1hLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQubmVnYXRpdmVDb21tYSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmRvdE5lZ2F0aXZlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuY29tbWFOZWdhdGl2ZSxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuaXNDYW5jZWxsYWJsZSkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLmlzQ2FuY2VsbGFibGUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgY2FuY2VsbGFibGUgYmVoYXZpb3Igb3B0aW9uICdpc0NhbmNlbGxhYmxlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5pc0NhbmNlbGxhYmxlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5tb2RpZnlWYWx1ZU9uV2hlZWwpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5tb2RpZnlWYWx1ZU9uV2hlZWwpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgaW5jcmVtZW50L2RlY3JlbWVudCBvbiBtb3VzZSB3aGVlbCBvcHRpb24gJ21vZGlmeVZhbHVlT25XaGVlbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMubW9kaWZ5VmFsdWVPbldoZWVsfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhvcHRpb25zLndoZWVsU3RlcCkgfHwgQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXIob3B0aW9ucy53aGVlbFN0ZXApKSB8fFxuICAgICAgICAgICAgKG9wdGlvbnMud2hlZWxTdGVwICE9PSAncHJvZ3Jlc3NpdmUnICYmICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMud2hlZWxTdGVwKSkgfHxcbiAgICAgICAgICAgIE51bWJlcihvcHRpb25zLndoZWVsU3RlcCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEEgc3RlcCBlcXVhbCB0byAnMCcgaXMgcmVqZWN0ZWRcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB3aGVlbCBzdGVwIHZhbHVlIG9wdGlvbiAnd2hlZWxTdGVwJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSB0aGUgc3RyaW5nICdwcm9ncmVzc2l2ZScsIG9yIGEgbnVtYmVyIG9yIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG51bWJlciAoZXhjbHVkaW5nIHplcm8pLCBbJHtvcHRpb25zLndoZWVsU3RlcH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5zZXJpYWxpemVTcGFjZXMsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuc2VyaWFsaXplU3BhY2VzLnBsdXMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnNlcmlhbGl6ZVNwYWNlcy5wZXJjZW50LFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHNwYWNlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBvcHRpb24gJ3NlcmlhbGl6ZVNwYWNlcycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJysnIG9yICclMjAnLCBbJHtvcHRpb25zLnNlcmlhbGl6ZVNwYWNlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMubm9FdmVudExpc3RlbmVycykgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLm5vRXZlbnRMaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgb3B0aW9uICdub0V2ZW50TGlzdGVuZXJzJyB0aGF0IHByZXZlbnQgdGhlIGNyZWF0aW9uIG9mIGV2ZW50IGxpc3RlbmVycyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5ub0V2ZW50TGlzdGVuZXJzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLnN0eWxlUnVsZXMpICYmXG4gICAgICAgICAgICAhKEF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KG9wdGlvbnMuc3R5bGVSdWxlcykgJiZcbiAgICAgICAgICAgICgob3B0aW9ucy5zdHlsZVJ1bGVzLmhhc093blByb3BlcnR5KCdwb3NpdGl2ZScpIHx8XG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlUnVsZXMuaGFzT3duUHJvcGVydHkoJ25lZ2F0aXZlJykgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVSdWxlcy5oYXNPd25Qcm9wZXJ0eSgncmFuZ2VzJykgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVSdWxlcy5oYXNPd25Qcm9wZXJ0eSgndXNlckRlZmluZWQnKSkpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG9wdGlvbiAnc3R5bGVSdWxlcycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIGNvcnJlY3RseSBzdHJ1Y3R1cmVkIG9iamVjdCwgd2l0aCBvbmUgb3IgbW9yZSAncG9zaXRpdmUnLCAnbmVnYXRpdmUnLCAncmFuZ2VzJyBvciAndXNlckRlZmluZWQnIGF0dHJpYnV0ZXMsIFske29wdGlvbnMuc3R5bGVSdWxlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVlcGVyIHRlc3RzIG9mIHRoZSBgc3R5bGVSdWxlc2Agb2JqZWN0IDogQ2hlY2sgdGhhdCB0aGUgY2FsbGJhY2ssIGlmIGRlZmluZWQsIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5zdHlsZVJ1bGVzKSAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVJ1bGVzLmhhc093blByb3BlcnR5KCd1c2VyRGVmaW5lZCcpICYmXG4gICAgICAgICAgICAhQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuc3R5bGVSdWxlcy51c2VyRGVmaW5lZCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVSdWxlcy51c2VyRGVmaW5lZC5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmhhc093blByb3BlcnR5KCdjYWxsYmFjaycpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKHJ1bGUuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjYWxsYmFjayBkZWZpbmVkIGluIHRoZSBcXGB1c2VyRGVmaW5lZFxcYCBhdHRyaWJ1dGUgaXMgbm90IGEgZnVuY3Rpb24sICR7dHlwZW9mIHJ1bGUuY2FsbGJhY2t9IGdpdmVuLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMucmVhZE9ubHkpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5yZWFkT25seSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvcHRpb24gJ3JlYWRPbmx5JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5yZWFkT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPbkhvdmVyKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMudW5mb3JtYXRPbkhvdmVyKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG9wdGlvbiAndW5mb3JtYXRPbkhvdmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51bmZvcm1hdE9uSG92ZXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZmFpbE9uVW5rbm93bk9wdGlvbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuY3JlYXRlTG9jYWxMaXN0KSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuY3JlYXRlTG9jYWxMaXN0KSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnY3JlYXRlTG9jYWxMaXN0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5jcmVhdGVMb2NhbExpc3R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKG9wdGlvbnMsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIEF1dG9OdW1lcmljLmRlZmF1bHRTZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRoZSBwcmVkZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMgaW4gb25lIG9iamVjdC5cbiAgICAgKiBZb3UgY2FuIGFsc28gYWNjZXNzIGEgc3BlY2lmaWMgbGFuZ3VhZ2Ugb2JqZWN0IGRpcmVjdGx5IGJ5IHVzaW5nIGBBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkZyZW5jaGAgZm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIGdpdmVuIG51bWJlciAob3IgbnVtZXJpYyBzdHJpbmcpIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuIFRoaXMgcmV0dXJucyB0aGUgZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nLlxuICAgICAqIFRoaXMgY2FuIGFsc28gZm9ybWF0IHRoZSBnaXZlIERPTSBlbGVtZW50IHZhbHVlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZy5cbiAgICAgKiBOb3RlIDogVGhpcyBmdW5jdGlvbiBkb2VzIHVwZGF0ZSB0aGF0IGVsZW1lbnQgdmFsdWUgd2l0aCB0aGUgbmV3bHkgZm9ybWF0dGVkIHZhbHVlIGluIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IHZhbHVlT3JEb21FbGVtZW50IEEgbnVtYmVyLCBvciBhIHN0cmluZyB0aGF0IHJlcHJlc2VudCBhIGphdmFzY3JpcHQgbnVtYmVyLCBvciBhIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0KHZhbHVlT3JEb21FbGVtZW50LCBvcHRpb25zID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQodmFsdWVPckRvbUVsZW1lbnQpIHx8IHZhbHVlT3JEb21FbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcodmFsdWVPckRvbUVsZW1lbnQpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcih2YWx1ZU9yRG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB2YWx1ZSBcIiR7dmFsdWVPckRvbUVsZW1lbnR9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWF0ZSBhIHZlcnkgYmFzaWMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXREZWZhdWx0Q29uZmlnKCksIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWVPckRvbUVsZW1lbnQgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWdleCA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncywgcmVnZXgpOyAvLyBUaGlzIGlzIG5lZWRlZCBieSBgX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVyc2AgdGhhdCB1c2VzIHRob3NlIHJlZ2V4XG5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0aGlzLl9tYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlT3JEb21FbGVtZW50YCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWVPckRvbUVsZW1lbnQgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgbGV0IHZhbHVlU3RyaW5nID0gdGhpcy5fdG9OdW1lcmljVmFsdWUodmFsdWVPckRvbUVsZW1lbnQsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWx1ZVN0cmluZykpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGZvcm1hdCBpcyBub3QgYSByZWNvZ25pemVkIG51bWJlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhc2ljIHRlc3RzIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZVN0cmluZyBpcyB2YWxpZFxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSB0aGlzLl9jaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLmZvcm1hdHRlZCwgZG9jdW1lbnQsICdSYW5nZSB0ZXN0IGZhaWxlZCcpO1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rLCBwcm9jZWVkIHRvIHJvdW5kaW5nLCBmb3JtYXR0aW5nIGFuZCBncm91cGluZ1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHRoaXMuX3JvdW5kVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSB0aGlzLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSB0aGlzLl9hZGRHcm91cFNlcGFyYXRvcnModmFsdWVTdHJpbmcsIHNldHRpbmdzLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgdmFsdWUsIGFuZCBzZXQgdGhlIHJlc3VsdGluZyB2YWx1ZSBiYWNrIGFzIHRoZSBlbGVtZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgc3RhdGljIGZvcm1hdEFuZFNldChkb21FbGVtZW50LCBvcHRpb25zID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0KGRvbUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWUoZG9tRWxlbWVudCwgZm9ybWF0dGVkVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmZvcm1hdCB0aGUgZ2l2ZW4gZm9ybWF0dGVkIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLiBUaGlzIHJldHVybnMgYSBudW1lcmljIHN0cmluZy5cbiAgICAgKiBJdCBjYW4gYWxzbyB1bmZvcm1hdCB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgbnVtZXJpYyBzdHJpbmcuXG4gICAgICogTm90ZTogVGhpcyBkb2VzICpub3QqIHVwZGF0ZSB0aGF0IGVsZW1lbnQgdmFsdWUuXG4gICAgICogVGhpcyBiYXNpY2FsbHkgYWxsb3dzIHRvIGdldCB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgd2l0aG91dCBmaXJzdCBoYXZpbmcgdG8gaW5pdGlhbGl6ZSBhbiBBdXRvTnVtZXJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gbnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IG9wdGlvbnMgTXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkLCB0aGUgbGF0dGVyIG92ZXJ3cml0aW5nIHRoZSBzZXR0aW5ncyBmcm9tIHRoZSBmb3JtZXIgb25lc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmZvcm1hdChudW1lcmljU3RyaW5nT3JEb21FbGVtZW50LCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlclN0cmljdChudW1lcmljU3RyaW5nT3JEb21FbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gR2l2aW5nIGFuIHVuZm9ybWF0dGVkIHZhbHVlIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgdW5mb3JtYXR0ZWQgdmFsdWUsIHdoYXRldmVyIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQobnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBudW1lcmljU3RyaW5nT3JEb21FbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheSh2YWx1ZSkgfHwgQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBBIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gdW5mb3JtYXQgaXQsIFske3ZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0aW9uc1RvVXNlID0ge307XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucykgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnNUb1VzZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zVG9Vc2UsIG9wdGlvbk9iamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXREZWZhdWx0Q29uZmlnKCksIG9wdGlvbnNUb1VzZSk7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGhpcy5fbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIGEgbmVnYXRpdmUgc2lnbiBpcyBhbnl3aGVyZSBpbiB0aGUgYHZhbHVlYCwgbm90IGp1c3Qgb24gdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIChpZS4gJzEyMzQ1LjY3LScpXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIpKSB7XG4gICAgICAgICAgICBbc2V0dGluZ3MuZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5sYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3MuZmlyc3RCcmFja2V0ICYmXG4gICAgICAgICAgICAgICAgdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpID09PSBzZXR0aW5ncy5sYXN0QnJhY2tldCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3JlbW92ZUJyYWNrZXRzKHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jb252ZXJ0VG9OdW1lcmljU3RyaW5nKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IHVud2FudGVkQ2hhcmFjdGVycyA9IG5ldyBSZWdFeHAoYFteKy0wMTIzNDU2Nzg5Ll1gLCAnZ2knKTtcbiAgICAgICAgaWYgKHVud2FudGVkQ2hhcmFjdGVycy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdGhpcy5fcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTsgLy8gSGVyZSB3ZSBuZWVkIHRvIGNvbnZlcnQgYmFjayB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gYSBwZXJpb2Qgc2luY2UgYF9yb3VuZFZhbHVlYCBhZGRzIGl0IGluIHNvbWUgY2FzZXNcbiAgICAgICAgdmFsdWUgPSB0aGlzLl90b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0Rm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgdGhlIGdpdmVuIERPTSBlbGVtZW50IHZhbHVlLCBhbmQgc2V0IHRoZSByZXN1bHRpbmcgdmFsdWUgYmFjayBhcyB0aGUgZWxlbWVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHVuZm9ybWF0QW5kU2V0KGRvbUVsZW1lbnQsIG9wdGlvbnMgPSBudWxsKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGNvbnN0IHVuZm9ybWF0dGVkVmFsdWUgPSB0aGlzLnVuZm9ybWF0KGRvbUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWUoZG9tRWxlbWVudCwgdW5mb3JtYXR0ZWRWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgYW5kIGxvY2FsaXplIHRoZSBnaXZlbiBmb3JtYXR0ZWQgc3RyaW5nIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuIFRoaXMgcmV0dXJucyBhIG51bWVyaWMgc3RyaW5nLlxuICAgICAqIEl0IGNhbiBhbHNvIHVuZm9ybWF0IGFuZCBsb2NhbGl6ZSB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgbnVtZXJpYyBzdHJpbmcuXG4gICAgICogTm90ZTogVGhpcyBkb2VzICpub3QqIHVwZGF0ZSB0aGF0IGVsZW1lbnQgdmFsdWUuXG4gICAgICogVGhpcyBiYXNpY2FsbHkgYWxsb3dzIHRvIGdldCB0aGUgbG9jYWxpemVkIHZhbHVlIHdpdGhvdXQgZmlyc3QgaGF2aW5nIHRvIGluaXRpYWxpemUgYW4gQXV0b051bWVyaWMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2NhbGl6ZShudW1lcmljU3RyaW5nT3JEb21FbGVtZW50LCBvcHRpb25zID0gbnVsbCkge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQobnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBudW1lcmljU3RyaW5nT3JEb21FbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IEF1dG9OdW1lcmljLmRlZmF1bHRTZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdGhpcy51bmZvcm1hdCh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy9YWFggVGhlIGZvbGxvd2luZyBjb2RlIGlzIHByZXR0eSBjbG9zZSB0byB0aGUgb25lIHlvdSBjYW4gZmluZCBpbiBgZ2V0TG9jYWxpemVkKClgLCBidXQgZGlmZmVyZW50IGVub3VnaCBzbyB3ZSB3b24ndCByZWZhY3RvciBpdC5cbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgb3B0aW9ucy5sZWFkaW5nWmVybyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdXRwdXRGb3JtYXRUb1VzZTtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0VG9Vc2UgPSBvcHRpb25zLm91dHB1dEZvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gQXV0b051bWVyaWMuZGVmYXVsdFNldHRpbmdzLm91dHB1dEZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90b0xvY2FsZSh2YWx1ZSwgb3V0cHV0Rm9ybWF0VG9Vc2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2NhbGl6ZUFuZFNldChkb21FbGVtZW50LCBvcHRpb25zID0gbnVsbCkgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICBjb25zdCBsb2NhbGl6ZWRWYWx1ZSA9IHRoaXMubG9jYWxpemUoZG9tRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZShkb21FbGVtZW50LCBsb2NhbGl6ZWRWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsaXplZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaXMgdGhlIGdpdmVuIERPTSBlbGVtZW50IGhhcyBhbiBBdXRvTnVtZXJpYyBvYmplY3QgdGhhdCBtYW5hZ2VzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc01hbmFnZWRCeUF1dG9OdW1lcmljKGRvbUVsZW1lbnQpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5HbG9iYWxMaXN0KGRvbUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgQXV0b051bWVyaWMgb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHJldHVybnMge251bGx8QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc3RhdGljIGdldEF1dG9OdW1lcmljRWxlbWVudChkb21FbGVtZW50KSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGlmICghdGhpcy5pc01hbmFnZWRCeUF1dG9OdW1lcmljKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGcm9tR2xvYmFsTGlzdChkb21FbGVtZW50KTtcbiAgICB9XG5cblxuICAgIC8vIFByZS1kZWZpbmVkIG9wdGlvbnMgY2FuIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhlIGN1cnJlbnQgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlaXIgc3BlY2lmaWNpdGllc1xuICAgIC8vWFhYIEEgYmV0dGVyIHdheSB3b3VsZCBiZSB0byBub3QgaW5pdGlhbGl6ZSBmaXJzdCwgYnV0IHRoYXQncyBub3QgcG9zc2libGUgc2luY2UgYG5ld2AgaXMgY2FsbGVkIGZpcnN0IGFuZCB3ZSBkbyBub3QgcGFzcyB0aGUgbGFuZ3VhZ2Ugb3B0aW9ucyAoaWUuIGBGcmVuY2hgKSB0byB0aGUgY29uc3RydWN0b3JcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgQXV0b051bWVyaWMgb2JqZWN0IHdpdGggdGhlIHByZWRlZmluZWQgb3B0aW9ucywgYW5kIHBvc3NpYmx5IHNvbWUgb3B0aW9uIG92ZXJyaWRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcmVkZWZpbmVkT3B0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKHByZWRlZmluZWRPcHRpb24sIG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25PdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlU2V0dGluZ3MocHJlZGVmaW5lZE9wdGlvbiwgb3B0aW9uT3ZlcnJpZGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShwcmVkZWZpbmVkT3B0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBGcmVuY2ggcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmcmVuY2gob3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKEF1dG9OdW1lcmljLmdldFByZWRlZmluZWRPcHRpb25zKCkuRnJlbmNoLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5ncyB0byB1c2UgdGhlIE5vcnRoIEFtZXJpY2FuIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgbm9ydGhBbWVyaWNhbihvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMoQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5Ob3J0aEFtZXJpY2FuLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5ncyB0byB1c2UgdGhlIEJyaXRpc2ggcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBicml0aXNoKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkJyaXRpc2gsIG9wdGlvbk92ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmdzIHRvIHVzZSB0aGUgU3dpc3MgcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzd2lzcyhvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMoQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5Td2lzcywgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBKYXBhbmVzZSBwcmUtZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zLlxuICAgICAqIFRob3NlIHByZS1kZWZpbmVkIG9wdGlvbnMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhbiBvcHRpb24gb2JqZWN0IGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGphcGFuZXNlKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkphcGFuZXNlLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5ncyB0byB1c2UgdGhlIFNwYW5pc2ggcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzcGFuaXNoKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLlNwYW5pc2gsIG9wdGlvbk92ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmdzIHRvIHVzZSB0aGUgQ2hpbmVzZSBwcmUtZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zLlxuICAgICAqIFRob3NlIHByZS1kZWZpbmVkIG9wdGlvbnMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhbiBvcHRpb24gb2JqZWN0IGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGNoaW5lc2Uob3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKEF1dG9OdW1lcmljLmdldFByZWRlZmluZWRPcHRpb25zKCkuQ2hpbmVzZSwgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBCcmF6aWxpYW4gcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBicmF6aWxpYW4ob3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKEF1dG9OdW1lcmljLmdldFByZWRlZmluZWRPcHRpb25zKCkuQnJhemlsaWFuLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvLyBJbnRlcm5hbCBwcml2YXRlIGZ1bmN0aW9uc1xuICAgIC8qKlxuICAgICAqIFJ1biBhbnkgY2FsbGJhY2tzIGZvdW5kIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgaW4gb3JkZXIgdG8gc2V0IHRoZSBzZXR0aW5ncyB2YWx1ZSBiYWNrLlxuICAgICAqIEFueSBwYXJhbWV0ZXIgY2FuIGhhdmUgYSBjYWxsYmFjayBkZWZpbmVkLlxuICAgICAqIFRoZSBjYWxsYmFjayB0YWtlcyB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBlbGVtZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgYW5kIHRoZSBrZXkgbmFtZSBhcyB0aGUgc2Vjb25kLlxuICAgICAqIEBleGFtcGxlIGNhbGxiYWNrKHRoaXMsICdjdXJyZW5jeVN5bWJvbCcpXG4gICAgICovXG4gICAgX3J1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgdGhpcy5zZXR0aW5ncyBvYmplY3QgKG9wdGlvbiBhcnJheSkgdG8gZmluZCB0aGUgZm9sbG93aW5nXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2V0dGluZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWUodGhpcywga2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YS4gRm9yIGluc3RhbmNlOiA8dGFnIGRhdGEtY3VycmVuY3ktc3ltYm9sPVwiZnVuY3Rpb25OYW1lXCI+PC90YWc+XG4gICAgICAgICAgICAgICAgICAgIGxldCBodG1sQXR0cmlidXRlID0gdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpOyAvL1RPRE8gVXNlIGBkYXRhc2V0YCBpbnN0ZWFkIG9mIGBnZXRBdHRyaWJ1dGVgIHdoZW4gd2Ugd29uJ3QgbmVlZCB0byBzdXBwb3J0IG9ic29sZXRlIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyaWJ1dGUgPSBBdXRvTnVtZXJpY0hlbHBlci5jYW1lbGl6ZShodG1sQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNldHRpbmdzW2h0bWxBdHRyaWJ1dGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzW2tleV0gPSBodG1sQXR0cmlidXRlKHRoaXMsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIG1heGltdW0gZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtaW5pbXVtVmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF4aW11bVZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX21heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgobWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KEF1dG9OdW1lcmljSGVscGVyLmRlY2ltYWxQbGFjZXMobWluaW11bVZhbHVlKSwgQXV0b051bWVyaWNIZWxwZXIuZGVjaW1hbFBsYWNlcyhtYXhpbXVtVmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIGlmIHRoZSBzZXR0aW5ncyBjb25maWd1cmF0aW9uIGxlYWRzIHRvIGEgdHJhaWxpbmcgbmVnYXRpdmUgc2lnbiAob25seSB3aGVuIHRoZSByYXcgdmFsdWUgaXMgbmVnYXRpdmUpLCBzbyB3ZSBkbyBub3QgaGF2ZSB0byB0ZXN0IHRoZSBzZXR0aW5ncyB2YWx1ZXMgZXZlcnkgdGltZSB3ZSBuZWVkIHRvIGtub3cgdGhhdC5cbiAgICAgKiBgaXNUcmFpbGluZ05lZ2F0aXZlYCBpcyBzZXQgdG8gYHRydWVgIGlmIHRoZSBzZXR0aW5ncyByZXN1bHQgaW4gYSB0cmFpbGluZyBuZWdhdGl2ZSBjaGFyYWN0ZXIsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIE5vdGU6IFRoaXMgcmV0dXJucyBgdHJ1ZWAgZXZlbiBpZiB0aGUgcmF3IHZhbHVlIGlzIHBvc2l0aXZlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFRyYWlsaW5nTmVnYXRpdmVTaWduSW5mbygpIHtcbiAgICAgICAgdGhpcy5pc1RyYWlsaW5nTmVnYXRpdmUgPSAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXggJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXgpIHx8XG4gICAgICAgICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCAmJlxuICAgICAgICAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0IHx8IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBhbGwgdW53YW50ZWQgbm9uLW51bWJlciBjaGFyYWN0ZXJzLlxuICAgICAqIFRoaXMga2VlcHMgdGhlIG51bWJlcnMsIHRoZSBuZWdhdGl2ZSBzaWduIGFzIHdlbGwgYXMgdGhlIGN1c3RvbSBkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdHJpcFplcm9zIElmIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBsZWFkaW5nIHplcm8ocykgYXJlIG5vdCBzdHJpcHBlZCwgb3RoZXJ3aXNlIGlmIHNldCB0byBgdHJ1ZWAsIHRoZSBgbGVhZGluZ1plcm9gIG9wdGlvbiBpcyBmb2xsb3dlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGb2N1c2VkIElmIHRoZSBlbGVtZW50IGlzIGZvY3VzZWQsIHRoZW4gdGhpcyBpcyBgdHJ1ZWBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XG4gICAgICovXG4gICAgc3RhdGljIF9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocywgc2V0dGluZ3MsIHN0cmlwWmVyb3MsIGlzRm9jdXNlZCkge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICAvL1RPRE8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgMTAgdGltZXMgKHNpYyEpIG9uIGVhY2gga2V5IGlucHV0LCBjb3VsZG4ndCB3ZSBsb3dlciB0aGF0IG51bWJlcj8gY2YuIGlzc3VlICMzMjVcbiAgICAgICAgLy9UT0RPIFJlZmFjdG9yIHRoaXMgd2l0aCBgY29udmVydFRvTnVtZXJpY1N0cmluZygpYCBpZiBwb3NzaWJsZT9cbiAgICAgICAgcyA9IFN0cmluZyhzKTsgLy8gVHlwZWNhc3QgdG8gdG8gYSBzdHJpbmcsIGluIGNhc2UgdGhhdCB0aGUgaW5pdGlhbFZhbHVlIGlzIGEgbnVtYmVyXG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3VmZml4XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN1ZmZpeFRleHQsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBSZW1vdmUgdGhlIHBvc2l0aXZlIHNpZ24gdG9vP1xuXG4gICAgICAgIC8vIEZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcblxuICAgICAgICAvLyBUaGVuIHJlcGxhY2UgYW55dGhpbmcgYWZ0ZXIgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAsICckMScpO1xuXG4gICAgICAgIC8vIFRoZW4gcmVtb3ZlIGFueSB1bmludGVyZXN0aW5nIGNoYXJhY3RlcnNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBvbmx5IG51bWJlciBzdHJpbmdcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcbiAgICAgICAgcyA9IG0gPyBbbVsxXSwgbVsyXSwgbVszXV0uam9pbignJykgOiAnJztcblxuICAgICAgICBpZiAoc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uYWxsb3cgfHwgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8ua2VlcCkge1xuICAgICAgICAgICAgbGV0IG5lZ2F0aXZlU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVTaWduID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAobmVnYXRpdmVTaWduID09PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnRQb3MgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5lZ2F0aXZlU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyA9IGAke25lZ2F0aXZlU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHN0cmlwWmVyb3MgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSkgfHxcbiAgICAgICAgICAgICghaXNGb2N1c2VkICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmFsbG93KSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdHJpcFJlZywgJyQxJDInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgZm9jdXMgc3RhdGUsIHdoaWNoIGlzIHBhc3NlZCBhcyBgaXNGb2N1c2VkYC5cbiAgICAgKiBUaGUgZm9jdXMgc3RhdGUgaXMgJ3N0b3JlZCcgaW4gdGhhdCBvYmplY3QgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncywgaXNGb2N1c2VkKSB7XG4gICAgICAgIC8vWFhYIE5vdGU7IHRoaXMgZnVuY3Rpb24gaXMgc3RhdGljIHNpbmNlIHdlIG5lZWQgdG8gcGFzcyBhIGBzZXR0aW5nc2Agb2JqZWN0IHdoZW4gY2FsbGluZyB0aGUgc3RhdGljIGBBdXRvTnVtZXJpYy5mb3JtYXQoKWAgbWV0aG9kXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3JlbW92ZUJyYWNrZXRzKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9hZGRCcmFja2V0cyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGJyYWNrZXQgdHlwZXMgc3BlY2lmaWVkIGluIHRoZSBgc2V0dGluZ3NgIG9iamVjdCwgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkQnJhY2tldHModmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYCR7c2V0dGluZ3MuZmlyc3RCcmFja2V0fSR7dmFsdWUucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKX0ke3NldHRpbmdzLmxhc3RCcmFja2V0fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBicmFja2V0IHR5cGVzIHNwZWNpZmllZCBpbiB0aGUgYHNldHRpbmdzYCBvYmplY3QsIGZyb20gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWFycmFuZ2VTaWduc0FuZFZhbHVlT3JkZXIgSWYgc2V0IHRvIGB0cnVlYCwgdGhlbiBvbmx5IHRoZSBicmFja2V0cyBhcmUgcmVtb3ZlIGFuZCBhIG5lZ2F0aXZlIHNpZ24gaXMgYWRkZWQsIHdpdGhvdXQgcmVvcmRlcmluZyB0aGUgbmVnYXRpdmUgc2lnbiwgY3VycmVuY3kgc3ltYm9sIGFuZCB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHNldHRpbmdzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3JlbW92ZUJyYWNrZXRzKHZhbHVlLCBzZXR0aW5ncywgcmVhcnJhbmdlU2lnbnNBbmRWYWx1ZU9yZGVyID0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5ncy5maXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnJhY2tldHMgaWYgdGhleSBhcmUgcHJlc2VudFxuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZShzZXR0aW5ncy5maXJzdEJyYWNrZXQsICcnKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHNldHRpbmdzLmxhc3RCcmFja2V0LCAnJyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGF0IHRoZSByaWdodCBwbGFjZVxuICAgICAgICAgICAgaWYgKHJlYXJyYW5nZVNpZ25zQW5kVmFsdWVPcmRlcikge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjdXJyZW5jeSBzeW1ib2wgZnJvbSB0aGUgdmFsdWUsIHNpbmNlIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBhZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBhdCB0aGUgcmlnaHQgcGxhY2UgKGluY2x1ZGluZyBiZXR3ZWVuIHRoZSB2YWx1ZSBhbmQgdGhlIGN1cnJlbmN5IHNpZ24pXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tZXJnZUN1cnJlbmN5U2lnbk5lZ2F0aXZlUG9zaXRpdmVTaWduQW5kVmFsdWUocmVzdWx0LCBzZXR0aW5ncywgdHJ1ZSwgZmFsc2UpOyAvL1RPRE8gVGhpcyBhc3N1bWUgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlIGFuZCBub24tZW1wdHkuIElzIHRoaXMgYWx3YXlzIHRoZSBjYXNlP1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIG9ubHkgd2FudCB0byBhZGQgdGhlIG5lZ2F0aXZlIHNpZ24gc2luY2Ugd2UgcmVtb3ZlZCB0aGUgYnJhY2tldHMsIHdpdGhvdXQgcmVvcmRlcmluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICctJyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXplIHRoZSBgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXJgIG9wdGlvbnMgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IGJyYWNrZXQgY2hhcmFjdGVycyB0byB1c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0QnJhY2tldHMoKSB7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIpKSB7XG4gICAgICAgICAgICBbdGhpcy5zZXR0aW5ncy5maXJzdEJyYWNrZXQsIHRoaXMuc2V0dGluZ3MubGFzdEJyYWNrZXRdID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5zcGxpdCgnLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5maXJzdEJyYWNrZXQgPSAnJztcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubGFzdEJyYWNrZXQgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG51bWJlciBhcyBhIG51bWVyaWMgc3RyaW5nIHRoYXQgY2FuIGJlIHR5cGVjYXN0IHRvIGEgTnVtYmVyIHRoYXQgSmF2YXNjcmlwdCB3aWxsIHVuZGVyc3RhbmQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybiB0aGUgZ2l2ZW4gc3RyaW5nIGJ5IHN0cmlwcGluZyB0aGUgY3VycmVuY3kgc2lnbiAoY3VycmVuY3lTeW1ib2wpLCB0aGUgZ3JvdXBpbmcgc2VwYXJhdG9ycyAoZGlnaXRhbEdyb3VwU3BhY2luZykgYW5kIGJ5IHJlcGxhY2luZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgKGRlY2ltYWxDaGFyYWN0ZXIpIGJ5IGEgZG90LlxuICAgICAqIExhc3RseSwgaXQgYWxzbyBwdXQgdGhlIG5lZ2F0aXZlIHNpZ24gYmFjayB0byBpdHMgbm9ybWFsIHBvc2l0aW9uIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfY29udmVydFRvTnVtZXJpY1N0cmluZyhzLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbmN5IHN5bWJvbFxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBncm91cGluZyBzZXBhcmF0b3JzICh0aG91c2FuZHMgc2VwYXJhdG9ycyB1c3VhbGx5KVxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsICcnKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBieSBhIGRvdFxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHN1ZmZpeFRleHRcbiAgICAgICAgaWYgKHNldHRpbmdzLnN1ZmZpeFRleHQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuc3VmZml4VGV4dC5ub25lKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN1ZmZpeFRleHQsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlIHNpZ24gdG8gdGhlIHJpZ2h0IHBvc2l0aW9uLCBpZiBhbnlcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUocykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgYXJhYmljIG51bWJlcnMgdG8gbGF0aW4gb25lcywgaWYgYW55XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb051bWJlciA9IHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmtlZXA7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBBdXRvTnVtZXJpY0hlbHBlci5hcmFiaWNUb0xhdGluTnVtYmVycyhzLCBjb252ZXJ0VG9OdW1iZXIsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGlmICghaXNOYU4odGVtcCkpIHtcbiAgICAgICAgICAgIHMgPSB0ZW1wLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnQuXG4gICAgICogU2VlIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGxvY2FsZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGxvY2FsZSkgfHwgbG9jYWxlID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5zdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAobG9jYWxlKSB7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm51bWJlcjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5kb3ROZWdhdGl2ZTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuY29tbWE6XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm5lZ2F0aXZlQ29tbWE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmNvbW1hTmVnYXRpdmU6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShyZXN1bHQpID8gcmVzdWx0LnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjYXNlXG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmRvdDpcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQubmVnYXRpdmVEb3Q6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gb3V0cHV0Rm9ybWF0IFske2xvY2FsZX1dIG9wdGlvbiBpcyBub3QgcmVjb2duaXplZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgb2YgdGhlIGdpdmVuIHN0cmluZyB2YWx1ZSB0byBhbiBoeXBoZW4gKC0pIGFuZCBhIGRvdCAoLikgaW4gb3JkZXIgdG8gbWFrZSB0aGF0IHZhbHVlICd0eXBlY2FzdGFibGUnIHRvIGEgcmVhbCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgX21vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZShzKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSh0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICctJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSBgZ2V0YCBpcyBub3QgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcbiAgICAgICAgICAgIHMgKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gdXNlIHRob3NlIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBfbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vWFhYIE5vdGU7IHRoaXMgZnVuY3Rpb24gaXMgc3RhdGljIHNpbmNlIHdlIG5lZWQgdG8gcGFzcyBhIGBzZXR0aW5nc2Agb2JqZWN0IHdoZW4gY2FsbGluZyB0aGUgc3RhdGljIGBBdXRvTnVtZXJpYy5mb3JtYXQoKWAgbWV0aG9kXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGVtcHR5IG9yIGlzIGVxdWFsIHRvIHRoZSBuZWdhdGl2ZSBzaWduIGNoYXJhY3RlciBkZWZpbmVkIGluIHRoZSBnaXZlbiBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9pc0VsZW1lbnRWYWx1ZUVtcHR5T3JPbmx5VGhlTmVnYXRpdmVTaWduKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW5jeSBzeW1ib2wgYW5kIHRoZSBzdWZmaXggdGV4dCBvcmRlcmVkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX29yZGVyVmFsdWVDdXJyZW5jeVN5bWJvbEFuZFN1ZmZpeFRleHQodmFsdWUsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5hbHdheXMgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgdmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgaW5wdXQgdmFsdWUgYnkgYWRkaW5nIHRoZSBncm91cCBzZXBhcmF0b3JzLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bnVsbH0gcmF3VmFsdWUgSWYgdGhpcyBpcyBzZXQsIHRoZW4gdGhpcyByYXdWYWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9uZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHNldHRpbmdzYCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIGlzIHNvbWUgdmVyeSBzcGVjaWZpYyBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvIHNldCB0aGUgcmF3IHZhbHVlICphZnRlciogc2V0dGluZ3MgdGhlIGZvcm1hdHRlZCB2YWx1ZSwgdXNpbmcgdGhlIGBfYWRkR3JvdXBTZXBhcmF0b3JzKClgIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2FkZEdyb3VwU2VwYXJhdG9ycyhpbnB1dFZhbHVlLCBzZXR0aW5ncywgaXNGb2N1c2VkLCByYXdWYWx1ZSA9IG51bGwpIHtcbiAgICAgICAgLy9YWFggTm90ZTsgdGhpcyBmdW5jdGlvbiBpcyBzdGF0aWMgc2luY2Ugd2UgbmVlZCB0byBwYXNzIGEgYHNldHRpbmdzYCBvYmplY3Qgd2hlbiBjYWxsaW5nIHRoZSBzdGF0aWMgYEF1dG9OdW1lcmljLmZvcm1hdCgpYCBtZXRob2RcbiAgICAgICAgY29uc3QgaXNWYWx1ZU5lZ2F0aXZlID0gQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShpbnB1dFZhbHVlKSB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlV2l0aEJyYWNrZXRzKGlucHV0VmFsdWUsIHNldHRpbmdzLmZpcnN0QnJhY2tldCwgc2V0dGluZ3MubGFzdEJyYWNrZXQpOyAvLyBUZXN0IGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZSBiZWZvcmUgcmVtb3ZpbmcgdGhlIG5lZ2F0aXZlIHNpZ25cblxuICAgICAgICBpbnB1dFZhbHVlID0gdGhpcy5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGlucHV0VmFsdWUsIHNldHRpbmdzLCBmYWxzZSwgaXNGb2N1c2VkKTtcblxuICAgICAgICBpZiAodGhpcy5faXNFbGVtZW50VmFsdWVFbXB0eU9yT25seVRoZU5lZ2F0aXZlU2lnbihpbnB1dFZhbHVlLCBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRlclZhbHVlQ3VycmVuY3lTeW1ib2xBbmRTdWZmaXhUZXh0KGlucHV0VmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzWmVyb09ySGFzTm9WYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmlzWmVyb09ySGFzTm9WYWx1ZShpbnB1dFZhbHVlKTtcblxuICAgICAgICAvLyBUZW1wb3JhcmlseSByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgcHJlc2VudFxuICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZyA9IHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cDtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nKSB7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZy50d286XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nLnR3b1NjYWxlZDpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nLmZvdXI6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZy50aHJlZTpcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcn0kMmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAhPT0gMCAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSm9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgaXQncyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUvcG9zaXRpdmUgc2lnbiBhbmQgdGhlIGN1cnJlbmN5IHN5bWJvbCwgYXQgdGhlIHJpZ2h0IHBvc2l0aW9uc1xuICAgICAgICBpbnB1dFZhbHVlID0gQXV0b051bWVyaWMuX21lcmdlQ3VycmVuY3lTaWduTmVnYXRpdmVQb3NpdGl2ZVNpZ25BbmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncywgaXNWYWx1ZU5lZ2F0aXZlLCBpc1plcm9Pckhhc05vVmFsdWUpOyAvL1RPRE8gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWdhaW4gaW4gYF90b2dnbGVOZWdhdGl2ZUJyYWNrZXRgIGlmIHRoZSBicmFja2V0cyBhcmUgcmVtb3ZlZDsgbGV0J3MgRFJZIHRoaXNcbiAgICAgICAgXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwocmF3VmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmF3IHZhbHVlIGlzIG5vdCBmb3JjZWQsIHVzZSB0aGUgZGVmYXVsdCBvbmUgZnJvbSB0aGUgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICByYXdWYWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBuZWdhdGl2ZSBzaWduIGFuZCBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgKHJhd1ZhbHVlIDwgMCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRoaXMuX3RvZ2dsZU5lZ2F0aXZlQnJhY2tldChpbnB1dFZhbHVlLCBzZXR0aW5ncywgaXNGb2N1c2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHNlbWktZm9ybWF0dGVkIHN0cmluZyB3aGVyZSB0aGUgaW5wdXQgdmFsdWUsIHRoZSBuZWdhdGl2ZSBvciBwb3NpdGl2ZSBzaWduLCBhbmQgdGhlIGN1cnJlbmN5IHN5bWJvbCBhcmUgc3RpdGNoZWQgdG9nZXRoZXIgYXQgdGhlIHJpZ2h0IHBvc2l0aW9ucywgdXNpbmcgdGhlIG9wdGlvbnMgc2V0IGluIHRoZSBgc2V0dGluZ3NgIG9iamVjdC5cbiAgICAgKiBOb3RlIDogdGhlIGBpbnB1dFZhbHVlYCBpcyB1c3VhbGx5IG5vdCBhIG51bWVyaWMgc3RyaW5nIHNpbmNlIHRoZSBncm91cGluZyBzeW1ib2xzIGFyZSBhbHJlYWR5IGFkZGVkIHRvIGl0IGF0IHRoaXMgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWx1ZU5lZ2F0aXZlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1plcm9Pckhhc05vVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX21lcmdlQ3VycmVuY3lTaWduTmVnYXRpdmVQb3NpdGl2ZVNpZ25BbmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncywgaXNWYWx1ZU5lZ2F0aXZlLCBpc1plcm9Pckhhc05vVmFsdWUpIHtcbiAgICAgICAgbGV0IHNpZ25Ub1VzZSA9ICcnO1xuICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBzaWduVG9Vc2UgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSB7XG4gICAgICAgICAgICBzaWduVG9Vc2UgPSBzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4KSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSAmJlxuICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7c2lnblRvVXNlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzaWduVG9Vc2V9JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX0ke3NpZ25Ub1VzZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSAmJlxuICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NpZ25Ub1VzZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7aW5wdXRWYWx1ZX0ke3NpZ25Ub1VzZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke3NpZ25Ub1VzZX0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB3aGVyZSB0byBwdXQgdGhlIGNhcmV0IHBvc2l0aW9uIG9uIGZvY3VzIGlmIHRoZSBlbGVtZW50IGNvbnRlbnQgaXMgbm90IHNlbGVjdGVkLlxuICAgICAqIFRoaXMgY2FsY3VsYXRpb24gaXMgYWZmZWN0ZWQgYnkgdGhlIGBjYXJldFBvc2l0aW9uT25Gb2N1c2Agb3B0aW9uIHdoaWNoIGNhbiBiZSBlaXRoZXIgYG51bGxgLCBgJ3N0YXJ0J2AsIGAnZW5kJ2AsIGAnZGVjaW1hbExlZnQnYCBvciAnZGVjaW1hbFJpZ2h0J2AsIGFuZCB3aWxsIGRlY2lkZSB3aGVyZSB0byBwdXQgdGhlIGNhcmV0IChvbiB0aGUgbGVmdCBvciByaWdodCBvZiB0aGUgdmFsdWUgb3IgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLCByZXNwZWN0aXZlbHkpIDpcbiAgICAgKiAtIGBudWxsYCA6IHRoZSBjYXJldCBwb3NpdGlvbiBpcyBub3QgZm9yY2VkXG4gICAgICogLSBgJ3N0YXJ0J2AgOiB0aGUgY2FyZXQgaXMgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIHZhbHVlXG4gICAgICogLSBgJ2VuZCdgIDogdGhlIGNhcmV0IGlzIHBvc2l0aW9uZWQgb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgdmFsdWVcbiAgICAgKiAtIGAnZGVjaW1hbExlZnQnYCA6IHRoZSBjYXJldCBpcyBwb3NpdGlvbmVkIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICogLSBgJ2RlY2ltYWxSaWdodCdgIDogdGhlIGNhcmV0IGlzIHBvc2l0aW9uZWQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGZvcm1hdHRlZCBzdHJpbmcgc3RyaXBwZWQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhbmQgbmVnYXRpdmUvcG9zaXRpdmUgc2lnblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHRocm93c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRpYWxDYXJldFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ2BfaW5pdGlhbENhcmV0UG9zaXRpb24oKWAgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB3aGVuIHRoZSBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIG9wdGlvbiBpcyBgbnVsbGAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlIDwgMDtcbiAgICAgICAgY29uc3QgaXNaZXJvT3JIYXNOb1ZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuaXNaZXJvT3JIYXNOb1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHZhbHVlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBpbnRlZ2VyU2l6ZSA9IDA7XG4gICAgICAgIGxldCBoYXNEZWNpbWFsQ2hhciA9IGZhbHNlO1xuICAgICAgICBsZXQgb2Zmc2V0RGVjaW1hbENoYXIgPSAwO1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5zdGFydCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcrJywgJycpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgICAgIHZhbHVlU2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGhhc0RlY2ltYWxDaGFyID0gQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxMZWZ0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5kZWNpbWFsUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVjaW1hbENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdlclNpemUgPSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldERlY2ltYWxDaGFyID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlZ2VyU2l6ZSA9IHZhbHVlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGVjaW1hbENoYXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzaWduVG9Vc2UgPSAnJztcbiAgICAgICAgaWYgKGlzVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgc2lnblRvVXNlID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpIHtcbiAgICAgICAgICAgIHNpZ25Ub1VzZSA9IHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUgPSBzaWduVG9Vc2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFNpemUgPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGJhc2VkIG9uIGBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudGAsIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgYW5kIGBjYXJldFBvc2l0aW9uT25Gb2N1c2BcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICvigqx8MTIuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vICvigqx8MTIuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIOKCrCt8MTIuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplICsgY3VycmVuY3lTeW1ib2xTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDogLy8g4oKsfDEyLjM0K1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjdXJyZW5jeVN5bWJvbFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOKCrHwxMi4zNFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY3VycmVuY3lTeW1ib2xTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5lbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICvigqwxMi4zNHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vICvigqwxMi4zNHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIOKCrCsxMi4zNHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gdG90YWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyDigqwxMi4zNHwrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGN1cnJlbmN5U3ltYm9sU2l6ZSArIHZhbHVlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g4oKsMTIuMzR8XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbExlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICvigqwxMnwuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vICvigqwxMnwuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIOKCrCsxMnwuMzRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplICsgY3VycmVuY3lTeW1ib2xTaXplICsgaW50ZWdlclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyDigqwxMnwuMzQrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGN1cnJlbmN5U3ltYm9sU2l6ZSArIGludGVnZXJTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDigqwxMnwuMzRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGN1cnJlbmN5U3ltYm9sU2l6ZSArIGludGVnZXJTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5kZWNpbWFsUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICvigqwxMi58MzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vICvigqwxMi58MzRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIOKCrCsxMi58MzRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplICsgY3VycmVuY3lTeW1ib2xTaXplICsgaW50ZWdlclNpemUgKyBvZmZzZXREZWNpbWFsQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIOKCrDEyLnwzNCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY3VycmVuY3lTeW1ib2xTaXplICsgaW50ZWdlclNpemUgKyBvZmZzZXREZWNpbWFsQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g4oKsMTIufDM0XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjdXJyZW5jeVN5bWJvbFNpemUgKyBpbnRlZ2VyU2l6ZSArIG9mZnNldERlY2ltYWxDaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIHwxMi4zNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIHwxMi4zNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vIHwxMi4zNCvigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICt8MTIuMzTigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8MTIuMzTigqxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmVuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDogLy8gMTIuMzR84oKsK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8gMTIuMzR84oKsK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gMTIuMzR8K+KCrFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB2YWx1ZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4OiAvLyArMTIuMzR84oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHBvc2l0aXZlTmVnYXRpdmVTaWduU2l6ZSArIHZhbHVlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTIuMzR84oKsXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB2YWx1ZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNWYWx1ZU5lZ2F0aXZlIHx8ICghaXNWYWx1ZU5lZ2F0aXZlICYmIHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyAxMnwuMzTigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQ6ICAvLyAxMnwuMzTigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdDogICAvLyAxMnwuMzQr4oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGludGVnZXJTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gKzEyfC4zNOKCrFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUgKyBpbnRlZ2VyU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTJ8LjM04oKsXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBpbnRlZ2VyU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNWYWx1ZU5lZ2F0aXZlIHx8ICghaXNWYWx1ZU5lZ2F0aXZlICYmIHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyAxMi58MzTigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQ6ICAvLyAxMi58MzTigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdDogICAvLyAxMi58MzQr4oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGludGVnZXJTaXplICsgb2Zmc2V0RGVjaW1hbENoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4OiAvLyArMTIufDM04oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHBvc2l0aXZlTmVnYXRpdmVTaWduU2l6ZSArIGludGVnZXJTaXplICsgb2Zmc2V0RGVjaW1hbENoYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEyLnwzNOKCrFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gaW50ZWdlclNpemUgKyBvZmZzZXREZWNpbWFsQ2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91bmRlZElucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge2ludH0gZGVjaW1hbFBsYWNlc092ZXJyaWRlXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfdHJ1bmNhdGVaZXJvcyhyb3VuZGVkSW5wdXRWYWx1ZSwgZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgIGxldCByZWdleDtcbiAgICAgICAgc3dpdGNoIChkZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBsZW5ndGggd2hlbiBhbGxvd0RlY2ltYWxQYWRkaW5nIGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske2RlY2ltYWxQbGFjZXNPdmVycmlkZX19KD86XFxcXGQqWzEtOV0pPykwKmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXG4gICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgIGlmIChkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcbiAgICAgICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3VuZGVkSW5wdXRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0aGUgaW5wdXQgdmFsdWUgdXNpbmcgdGhlIHJvdW5kaW5nIG1ldGhvZCBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcy4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgdGhvc2UuXG4gICAgICpcbiAgICAgKiBOb3RlIDogVGhpcyBpcyBoYW5kbGVkIGFzIHRleHQgc2luY2UgSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfcm91bmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICAvL1RPRE8gRGl2aWRlIHRoaXMgZnVuY3Rpb24gdG8gbWFrZSBpdCBlYXNpZXIgdG8gdW5kZXJzdGFuZFxuICAgICAgICBpbnB1dFZhbHVlID0gKGlucHV0VmFsdWUgPT09ICcnKSA/ICcwJyA6IGlucHV0VmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1IHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b05lYXJlc3QwNUFsdCB8fFxuICAgICAgICAgICAgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudXBUb05leHQwNSB8fFxuICAgICAgICAgICAgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuZG93blRvTmV4dDA1KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRDbG9zZVRvMDUoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW25lZ2F0aXZlU2lnbiwgcHJlcGFyZWRWYWx1ZV0gPSBBdXRvTnVtZXJpYy5fcHJlcGFyZVZhbHVlRm9yUm91bmRpbmcoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICBpbnB1dFZhbHVlID0gcHJlcGFyZWRWYWx1ZTtcblxuICAgICAgICBjb25zdCBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPSBpbnB1dFZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWVIYXNBRG90ID0gZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uID09PSAtMTtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdCgnLicpOyAvLyBIZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhbHdheXMgYSBwZXJpb2QgJy4nXG4gICAgICAgIGNvbnN0IGhhc0RlY2ltYWxzID0gZGVjaW1hbFBhcnQgPiAwO1xuICAgICAgICBpZiAoIWhhc0RlY2ltYWxzICYmXG4gICAgICAgICAgICAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyIHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcuZmxvYXRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaW5wdXRWYWx1ZSkgPT09IDApID8gaW5wdXRWYWx1ZSA6IG5lZ2F0aXZlU2lnbiArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdmlydHVhbERlY2ltYWxQb3NpdGlvbiA9IGlucHV0VmFsdWVIYXNBRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIFNldHMgdGhlIHRydW5jYXRlIHplcm8gbWV0aG9kXG4gICAgICAgIGxldCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nKSB7XG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGRlY2ltYWwgcGxhY2VzIHRvIGRldGVybWluZSBpZiByb3VuZGluZyBpcyByZXF1aXJlZCA6XG4gICAgICAgIGxldCBpbnB1dFZhbHVlUm91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgY2hlY2tEZWNpbWFsUGxhY2VzID0gKGlucHV0VmFsdWUubGVuZ3RoIC0gMSkgLSB2aXJ0dWFsRGVjaW1hbFBvc2l0aW9uO1xuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoY2hlY2tEZWNpbWFsUGxhY2VzIDw9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaW5wdXRWYWx1ZVJvdW5kZWQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgaWYgKGNoZWNrRGVjaW1hbFBsYWNlcyA8IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlUm91bmRlZCArPSBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGVja0RlY2ltYWxQbGFjZXMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gY2hlY2tEZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZVJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRGVjaW1hbFBsYWNlcyArPSB6ZXJvcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja0RlY2ltYWxQbGFjZXMgPiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlUm91bmRlZCA9IHRoaXMuX3RydW5jYXRlWmVyb3MoaW5wdXRWYWx1ZVJvdW5kZWQsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrRGVjaW1hbFBsYWNlcyA9PT0gMCAmJiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlUm91bmRlZCA9IGlucHV0VmFsdWVSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGlucHV0VmFsdWVSb3VuZGVkKSA9PT0gMCkgPyBpbnB1dFZhbHVlUm91bmRlZCA6IG5lZ2F0aXZlU2lnbiArIGlucHV0VmFsdWVSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBsZXQgcm91bmRlZFN0ckxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICByb3VuZGVkU3RyTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdW5kZWRTdHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKyBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSBOdW1iZXIoaW5wdXRWYWx1ZS5jaGFyQXQocm91bmRlZFN0ckxlbmd0aCArIDEpKTtcbiAgICAgICAgbGV0IGlucHV0VmFsdWVBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJvdW5kZWRTdHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG4gICAgICAgIGxldCBvZGQ7XG4gICAgICAgIGlmIChpbnB1dFZhbHVlLmNoYXJBdChyb3VuZGVkU3RyTGVuZ3RoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBvZGQgPSBpbnB1dFZhbHVlLmNoYXJBdChyb3VuZGVkU3RyTGVuZ3RoIC0gMSkgJSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2RkID0gaW5wdXRWYWx1ZS5jaGFyQXQocm91bmRlZFN0ckxlbmd0aCkgJSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFJvdW5kVXAobGFzdERpZ2l0LCBzZXR0aW5ncywgbmVnYXRpdmVTaWduLCBvZGQpKSB7XG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChpbnB1dFZhbHVlQXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWVBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWVBcnJheVtpXSA9ICtpbnB1dFZhbHVlQXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZUFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlQXJyYXlbaV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xuICAgICAgICBpbnB1dFZhbHVlQXJyYXkgPSBpbnB1dFZhbHVlQXJyYXkuc2xpY2UoMCwgcm91bmRlZFN0ckxlbmd0aCArIDEpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcm91bmRlZCB2YWx1ZVxuICAgICAgICBpbnB1dFZhbHVlUm91bmRlZCA9IHRoaXMuX3RydW5jYXRlWmVyb3MoaW5wdXRWYWx1ZUFycmF5LmpvaW4oJycpLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGlucHV0VmFsdWVSb3VuZGVkKSA9PT0gMCkgPyBpbnB1dFZhbHVlUm91bmRlZCA6IG5lZ2F0aXZlU2lnbiArIGlucHV0VmFsdWVSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kIHRoZSBgdmFsdWVgIHdoZW4gdGhlIHJvdW5kaW5nIG1ldGhvZCBkZWFscyB3aXRoICcuMDUnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9yb3VuZENsb3NlVG8wNSh2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1OlxuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1QWx0OlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQodmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC51cFRvTmV4dDA1OlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKE1hdGguY2VpbCh2YWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoTWF0aC5mbG9vcih2YWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgJy4nKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgKyAnLjAwJztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggLSB2YWx1ZS5pbmRleE9mKCcuJykgPCAzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZSArICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGdpdmVuIGB2YWx1ZWAgaW4gb3JkZXIgdG8gbWFrZSBpdCB1c2FibGUgZm9yIHRoZSByZXN0IG9mIHRoZSByb3VuZGluZyBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGNvbnZlcnQgdGhlIGB2YWx1ZWAgdG8gYSBwb3NpdGl2ZSBvbmUsIHRyaW0gYW55IGxlYWRpbmcgemVyb3MgYW5kIG1ha2Ugc3VyZSBpdCBkb2VzIG5vdCBzdGFydHMgd2l0aCBhIGxlYWRpbmcgZG90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3ByZXBhcmVWYWx1ZUZvclJvdW5kaW5nKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBDaGVja3MgaWYgYGlucHV0VmFsdWVgIGlzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnbiA9ICcnO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnbiA9ICctJztcblxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB0aGF0IHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSBhIGRvdClcbiAgICAgICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlxcZC8pKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgbmVnYXRpdmVTaWduID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltcyBsZWFkaW5nIHplcm8ncyBhcyBuZWVkZWRcbiAgICAgICAgaWYgKChOdW1iZXIodmFsdWUpID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwKSB8fFxuICAgICAgICAgICAgKHZhbHVlLmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uYWxsb3cpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW25lZ2F0aXZlU2lnbiwgdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgYSByb3VuZCB1cCBzaG91bGQgYmUgZG9uZSBnaXZlbiB0aGUgbGFzdCBkaWdpdCwgdGhlIHNldHRpbmdzIGFuZCBvdGhlciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsdWUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3REaWdpdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWdhdGl2ZVNpZ25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2RkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Nob3VsZFJvdW5kVXAobGFzdERpZ2l0LCBzZXR0aW5ncywgbmVnYXRpdmVTaWduLCBvZGQpIHtcbiAgICAgICAgcmV0dXJuIChsYXN0RGlnaXQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZVcFN5bW1ldHJpYykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZVcEFzeW1tZXRyaWMgJiYgbmVnYXRpdmVTaWduID09PSAnJykgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZlVwQXN5bW1ldHJpYyAmJiBuZWdhdGl2ZVNpZ24gPT09ICctJykgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAobGFzdERpZ2l0ID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRG93blN5bW1ldHJpYykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZEb3duQXN5bW1ldHJpYyAmJiBuZWdhdGl2ZVNpZ24gPT09ICcnKSAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAobGFzdERpZ2l0ID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRG93bkFzeW1tZXRyaWMgJiYgbmVnYXRpdmVTaWduID09PSAnLScpICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZkV2ZW5CYW5rZXJzUm91bmRpbmcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgKGxhc3REaWdpdCA9PT0gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRXZlbkJhbmtlcnNSb3VuZGluZyAmJiBvZGQgPT09IDEpICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9DZWlsaW5nVG93YXJkUG9zaXRpdmVJbmZpbml0eSAmJiBuZWdhdGl2ZVNpZ24gPT09ICcnKSB8fFxuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9GbG9vclRvd2FyZE5lZ2F0aXZlSW5maW5pdHkgJiYgbmVnYXRpdmVTaWduID09PSAnLScpICB8fFxuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudXBSb3VuZEF3YXlGcm9tWmVybyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCBhd2F5IGZyb20gemVyb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3RydW5jYXRlRGVjaW1hbFBsYWNlcyhzLCBzZXR0aW5ncywgaXNQYXN0ZSkge1xuICAgICAgICBpZiAoaXNQYXN0ZSkge1xuICAgICAgICAgICAgcyA9IHRoaXMuX3JvdW5kVmFsdWUocywgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgJiYgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG5cbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBkZWNpbWFsIHBhcnQgdG8gdGhlIHNhdGlzZnlpbmcgbGVuZ3RoIHNpbmNlIHdlIHdvdWxkIHJvdW5kIGl0IGFueXdheVxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0ICYmIGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGAke2ludGVnZXJQYXJ0fSR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke21vZGlmaWVkRGVjaW1hbFBhcnR9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgbnVtYmVyIHNhdGlzZnkgdGhlIGZvcm1hdCBjb25kaXRpb25zXG4gICAgICogYW5kIGxheXMgYmV0d2VlbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxuICAgICAqIGFuZCB0aGUgc3RyaW5nIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgdGhlIGRpZ2l0cyBpbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IEF1dG9OdW1lcmljSGVscGVyLnBhcnNlU3RyKHNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gQXV0b051bWVyaWNIZWxwZXIucGFyc2VTdHIoc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBBdXRvTnVtZXJpY0hlbHBlci5wYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm92ZXJyaWRlTWluTWF4TGltaXRzKSB7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMuZmxvb3I6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW0F1dG9OdW1lcmljSGVscGVyLnRlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cy5jZWlsaW5nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCBBdXRvTnVtZXJpY0hlbHBlci50ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cy5pZ25vcmU6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbQXV0b051bWVyaWNIZWxwZXIudGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIEF1dG9OdW1lcmljSGVscGVyLnRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gdGhlIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBhbmQgYG5vU2VwYXJhdG9yT25Gb2N1c2Agb3B0aW9ucyBhcmUgdXNlZC5cbiAgICAgKiBUaG9zZSBvcmlnaW5hbCBzZXR0aW5ncyBhcmUgdXNlZCBleGNsdXNpdmVseSBpbiB0aGUgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIF9rZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERlY2ltYWxQbGFjZXNPdmVycmlkZSAgICAgID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxBbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICA9IHRoaXMuc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZztcbiAgICAgICAgdGhpcy5vcmlnaW5hbE5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgID0gdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3VmZml4VGV4dCAgICAgICAgICAgICAgICAgPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCAmIGBub1NlcGFyYXRvck9uRm9jdXNgIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIFF1aXJrc21vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfcmVhZENvb2tpZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIGlzIHRha2VuIGZyb20gTW9kZXJuaXpyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIF9zdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFueSB6ZXJvcyBpbiBleGNlc3MgaW4gdGhlIGZyb250IGFuZCBiYWNrIG9mIHRoZSBnaXZlbiBgdmFsdWVgLCBhY2NvcmRpbmcgdG8gdGhlIGBzZXR0aW5nc2AuXG4gICAgICogVGhpcyBhbHNvIG1hbmFnZXMgdGhlIGNhc2VzIHdoZXJlIHRoZSBkZWNpbWFsIHBvaW50IGlzIG9uIHRoZSBmYXIgbGVmdCBvciBmYXIgcmlnaHQgb2YgdGhlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIF90cmltTGVhZGluZ0FuZFRyYWlsaW5nWmVyb3ModmFsdWUpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaXMgdGhlIHZhbHVlIGlzIGFscmVhZHkgZW1wdHkuIFRoaXMgcHJldmVudCBjb252ZXJ0aW5nIHRoYXQgdmFsdWUgdG8gJzAnLlxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiAnMCcgaWYgdGhlIHZhbHVlIGlzIHplcm9cbiAgICAgICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmltIHRoZSBsZWFkaW5nIHplcm9zLCB3aGlsZSBsZWF2aW5nIG9uZSB6ZXJvIHRvIHRoZSBsZWZ0IG9mIHRoZSBkZWNpbWFsIHBvaW50IGlmIG5lZWRlZFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKC0pPzArKD89XFxkKS9nLCckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPIHJlbW92ZSB0aGlzIGZyb20gdGhhdCBmdW5jdGlvbiBhbmQgdXNlIGB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcygpYCBpbnN0ZWFkXG4gICAgICAgIC8vIFRyaW0gdGhlIHRyYWlsaW5nIHplcm9zIGFmdGVyIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2Ugbm90IGJlaW5nIGEgemVybyAoaWUuIDEuMjMwMCAtPiAxLjIzKVxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsICcuJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYW55IHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIGlzIHN1cHBvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9ICh0aGlzLmRvbUVsZW1lbnQubmFtZSAhPT0gJycgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMuZG9tRWxlbWVudC5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuZG9tRWxlbWVudC5uYW1lKX1gIDpgQVVUT18ke3RoaXMuZG9tRWxlbWVudC5pZH1gO1xuICAgICAgICAgICAgbGV0IGRhdGU7XG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcblxuICAgICAgICAgICAgLy8gU2V0cyBjb29raWUgZm9yIGJyb3dzZXIgdGhhdCBkbyBub3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSBJRSA2ICYgSUUgN1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7dGhpcy5zZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyBOb3RlIDogYHRvR01UU3RyaW5nKClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgKGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvR01UU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ29va2llKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c2luJyBhbmQgJ21vdXNlZW50ZXInIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRm9jdXNJbkFuZE1vdXNlRW50ZXIoZSkge1xuICAgICAgICAvL1RPRE8gYEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZWAgaXMgY2FsbGVkIDMgdGltZXMgc2VxdWVudGlhbGx5IGhlcmUsIGZpeCB0aGF0XG4gICAgICAgIGNvbnN0IGluaXRpYWxFbGVtZW50VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25Ib3ZlciAmJiBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiBlLmFsdEtleSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdW5mb3JtYXRBbHRIb3ZlcmVkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnICYmIHRoaXMuc2V0dGluZ3MudW5mb3JtYXRPbkhvdmVyICYmIHRoaXMuaG92ZXJlZFdpdGhBbHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlZm9ybWF0QWx0SG92ZXJlZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1cycgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSA8IDAgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHsgLy9GSVhNRSB0aGlzIGlzIGNhbGxlZCBhIHNlY29uZCB0aW1lIGluIF9hZGRHcm91cFNlcGFyYXRvcnMgdG9vLiBQcmV2ZW50IHRoaXNcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbW92ZSB0aGUgYnJhY2tldHMgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5fcmVtb3ZlQnJhY2tldHMoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCksIHRoaXMuc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgdmFsdWUgbmVlZHMgdG8gYmUgY2hhbmdlZCBieSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHNob3cgb24gZm9jdXMsIHRoZSBzY2FsZURlY2ltYWwqIG9wdGlvbnMgb3Igbm8gc2VwYXJhdG9yIG9uIGZvY3VzIG9wdGlvblxuICAgICAgICAgICAgbGV0IHVwZGF0ZUVsZW1lbnRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHRoaXMuc2V0dGluZ3MucmF3VmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBjaGFuZ2luZyB0aGUgZWxlbWVudCB2YWx1ZSBpZiBpdCdzIGVtcHR5IChzbyB3ZSBkb24ndCBlbmQgdXAgaGF2aW5nIGEgJzAuMDAwc2NhbGVTeW1ib2wnIHZhbHVlIGFmdGVyIGEgbW91c2VlbnRlci9tb3VzZWxlYXZlIGN5Y2xlKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHRoaXMub3JpZ2luYWxEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFVzZSBhIGB0aGlzLnNldHRpbmdzT3ZlcnJpZGVgIG9iamVjdCBpbnN0ZWFkIG9mIG1vZGlmeWluZyB0aGUgYHRoaXMuc2V0dGluZ3NgIG9iamVjdFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXBkYXRlRWxlbWVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmRlZFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fcm91bmRWYWx1ZSh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5ub1NlcGFyYXRvck9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCwgcm91bmRlZFZhbHVlLnJlcGxhY2UoJy4nLCB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLl9hZGRHcm91cFNlcGFyYXRvcnMocm91bmRlZFZhbHVlLCB0aGlzLnNldHRpbmdzLCB0aGlzLmlzRm9jdXNlZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gc2VuZCBhICduYXRpdmUnIGNoYW5nZSBldmVudCB3aGVuIGJsdXJyaW5nIHRoZSBpbnB1dCwgd2UgbmVlZCB0byBmaXJzdCBzdG9yZSB0aGUgaW5pdGlhbCBpbnB1dCB2YWx1ZSBvbiBmb2N1cy5cbiAgICAgICAgICAgIHRoaXMudmFsdWVPbkZvY3VzID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbCA9IHRoaXMudmFsdWVPbkZvY3VzO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5faXNFbGVtZW50VmFsdWVFbXB0eU9yT25seVRoZU5lZ2F0aXZlU2lnbih0aGlzLnZhbHVlT25Gb2N1cywgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICBjb25zdCBvcmRlcmVkVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9vcmRlclZhbHVlQ3VycmVuY3lTeW1ib2xBbmRTdWZmaXhUZXh0KHRoaXMudmFsdWVPbkZvY3VzLCB0aGlzLnNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICgoaXNFbXB0eVZhbHVlICYmIG9yZGVyZWRWYWx1ZSAhPT0gJycpICYmIHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5mb2N1cykge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIG9yZGVyZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGN1cnJlbmN5IHN5bWJvbCBhbmQgaXRzIG9uIHRoZSByaWdodCBoYW5kIHNpZGUsIHRoZW4gd2UgcGxhY2UgdGhlIGNhcmV0IGFjY29yZGluZ2x5IG9uIHRoZSBmYXIgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRWYWx1ZSA9PT0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkgIT09IGluaXRpYWxFbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMuZm9ybWF0dGVkLCB0aGlzLmRvbUVsZW1lbnQsIHsgb2xkVmFsdWU6IGluaXRpYWxFbGVtZW50VmFsdWUsIG5ld1ZhbHVlOiBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAnZm9jdXMnIGV2ZW50LlxuICAgICAqIFdlIHVwZGF0ZSB0aGUgaW5mbyBvZiB0aGUgZm9jdXNlZCBzdGF0ZSBpbiB0aGUgYHRoaXMuaXNGb2N1c2VkYCB2YXJpYWJsZSB3aGVuIHRoZSBlbGVtZW50IGdldHMgZm9jdXNlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5pc0NhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHVuZm9ybWF0dGVkIHZhbHVlIGZvciBsYXRlciB1c2UgYnkgdGhlICdjYW5jZWxsYWJsZScgZmVhdHVyZVxuICAgICAgICAgICAgdGhpcy5fc2F2ZUNhbmNlbGxhYmxlVmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGtlZXAgdHJhY2sgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWRcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAnZm9jdXNpbicgZXZlbnQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSAnZm9jdXMnIGV2ZW50LCBhbmQgaXMgbmVjZXNzYXJ5IHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIG9uIGZvY3VzIHVuZGVyIEZpcmVmb3ggZm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRm9jdXNJbihlKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE9uRm9jdXMpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBpbnB1dCBjb250ZW50IGlzIHNlbGVjdGVkIG9uIGZvY3VzIChmb2xsb3dpbmcgdGhlIGBzZWxlY3RPbkZvY3VzYCBhbmQgYHNlbGVjdE51bWJlck9ubHlgIG9wdGlvbnMpXG4gICAgICAgICAgICAvL1hYWCBGaXJlZm94IDw0NyBkb2VzIG5vdCByZXNwZWN0IHRoaXMgc2VsZWN0aW9uLi4uT2ggd2VsbC5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPciB3ZSBkZWNpZGUgd2hlcmUgdG8gcHV0IHRoZSBjYXJldCB1c2luZyB0aGUgYGNhcmV0UG9zaXRpb25PbkZvY3VzYCBvcHRpb25cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHRoaXMuX2luaXRpYWxDYXJldFBvc2l0aW9uKEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gY2hhbmdlXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxuICAgICAqXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICovXG4gICAgX29uS2V5ZG93bihlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5zZXR0aW5ncy51bmZvcm1hdE9uSG92ZXIgJiYgZS5hbHRLZXkgJiYgdGhpcy5kb21FbGVtZW50ID09PSBBdXRvTnVtZXJpY0hlbHBlci5nZXRIb3ZlcmVkRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBIZXJlIEkgcHJldmVudCBjYWxsaW5nIF91bmZvcm1hdEFsdEhvdmVyZWQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBzaW5jZSB0aGUgZ2xvYmFsICdrZXlkb3duJyBsaXN0ZW5lciB3aWxsIHBpY2sgaXQgdXAgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdW5mb3JtYXRBbHRIb3ZlcmVkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVFdmVudEtleUluZm8oZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlT25LZXlkb3duID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTsgLy8gVGhpcyBpcyBuZWVkZWQgaW4gYG9uS2V5dXAoKWAgdG8gY2hlY2sgaWYgdGhlIHZhbHVlIGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3NcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5Fc2MpIHtcbiAgICAgICAgICAgIC8vWFhYIFRoZSBkZWZhdWx0ICdFc2NhcGUnIGtleSBiZWhhdmlvciBkaWZmZXJzIGJldHdlZW4gRmlyZWZveCBhbmQgQ2hyb21lLCBGaXJlZm94IGFscmVhZHkgaGF2aW5nIGEgYnVpbHQtaW4gJ2NhbmNlbGxhYmxlLWxpa2UnIGZlYXR1cmUuIFRoaXMgaXMgd2h5IHdlIGNhbGwgYGUucHJldmVudERlZmF1bHQoKWAgaGVyZSBpbnN0ZWFkIG9mIGp1c3Qgd2hlbiBgaXNDYW5jZWxsYWJsZWAgaXMgc2V0IHRvIGB0cnVlYC4gVGhpcyBhbGxvdyB1cyB0byBrZWVwIHRoZSBzYW1lIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaXNDYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIGNhbmNlbCBpdHMgbW9kaWZpY2F0aW9ucyA6XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2V0IGJhY2sgdGhlIHNhdmVkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmF3VmFsdWUgIT09IHRoaXMuc2F2ZWRDYW5jZWxsYWJsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzZXQgdGhlIHZhbHVlIGFnYWluIGlmIGl0IGhhcyBub3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh0aGlzLnNhdmVkQ2FuY2VsbGFibGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCB3ZSBuZWVkIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCB3aGVuIHNldHRpbmcgYmFjayB0aGUgaW5pdGlhbCB2YWx1ZSBpbiBvcmRlciB0byBtYWtlIG90aGVyIHNjcmlwdHMgYXdhcmUgb2YgdGhlIHZhbHVlIGNoYW5nZS4uLlxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm5hdGl2ZS5pbnB1dCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLi5hbmQgbGFzdGx5IHdlIHVwZGF0ZSB0aGUgY2FyZXQgc2VsZWN0aW9uLCBldmVuIGlmIHRoZSBvcHRpb24gYGlzQ2FuY2VsbGFibGVgIGlzIGZhbHNlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgICAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gdG8gc2VsZWN0IGVpdGhlciB0aGUgaW50ZWdlciBvciBkZWNpbWFsIHBhcnQgd2l0aCBgRXNjYFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XG4gICAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5FbnRlciAmJiB0aGlzLnZhbHVlT25Gb2N1cyAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmNoYW5nZSwgZS50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZU9uRm9jdXMgPSB0YXJnZXRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaXNDYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGFjdGl2YXRlZCB0aGUgJ2NhbmNlbGxhYmxlJyBmZWF0dXJlLCB3ZSBzYXZlIHRoZSB2YWxpZGF0ZWQgdmFsdWUgd2hlbiAnRW50ZXInIGlzIGhpdFxuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVDYW5jZWxsYWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVJbnRlcm5hbFByb3BlcnRpZXMoZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NOb25QcmludGFibGVLZXlzQW5kU2hvcnRjdXRzKGUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgaXMgYSBkZWxldGUvYmFja3NwYWNlIGtleVxuICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQmFja3NwYWNlIHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkRlbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0VmFsdWUoZSk7XG5cbiAgICAgICAgICAgIC8vIElmIGFuZCBvbmx5IGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgaGFzIGNoYW5nZWQgYWZ0ZXIgdGhhdCBiYWNrc3BhY2UvZGVsZXRlLCB0aGVuIHdlIGhhdmUgdG8gc2VuZCBhbiAnaW5wdXQnIGV2ZW50IGxpa2UgYnJvd3NlcnMgbm9ybWFsbHkgZG8uXG4gICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7IC8vIFVwZGF0ZSB0aGUgdmFsdWUgc2luY2UgaXQgY291bGQgaGF2ZSBiZWVuIGNoYW5nZWQgZHVyaW5nIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgaWYgKCh0YXJnZXRWYWx1ZSAhPT0gdGhpcy5sYXN0VmFsKSAmJiB0aGlzLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5uYXRpdmUuaW5wdXQsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXN0VmFsID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD8gKEkgbWVhbiwgX2Zvcm1hdFZhbHVlIGFsd2F5cyBzZXQgaXQgdG8gYHRydWVgLCBhbmQgdGhpcyBvdmVyd3JpdGUgdGhhdCBpbmZvKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbktleXByZXNzKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkluc2VydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdGhpcy5wcm9jZXNzZWQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUludGVybmFsUHJvcGVydGllcyhlKTtcblxuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc05vblByaW50YWJsZUtleXNBbmRTaG9ydGN1dHMoZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpO1xuICAgICAgICBpZiAoaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICgodGFyZ2V0VmFsdWUgIT09IHRoaXMubGFzdFZhbCkgJiYgdGhpcy50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmlucHV0LCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBhZGQgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleSA9PT0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8IHRoaXMuZXZlbnRLZXkgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLmVuZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IHRhcmdldFZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXN0VmFsID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD8gKEkgbWVhbiwgX2Zvcm1hdFZhbHVlIGFsd2F5cyBzZXQgaXQgdG8gYHRydWVgLCBhbmQgdGhpcyBvdmVyd3JpdGUgdGhhdCBpbmZvKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdpbnB1dCcgZXZlbnRzLlxuICAgICAqIEhhbmRsaW5nIHRoaXMgZXZlbnQgaW5zdGVhZCBvZiBga2V5cHJlc3NgIGlzIG5lZWRlZCBpbiBvcmRlciB0byBzdXBwb3J0IGFuZHJvaWQgZGV2aWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25JbnB1dChlKSB7IC8vRklYTUUgw6AgdGVzdGVyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gRml4IHRoZSBjYXJldCBwb3NpdGlvbiBvbiBrZXl1cCBpbiB0aGUgYF9mb3JtYXRWYWx1ZSgpYCBmdW5jdGlvblxuICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkFuZHJvaWREZWZhdWx0KSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gVGhlIGtleUNvZGUgaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgQW5kcm9pZCBDaHJvbWUgb25lICh3aGljaCBpcyBhbHdheXMgZXF1YWwgdG8gYGtleUNvZGUuQW5kcm9pZERlZmF1bHRgKVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHRoaXMubGFzdFZhbC5sZW5ndGggfHwgdmFsdWUubGVuZ3RoID49IHRoaXMubGFzdFZhbC5sZW5ndGggLSBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBrZXljb2RlIG9mIHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgZW50ZXJlZCwgYW5kIG92ZXJ3cml0ZSB0aGUgZmF1bHR5IGBldmVudEtleUNvZGVgIGluZm8gd2l0aCBpdFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXkgPSB2YWx1ZS5jaGFyQ29kZUF0KHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBhY3R1YWwgY2hhcmFjdGVyIGVudGVyZWQsIGFuZCB1cGRhdGUgdGhlIGBldmVudEtleWAgd2l0aCBpdCAoaW5zdGVhZCBvZiB0aGUgQW5kcm9pZCBkZWZhdWx0IG9uZSlcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5ID0gdmFsdWUuY2hhckF0KHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHNob3VsZCBiZSBpbnNlcnRlZCwgYW5kIGlmIHNvLCBkbyBpbnNlcnQgaXQgaW50byB0aGUgY3VycmVudCBlbGVtZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlciBlbnRlcmVkIChudW1iZXIsIGRlY2ltYWwgb3IgcGx1cy9taW51cyBzaWduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXRWYWx1ZShlKTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCk7IC8vVE9ETyBpcyB0aGlzIG5lZWRlZCBhIHNlY29uZCB0aW1lP1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBuZXcgY2FyZXQgcG9zaXRpb24uIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBvbiBrZXl1cCwgYF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSgpYCBjYXB0dXJlcyB0aGUgb2xkIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBDaGVjayBpZiB0aGlzIGlzIGFuIEFuZHJvaWQgYnVnIG9yIGFuIGF1dG9OdW1lcmljIG9uZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbi5zdGFydDtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0RlY2ltYWxDaGFyYWN0ZXIgPSBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPT09IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGNhcmV0IHRvIHRoZSByaWdodCBpZiB0aGUgYGFuZHJvaWRDaGFyRW50ZXJlZGAgaXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9yIGlmIGl0J3Mgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFoYXNEZWNpbWFsQ2hhcmFjdGVyICYmIGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA8IHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbi5zdGFydCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24gdGhlIGNhcmV0IHJpZ2h0IG5vdyBiZWZvcmUgdGhlICdrZXl1cCcgZXZlbnQgaW4gb3JkZXIgdG8gcHJldmVudCB0aGUgY2FyZXQgZnJvbSBqdW1waW5nIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RWYWwgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVudGVyZWQgY2hhcmFjdGVyIGlzIG5vdCBhbGxvd2VkIDsgb3ZlcndyaXRlIHRoZSBuZXcgaW52YWxpZCB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyB2YWxpZCBvbmUsIGFuZCBzZXQgYmFjayB0aGUgY2FyZXQvc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmxhc3RWYWwpOyAvL1RPRE8gVXBkYXRlIHRoZSByYXdWYWx1ZSBoZXJlIHRvbyB2aWEgX3NldFZhbHVlKCk/XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50LCBzZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vVE9ETyBDaGVjayBob3cgdGhhdCBpcyBhZmZlY3RpbmcgdGhlIG5vcm1hbCB0cmlnZ2VyIG9mIHRoZSBpbnB1dCBldmVudFxuXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hhcmFjdGVyIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAvL1hYWCBUaGUgY2hhbmdlIGluIGxlbmd0aCBjb3VsZCBhbHNvIGJlIHRoZSByZXN1bHQgb2YgdGhlIGBEZWxldGVgIGtleSwgYnV0IHRoZXJlIHVzdWFsbHkgYXJlIG5vIHN1Y2gga2V5IGluIHRoZSBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRzXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleSA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkJhY2tzcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXl1cCcgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3QgcmVsZWFzZWQgYW55IGtleSwgaGVuY2Ugb25lIGV2ZW50IGlzIHNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25LZXl1cChlKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmlzQ2FuY2VsbGFibGUgJiYgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRXNjKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBjYW5jZWwgaXRzIG1vZGlmaWNhdGlvbnMsIHdlIGRyb3AgdGhlICdrZXl1cCcgZXZlbnQgZm9yIHRoZSBFc2Mga2V5XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmFnZSB0aGUgdW5kby9yZWRvIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuWiB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS56KSB7XG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWRvXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnlUYWJsZVJlZG8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uR29pbmdSZWRvID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Hb2luZ1JlZG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBhbiAndW5kbycgdG8gYmUgbGF1bmNoIHdoZW4gcmVsZWFzaW5nIHRoZSBzaGlmdCBrZXkgYmVmb3JlIHRoZSBjdHJsIGtleSBhZnRlciBhICdyZWRvJyBzaG9ydGN1dFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uR29pbmdSZWRvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmRvXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnlUYWJsZVVuZG8oKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1JlZG8gJiYgKGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZXJlIGlmIHRoZSB1c2VyIGhhcyBlbnRlcmVkIGBDb250cm9sK1NoaWZ0K3pgLCB0aGVuIHJlbGVhc2UgYHpgLCBrZWVwaW5nIGBDb250cm9sYCBvciBgU2hpZnRgIHByZXNzZWQsIHRoZW4gYHRoaXMub25Hb2luZ1JlZG9gIGlzIG5ldmVyIGNoYW5nZWQgYmFjayB0byBgZmFsc2VgIHdoZW4gdGhlIHVzZXIgcmVsZWFzZSBgQ29udHJvbGAgb3IgYFNoaWZ0YFxuICAgICAgICAgICAgdGhpcy5vbkdvaW5nUmVkbyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFuYWdlIHRoZSByZWZvcm1hdCB3aGVuIGhvdmVyZWQgd2l0aCB0aGUgQWx0IGtleSBwcmVzc2VkXG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5BbHQgJiYgdGhpcy5ob3ZlcmVkV2l0aEFsdCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fcmVmb3JtYXRBbHRIb3ZlcmVkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVJbnRlcm5hbFByb3BlcnRpZXMoZSk7XG5cbiAgICAgICAgY29uc3Qgc2tpcCA9IHRoaXMuX3Byb2Nlc3NOb25QcmludGFibGVLZXlzQW5kU2hvcnRjdXRzKGUpO1xuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgIGNvbnN0IGlzT25BbmRyb2lkID0gdGhpcy5hbmRyb2lkU2VsZWN0aW9uU3RhcnQgIT09IG51bGw7XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKHNraXAgJiYgIWlzT25BbmRyb2lkIHx8IHRhcmdldFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5UYWIpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIHRhcmdldFZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHRhcmdldFZhbHVlID09PSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSA9PT0gJycgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0ICE9PSAnJykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgnc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZm9ybWF0dGVkKSB7ICAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD8gQ29uc2lkZXJpbmcgdGhhdCBvbktleWRvd24gYW5kIG9uS2V5cHJlc3MgYm90aCBmaW5pc2ggYnkgc2V0dGluZyBpdCB0byBmYWxzZS4uLlxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3MgZXZlbnQgY2hhaW4sIGFuIGV2ZW50IGlzIHNlbnQgdG8gYWxlcnQgdGhhdCBhIGZvcm1hdHRpbmcgaGFzIGJlZW4gZG9uZSAoY2YuIElzc3VlICMxODcpXG4gICAgICAgIGlmICh0YXJnZXRWYWx1ZSAhPT0gdGhpcy5pbml0aWFsVmFsdWVPbktleWRvd24pIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMuZm9ybWF0dGVkLCBlLnRhcmdldCwgeyBvbGRWYWx1ZTogdGhpcy5pbml0aWFsVmFsdWVPbktleWRvd24sIG5ld1ZhbHVlOiB0YXJnZXRWYWx1ZSB9KTsgLy9UT0RPIERvIEkgbmVlZCB0byByZW1vdmUgdGhpcyBzaW5jZSB3ZSBub3cgc2VuZCB0aGlzIGV2ZW50IG9uIGBzZXQoKWA/XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvbiBvZiB0aGUgY3VycmVudCBlbGVtZW50IG9mIHRoZSBoaXN0b3J5IHRhYmxlXG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlUYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb24uZW5kO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVbdGhpcy5oaXN0b3J5VGFibGVJbmRleF0uc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVbdGhpcy5oaXN0b3J5VGFibGVJbmRleF0uZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZShlKSB7XG4gICAgICAgIC8vVE9ETyBDcmVhdGUgc2VwYXJhdGUgaGFuZGxlcnMgZm9yIGJsdXIgYW5kIG1vdXNlbGVhdmVcbiAgICAgICAgLy9GSVhNRSBEbyBub3QgY2FsbCBgc2V0KClgIGlmIHRoZSBjdXJyZW50IHJhdyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgb25lIHdlIGFyZSB0cnlpbmcgdG8gc2V0IChjdXJyZW50bHksIG9uIGZvY3VzIG91dCwgYHNldCgpYCBpcyBhbHdheXMgY2FsbGVkLCBldmVuIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWRcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudW5mb3JtYXRPbkhvdmVyICYmIGUudHlwZSA9PT0gJ21vdXNlbGVhdmUnICYmIHRoaXMuaG92ZXJlZFdpdGhBbHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlZm9ybWF0QWx0SG92ZXJlZCh0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChlLnR5cGUgPT09ICdtb3VzZWxlYXZlJyAmJiAhdGhpcy5pc0ZvY3VzZWQpIHx8IGUudHlwZSA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgnc2V0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9IHRoaXMub3JpZ2luYWxEaWdpdEdyb3VwU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSB0aGlzLm9yaWdpbmFsQ3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0ID0gdGhpcy5vcmlnaW5hbFN1ZmZpeFRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHRoaXMub3JpZ2luYWxEZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID0gdGhpcy5vcmlnaW5hbEFsbG93RGVjaW1hbFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IHRoaXMub3JpZ2luYWxOZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IHRoaXMuY29uc3RydWN0b3IuX2NoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHRoaXMuc2V0dGluZ3MucmF3VmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QgJiYgIXRoaXMuY29uc3RydWN0b3IuX2lzRWxlbWVudFZhbHVlRW1wdHlPck9ubHlUaGVOZWdhdGl2ZVNpZ24odGhpcy5zZXR0aW5ncy5yYXdWYWx1ZSwgdGhpcy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZSh0aGlzLl90cmltTGVhZGluZ0FuZFRyYWlsaW5nWmVyb3ModmFsdWUpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyB0aGlzLnNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gKHRoaXMuc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHRoaXMuc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA/IE51bWJlcih0aGlzLnNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgOiB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZFZhbHVlKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5taW5SYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5tYXhSYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLnplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUoJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZFZhbHVlKCcwJywgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUoJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdyb3VwZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX29yZGVyVmFsdWVDdXJyZW5jeVN5bWJvbEFuZFN1ZmZpeFRleHQodmFsdWUsIHRoaXMuc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5faXNFbGVtZW50VmFsdWVFbXB0eU9yT25seVRoZU5lZ2F0aXZlU2lnbih2YWx1ZSwgdGhpcy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9hZGRHcm91cFNlcGFyYXRvcnModmFsdWUsIHRoaXMuc2V0dGluZ3MsIHRoaXMuaXNGb2N1c2VkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGVzdGluZyBmb3IgYGFsbG93RGVjaW1hbFBhZGRpbmcubmV2ZXJgIGlzIG5lZWRlZCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGtlZXAgYSB0cmFpbGluZyBkZWNpbWFsQ2hhcmFjdGVyIChsaWtlICc1MDAuJykgaW4gdGhlIGVsZW1lbnQsIHNpbmNlIHRoZSByYXcgdmFsdWUgd291bGQgc3RpbGwgYmUgYSByaWdodGx5IGZvcm1hdHRlZCBpbnRlZ2VyICgnNTAwJylcbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IG9yaWdWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcuZmxvYXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYCR7Z3JvdXBlZFZhbHVlfSR7dGhpcy5zZXR0aW5ncy5zY2FsZVN5bWJvbH1gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSB0aGlzLnZhbHVlT25Gb2N1cykge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmNoYW5nZSwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZU9uRm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAncGFzdGUnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fENsaXBib2FyZEV2ZW50fSBlXG4gICAgICovXG4gICAgX29uUGFzdGUoZSkge1xuICAgICAgICAvL1RPRE8gVXNpbmcgY3RybCt6IGFmdGVyIGEgcGFzdGUgc2hvdWxkIGNhbmNlbCBpdCAtPiBIb3cgd291bGQgdGhhdCBhZmZlY3Qgb3RoZXIgZnJhbWV3b3Jrcy9jb21wb25lbnQgYnVpbHQgd2l0aCB0aGF0IGZlYXR1cmUgaW4gbWluZCB0aG91Z2g/XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWQgKGNmLiBpc3N1ZSAjMzAyKVxuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGRlZmF1bHQsIHNpbmNlIG90aGVyd2lzZSB0aGUgdXNlciB3b3VsZCBiZSBhYmxlIHRvIHBhc3RlIGludmFsaWQgY2hhcmFjdGVycyBpbnRvIHRoZSBpbnB1dFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IHJhd1Bhc3RlZFRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgICAgIC8vIDAuIFNwZWNpYWwgY2FzZSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYWxsIHRoZSBpbnB1dCB0ZXh0IGJlZm9yZSBwYXN0aW5nXG4gICAgICAgIGNvbnN0IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kIHx8IDA7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNpemUgPSBzZWxlY3Rpb25FbmQgLSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgbGV0IGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uU2l6ZSA9PT0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaXNBbGxJbnB1dFRleHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiBDaGVjayBpZiB0aGUgcGFzdGUgaGFzIGEgbmVnYXRpdmUgc2lnbiAob25seSBpZiBpdCdzIHRoZSBmaXJzdCBjaGFyYWN0ZXIpLCBhbmQgc3RvcmUgdGhhdCBpbmZvcm1hdGlvbiBmb3IgbGF0ZXIgdXNlXG4gICAgICAgIGNvbnN0IGlzUGFzdGVOZWdhdGl2ZSA9IEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVTdHJpY3QocmF3UGFzdGVkVGV4dCk7XG4gICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIC8vIDFhLiBSZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ24gZnJvbSB0aGUgcGFzdGVkIHRleHRcbiAgICAgICAgICAgIHJhd1Bhc3RlZFRleHQgPSByYXdQYXN0ZWRUZXh0LnNsaWNlKDEsIHJhd1Bhc3RlZFRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFN0cmlwIGFsbCB0aG91c2FuZCBzZXBhcmF0b3JzLCBicmFja2V0cyBhbmQgY3VycmVuY3kgc2lnbiwgYW5kIGNvbnZlcnQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIGEgZG90XG4gICAgICAgIGNvbnN0IHVudHJhbnNsYXRlZFBhc3RlZFRleHQgPSB0aGlzLl9wcmVwYXJlUGFzdGVkVGV4dChyYXdQYXN0ZWRUZXh0KTtcblxuICAgICAgICBsZXQgcGFzdGVkVGV4dDtcbiAgICAgICAgaWYgKHVudHJhbnNsYXRlZFBhc3RlZFRleHQgPT09ICcuJykge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIDogSWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYSBzaW5nbGUgZGVjaW1hbCBjaGFyYWN0ZXIgKHRoYXQgaGFzIGJlZW4gdHJhbnNsYXRlZCB0byAnLicgYWxyZWFkeSlcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSAnLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3JtYWwgY2FzZVxuICAgICAgICAgICAgLy8gQWxsb3cgcGFzdGluZyBhcmFiaWMgbnVtYmVyc1xuICAgICAgICAgICAgcGFzdGVkVGV4dCA9IEF1dG9OdW1lcmljSGVscGVyLmFyYWJpY1RvTGF0aW5OdW1iZXJzKHVudHJhbnNsYXRlZFBhc3RlZFRleHQsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gVGVzdCBpZiB0aGUgcGFzdGUgaXMgdmFsaWQgKG9ubHkgaGFzIG51bWJlcnMgYW5kIGV2ZW50dWFsbHkgYSBkZWNpbWFsIGNoYXJhY3RlcikuIElmIGl0J3Mgbm90IHZhbGlkLCBzdG9wIGhlcmUuXG4gICAgICAgIGlmIChwYXN0ZWRUZXh0ICE9PSAnLicgJiYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihwYXN0ZWRUZXh0KSB8fCBwYXN0ZWRUZXh0ID09PSAnJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIGlzIG5vdCBhIHZhbGlkIHBhc3RlIGNvbnRlbnQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuIENhbGN1bGF0ZSB0aGUgcGFzdGUgcmVzdWx0XG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZztcbiAgICAgICAgbGV0IGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9IHRoaXMuZ2V0TnVtZXJpY1N0cmluZygpO1xuICAgICAgICBsZXQgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVTdHJpY3QoaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyKTtcbiAgICAgICAgbGV0IGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmU7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCBjb250ZW50IGlzIG5lZ2F0aXZlLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZSB0b29cbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSAmJiAhaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gYC0ke2luaXRpYWxVbmZvcm1hdHRlZE51bWJlcn1gO1xuICAgICAgICAgICAgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IGxlZnRQYXJ0O1xuICAgICAgICBsZXQgcmlnaHRQYXJ0O1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgIC8qIDRhLiBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgY2FyZXQgZnJvbSB0aGUgcGFzdGVkIHRleHQgY29udGVudCwgdW50aWwgdGhlIGlucHV0IHJlYWNoIGl0cyByYW5nZSBsaW1pdC5cbiAgICAgICAgICAgICAqIElmIHRoZXJlIGlzIG1vcmUgY2hhcmFjdGVycyBpbiB0aGUgY2xpcGJvYXJkIG9uY2UgYSBsaW1pdCBpcyByZWFjaGVkLCBkcm9wIHRoZSBleHRyYW5lb3VzIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UgcGFzdGUgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBjbGlwYm9hcmQuXG4gICAgICAgICAgICAgKiBXaGlsZSBkb2luZyBzbywgd2UgY2hlY2sgaWYgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzIGFsbG93ZWQsIGFuZCBzdG9wIGFzIHNvb24gYXMgd2UgZW5jb3VudGVyIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiA0Yi4gUmVwbGFjZSBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIElkZW0gdGhhbiB0aGUgJ3RydW5jYXRlJyBwYXN0ZSBiZWhhdmlvciwgZXhjZXB0IHRoYXQgd2hlbiBhIHJhbmdlIGxpbWl0IGlzIGhpdCwgd2UgdHJ5IHRvIHJlcGxhY2UgdGhlIHN1YnNlcXVlbnQgaW5pdGlhbCBudW1iZXJzIHdpdGggdGhlIHBhc3RlZCBvbmVzLCB1bnRpbCB3ZSBoaXQgdGhlIHJhbmdlIGxpbWl0IGEgc2Vjb25kIChhbmQgbGFzdCkgdGltZSwgb3Igd2UgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jYXNlLWRlY2xhcmF0aW9uczogMCAqL1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnRydW5jYXRlOlxuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnJlcGxhY2U6XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Rm9ybWF0dGVkUGFydCA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZShzZWxlY3Rpb25FbmQsIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYS4gSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgc2VsZWN0ZWQgcGFydCwgYW5kIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9wcmVwYXJlUGFzdGVkVGV4dChsZWZ0Rm9ybWF0dGVkUGFydCArIHJpZ2h0Rm9ybWF0dGVkUGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuc2V0UmF3TmVnYXRpdmVTaWduKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdCBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IEF1dG9OdW1lcmljSGVscGVyLmNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihBdXRvTnVtZXJpY0hlbHBlci5jb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgcGFzdGUgaXMgbmVnYXRpdmUgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCwgdGhlbiBJIG11c3Qgb2Zmc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBieSBvbmUgcGxhY2UgdG8gdGhlIHJpZ2h0IHRvIHRha2UgdGhlIGFkZGl0aW9uYWwgaHlwaGVuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGFuZCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCk/XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVmdFBhcnQgPSByZXN1bHQuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcpO1xuICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJlc3VsdC5zbGljZShjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMobGVmdFBhcnQsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIEkgcmVtb3ZlIGEgZG90IGhlcmUsIHRoZW4gSSBuZWVkIHRvIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gKGRlY3JlbWVudCBpdCBieSAxKSB3aGVuIHBvc2l0aW9uaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBkbyBzbywgd2Uga2VlcCB0aGF0IGluZm8gaW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnRDb250YWluZWRBRG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gbGVmdFBhcnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmlnaHRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXG5cbiAgICAgICAgICAgICAgICAvLyBjLiBBZGQgbnVtYmVycyBvbmUgYnkgb25lIGF0IHRoZSBjYXJldCBwb3NpdGlvbiwgd2hpbGUgdGVzdGluZyBpZiB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gICAgQ29udGludWUgdW50aWwgeW91IGVpdGhlciBydW4gb3V0IG9mIG51bWJlcnMgdG8gcGFzdGUsIG9yIHRoYXQgeW91IGdldCBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pblBhcnNlID0gQXV0b051bWVyaWNIZWxwZXIucGFyc2VTdHIodGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFBhcnNlID0gQXV0b051bWVyaWNIZWxwZXIucGFyc2VTdHIodGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0OyAvLyBUaGlzIGlzIHNldCBhcyB0aGUgZGVmYXVsdCwgaW4gY2FzZSB3ZSBkbyBub3QgYWRkIGV2ZW4gb25lIG51bWJlclxuICAgICAgICAgICAgICAgIGxldCBwYXN0ZWRUZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdFBhcnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSByZXN1bHQgd2l0aCBhbm90aGVyIHBhc3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMZWZ0UGFydCArPSBwYXN0ZWRUZXh0W3Bhc3RlZFRleHRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1vZGlmaWVkTGVmdFBhcnQgKyByaWdodFBhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX2NoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nICs9IHBhc3RlZFRleHRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vWFhYIEhlcmUgd2UgaGF2ZSB0aGUgcmVzdWx0IGZvciB0aGUgYHRydW5jYXRlYCBvcHRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS50cnVuY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gSWYgdGhlIHVzZXIgYXMgZGVmaW5lZCBhIHRydW5jYXRlIGNhbGxiYWNrIGFuZCB0aGVyZSBhcmUgc3RpbGwgc29tZSBudW1iZXJzICh0aGF0IHdpbGwgYmUgZHJvcHBlZCksIHRoZW4gY2FsbCB0aGlzIGNhbGxiYWNrIHdpdGggdGhlIGluaXRpYWwgcGFzdGUgYXMgd2VsbCBhcyB0aGUgcmVtYWluaW5nIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vWFhYIC4uLmVsc2Ugd2UgbmVlZCB0byBjb250aW51ZSBtb2RpZnlpbmcgdGhlIHJlc3VsdCBmb3IgdGhlICdyZXBsYWNlJyBvcHRpb25cblxuICAgICAgICAgICAgICAgIC8vIGQuIFVudGlsIHRoZXJlIGFyZSBudW1iZXJzIHRvIHBhc3RlLCByZXBsYWNlIHRoZSBpbml0aWFsIG51bWJlcnMgb25lIGJ5IG9uZSwgYW5kIHN0aWxsIGRvIHRoZSByYW5nZSB0ZXN0LlxuICAgICAgICAgICAgICAgIC8vICAgIFN0b3Agd2hlbiB5b3UgaGF2ZSBubyBtb3JlIG51bWJlcnMgdG8gcGFzdGUsIG9yIGlmIHlvdSBhcmUgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMuXG4gICAgICAgICAgICAgICAgLy8gICAgSWYgeW91IGRvIGdldCB0byB0aGUgcmFuZ2UgbGltaXRzLCB1c2UgdGhlIHByZXZpb3VzIGtub3duIGdvb2QgdmFsdWUgd2l0aGluIHRob3NlIGxpbWl0cy5cbiAgICAgICAgICAgICAgICAvLyAgICBOb3RlOiBUaGUgbnVtYmVycyBhcmUgcmVwbGFjZWQgb25lIGJ5IG9uZSwgaW4gdGhlIGludGVnZXIgdGhlbiBkZWNpbWFsIHBhcnQsIHdoaWxlIGlnbm9yaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IHNob3VsZCBoYXBwZW4gaWYgdGhlIHVzZXIgdHJ5IHRvIHBhc3RlIGEgZGVjaW1hbCBudW1iZXI/IFNob3VsZCB3ZSBvdmVycmlkZSB0aGUgY3VycmVudCBpbml0aWFsIGRlY2ltYWwgY2hhcmFjdGVyIGluIGZhdm9yIG9mIHRoaXMgbmV3IG9uZT8gSWYgd2UgZG8sIHRoZW4gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGUgdk1pbi92TWF4IGZyb20gdGhlIHN0YXJ0IGluIG9yZGVyIHRvIHRha2UgaW50byBhY2NvdW50IHRoaXMgbmV3IGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uLi5cbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4ID0gY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEdvb2RLbm93blJlc3VsdFNpemUgPSBsYXN0R29vZEtub3duUmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCAmJiBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEdvb2RLbm93blJlc3VsdFtsYXN0R29vZEtub3duUmVzdWx0SW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdyZXBsYWNlbWVudCcuIFRoYXQgd2F5LCB3ZSBkbyBub3QgY2hhbmdlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbiByZWdhcmRpbmcgdGhlIHJlbWFpbmluZyBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVwbGFjZSBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0hlbHBlci5yZXBsYWNlQ2hhckF0KGxhc3RHb29kS25vd25SZXN1bHQsIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCwgcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gbGFzdEdvb2RLbm93blJlc3VsdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXN0R29vZEtub3duUmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiA0Yy4gTm9ybWFsIHBhc3RlIGJlaGF2aW9yOlxuICAgICAgICAgICAgICogSW5zZXJ0IHRoZSBwYXN0ZWQgbnVtYmVyIGluc2lkZSB0aGUgY3VycmVudCB1bmZvcm1hdHRlZCB0ZXh0LCBhdCB0aGUgcmlnaHQgY2FyZXQgcG9zaXRpb24gb3Igc2VsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcjpcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5pZ25vcmU6XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuY2xhbXA6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIDEuIEdlbmVyYXRlIHRoZSB1bmZvcm1hdHRlZCByZXN1bHRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Rm9ybWF0dGVkUGFydDIgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Rm9ybWF0dGVkUGFydDIgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQyICsgcmlnaHRGb3JtYXR0ZWRQYXJ0Mik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuc2V0UmF3TmVnYXRpdmVTaWduKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdCBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IEF1dG9OdW1lcmljSGVscGVyLmNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihBdXRvTnVtZXJpY0hlbHBlci5jb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgcGFzdGUgaXMgbmVnYXRpdmUgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCwgdGhlbiBJIG11c3Qgb2Zmc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBieSBvbmUgcGxhY2UgdG8gdGhlIHJpZ2h0IHRvIHRha2UgdGhlIGFkZGl0aW9uYWwgaHlwaGVuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQgKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGFuZCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCk/XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVmdFBhcnQgPSByZXN1bHQuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcpO1xuICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJlc3VsdC5zbGljZShjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBvbmx5IHBhc3RlIGEgc2luZ2xlIGRlY2ltYWwgY2hhcmFjdGVyLCB0aGVuIHdlIHJlbW92ZSB0aGUgcHJldmlvdXNseSBleGlzdGluZyBvbmUgKGlmIGFueSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKGxlZnRQYXJ0LCAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBJIHJlbW92ZSBhIGRvdCBoZXJlLCB0aGVuIEkgbmVlZCB0byB1cGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIChkZWNyZW1lbnQgaXQgYnkgMSkgd2hlbiBwb3NpdGlvbmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gZG8gc28sIHdlIGtlZXAgdGhhdCBpbmZvIGluIG9yZGVyIHRvIG1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0Q29udGFpbmVkQURvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IGxlZnRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmlnaHRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7bGVmdFBhcnR9JHtwYXN0ZWRUZXh0fSR7cmlnaHRQYXJ0fWA7XG5cbiAgICAgICAgICAgICAgICAvLyAyLiBDYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGluIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgdGhlbiB0aGUgY2FyZXQgcG9zaXRpb24gaXMgc2V0IGFmdGVyIHRoZSBwYXN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFdoZXJlUGFzdGVkVGV4dEhhc0JlZW5JbnNlcnRlZCA9IEF1dG9OdW1lcmljSGVscGVyLmNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihBdXRvTnVtZXJpY0hlbHBlci5jb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgKyBwYXN0ZWRUZXh0Lmxlbmd0aDsgLy8gSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbElucHV0VGV4dFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBhbGwgdGhlIGlucHV0IHRleHQgaXMgc2VsZWN0ZWQgYmVmb3JlIHBhc3RpbmcsIHdoaWNoIG1lYW5zIHdlJ2xsIGNvbXBsZXRlbHkgZXJhc2UgaXRzIGNvbnRlbnQgYW5kIHBhc3RlIG9ubHkgdGhlIGNsaXBib2FyZCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHRQYXJ0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgc2VsZWN0ZWQgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgKG9uIHRoZSBmYXIgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IEF1dG9OdW1lcmljSGVscGVyLmNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihBdXRvTnVtZXJpY0hlbHBlci5jb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5jb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oQXV0b051bWVyaWNIZWxwZXIuY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uRW5kLCB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSBJIG11c3Qgbm90IGNvdW50IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFzdGVkIHRleHQgKGllLiAnLicpLCBvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9ycyBpbiB0aGUgaW5pdGlhbCBzZWxlY3RlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUoZS50YXJnZXQpLnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgLSBzZWxlY3Rpb25TaXplICsgQXV0b051bWVyaWNIZWxwZXIuY291bnRDaGFySW5UZXh0KHRoaXMuc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciwgc2VsZWN0ZWRUZXh0KSArIHBhc3RlZFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBmb3Igc3BlY2lhbCBjYXNlcywgb25seSBpZiB0aGUgd2hvbGUgaW5wdXQgaGFzIG5vdCBiZWVuIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbElucHV0VGV4dFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gQ2hlY2sgaWYgdGhlIHJlc3VsdCBpcyBhIHZhbGlkIG51bWJlciwgaWYgbm90LCBkcm9wIHRoZSBwYXN0ZSBhbmQgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihyZXN1bHQpIHx8IHJlc3VsdCA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgd291bGQgcmVzdWx0IGludG8gYW4gaW52YWxpZCBjb250ZW50ICcke3Jlc3VsdH0nLmApOyAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgaXMgbm90IERSWSA7IHJlZmFjdG9yIHdpdGggYWJvdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIElmIGl0J3MgYSB2YWxpZCBudW1iZXIsIGNoZWNrIGlmIGl0IGZhbGxzIGluc2lkZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgdGhpcyBmYWlscywgbW9kaWZ5IHRoZSB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBwcm9jZWR1cmUgOlxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiAnZXJyb3InICh0aGlzIGlzIHRoZSBkZWZhdWx0KSA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCB0aGVuIHRocm93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnaWdub3JlJyA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBkbyBub3RoaW5nIG1vcmUuXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIElmICdjbGFtcCcgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWluaW11bSBvciBtYXhpbXVtIGxpbWl0LCB3aGljaGV2ZXIgaXMgY2xvc2VzdCB0byB0aGVcbiAgICAgICAgICogICAgICAgIHBhc3RlIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLlxuICAgICAgICAgKiBJZiAndHJ1bmNhdGUnIDpcbiAgICAgICAgICogICAgICAtIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAgLSBEcm9wIHRoZSByZW1haW5pbmcgbm9uLXBhc3RlZCBudW1iZXJzLCBhbmQga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3JlcGxhY2UnIDpcbiAgICAgICAgICogICAgICAtIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cbiAgICAgICAgICogICAgIC0gVGhlbiB0cnkgdG8gcmVwbGFjZSBhcyBtYW55IG51bWJlcnMgYXMgcG9zc2libGUgd2l0aCB0aGUgcGFzdGVkIG9uZXMuIE9uY2UgaXQgZmFpbHMsIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuU2V0ID0gZmFsc2U7XG4gICAgICAgIGxldCB2YWx1ZUhhc0JlZW5DbGFtcGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNldChyZXN1bHQpO1xuICAgICAgICAgICAgdmFsdWVIYXNCZWVuU2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBjbGFtcGVkVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuY2xhbXA6XG4gICAgICAgICAgICAgICAgICAgIGNsYW1wZWRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmNsYW1wVG9SYW5nZUxpbWl0cyhyZXN1bHQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoY2xhbXBlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYEZhdGFsIGVycm9yOiBVbmFibGUgdG8gc2V0IHRoZSBjbGFtcGVkIHZhbHVlICcke2NsYW1wZWRWYWx1ZX0nLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNsYW1wZWRWYWx1ZTsgLy8gVGhpcyBpcyB1c2VkIG9ubHkgZm9yIHNldHRpbmcgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcjpcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUudHJ1bmNhdGU6XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnJlcGxhY2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgcmVzdWx0cyBpbiBhIHZhbHVlICcke3Jlc3VsdH0nIHRoYXQgaXMgb3V0c2lkZSBvZiB0aGUgbWluaW11bSBbJHt0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtIFske3RoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlfV0gdmFsdWUgcmFuZ2UuYCk7XG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5pZ25vcmU6XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyAuLi5hbmQgbm90aGluZyBlbHNlIHNob3VsZCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA3LiBUaGVuIGxhc3RseSwgc2V0IHRoZSBjYXJldCBwb3NpdGlvbiBhdCB0aGUgcmlnaHQgbG9naWNhbCBwbGFjZVxuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXI7XG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5jbGFtcDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlSGFzQmVlbkNsYW1wZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHRhcmdldFZhbHVlLmxlbmd0aCAtIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKTsgLy8gVGhpcyBwdXRzIHRoZSBjYXJldCBvbiB0aGUgcmlnaHQgb2YgdGhlIGxhc3QgZGVjaW1hbCBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCB0YXJnZXRWYWx1ZS5sZW5ndGgpOyAvLyAuLmFuZCB0aGlzIG9uIHRoZSBmYXIgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBpZiB0aGUgdmFsdWUgaGFzIG5vdCBiZWVuIGNsYW1wZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHVzZWQuLi5cbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmVycm9yOlxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5pZ25vcmU6XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnRydW5jYXRlOlxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5yZXBsYWNlOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbXVsdGlwbGUgY2hhcmFjdGVycyBhcmUgcGFzdGVkLCB0aGlzIG1lYW5zIHdlIGhhdmUgdG8gbWFuYWdlIHRoZSBwb3RlbnRpYWwgdGhvdXNhbmQgc2VwYXJhdG9ycyB0aGF0IGNvdWxkIGJlIGFkZGVkIGJ5IHRoZSBmb3JtYXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlciA9IEF1dG9OdW1lcmljSGVscGVyLmZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmVzdWx0LCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgdGFyZ2V0VmFsdWUsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA4LiBXZSBtYWtlIHN1cmUgd2Ugc2VuZCBhbiBpbnB1dCBldmVudCBvbmx5IGlmIHRoZSByZXN1bHQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGluaXRpYWwgdmFsdWUgYmVmb3JlIHRoZSBwYXN0ZVxuICAgICAgICBpZiAodmFsdWVIYXNCZWVuU2V0ICYmIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9uIGEgJ25vcm1hbCcgbm9uLWF1dG9OdW1lcmljIGlucHV0LCBhbiBgaW5wdXRgIGV2ZW50IGlzIHNlbnQgd2hlbiBhIHBhc3RlIGlzIGRvbmUuIFdlIG1pbWljIHRoYXQuXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm5hdGl2ZS5pbnB1dCwgZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBmb2N1c2luZyBvdXQgb2YgdGhlIGlucHV0LCB3ZSBjaGVjayBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsIHRoZW4gd2Ugc2VuZCBhIGBjaGFuZ2VgIGV2ZW50IChzaW5jZSB0aGUgbmF0aXZlIG9uZSB3b3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGBlLnByZXZlbnREZWZhdWx0KClgIGNhbGxlZCBpbiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICAgKiBXZSBhbHNvIHVwZGF0ZSB0aGUgaW5mbyBvZiB0aGUgZm9jdXNlZCBzdGF0ZSBpbiB0aGUgYHRoaXMuaXNGb2N1c2VkYCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25CbHVyKGUpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCkgIT09IHRoaXMudmFsdWVPbkZvY3VzKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm5hdGl2ZS5jaGFuZ2UsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWRcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnd2hlZWwnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1doZWVsRXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25XaGVlbChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSAnU2hpZnQnIGtleSBtb2RpZmllciwgdGhlbiB3ZSBpZ25vcmUgdGhlIHdoZWVsIGV2ZW50XG4gICAgICAgIC8vIFRoaXMgc3BlY2lhbCBiZWhhdmlvciBpcyBhcHBsaWVkIGluIG9yZGVyIHRvIGF2b2lkIHByZXZlbnRpbmcgdGhlIHVzZXIgdG8gc2Nyb2xsIHRoZSBwYWdlIGlmIHRoZSBpbnB1dHMgYXJlIGNvdmVyaW5nIHRoZSB3aG9sZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICAgIC8vIElmIHRoYXQncyB0aGUgY2FzZSwgdGhlbiBoZSBjYW4gdXNlIHRoZSAnU2hpZnQnIG1vZGlmaWVyIGtleSB3aGlsZSB1c2luZyB0aGUgbW91c2Ugd2hlZWwgaW4gb3JkZXIgdG8gYnlwYXNzIHRoZSBpbmNyZW1lbnQvZGVjcmVtZW50IGZlYXR1cmVcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgb24gc21hbGwgc2NyZWVuIHdoZXJlIHNvbWUgYmFkbHkgY29uZmlndXJlZCBpbnB1dHMgY291bGQgdXNlIGFsbCB0aGUgYXZhaWxhYmxlIHNwYWNlLlxuICAgICAgICBpZiAoIWUuc2hpZnRLZXkgJiYgdGhpcy5zZXR0aW5ncy5tb2RpZnlWYWx1ZU9uV2hlZWwpIHtcbiAgICAgICAgICAgIC8vIDApIEZpcnN0LCBzYXZlIHRoZSBjYXJldCBwb3NpdGlvbiBzbyB3ZSBjYW4gc2V0IGl0IGJhY2sgb25jZSB0aGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIDEpIEdldCB0aGUgdW5mb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVbmZvcm1hdHRlZFZhbHVlID0gdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGN1cnJlbnRVbmZvcm1hdHRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGJ5IGRlZmF1bHQgdGhlIGlucHV0IGlzIGVtcHR5LCBzdGFydCBhdCAnMCdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUgPiAwIHx8IHRoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiAnMCcgaXMgbm90IGJldHdlZW4gbWluIGFuZCBtYXggdmFsdWUsICdtaW5pbXVtVmFsdWUnIGlmIHRoZSB1c2VyIGRvZXMgYSB3aGVlbHVwLCAnbWF4aW11bVZhbHVlJyBpZiB0aGUgdXNlciBkb2VzIGEgd2hlZWxkb3duXG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1doZWVsVXBFdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNXaGVlbERvd25FdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZXZlbnQgaXMgbm90IGEgJ3doZWVsJyBldmVudC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyZW50VW5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gK3Jlc3VsdDsgLy8gVHlwZWNhc3QgdG8gYSBudW1iZXIgbmVlZGVkIGZvciB0aGUgZm9sbG93aW5nIGFkZGl0aW9uL3N1YnRyYWN0aW9uXG5cbiAgICAgICAgICAgIC8vIDIpIEluY3JlbWVudC9EZWNyZW1lbnQgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBCdXQgZmlyc3QsIGNob29zZSB0aGUgaW5jcmVtZW50L2RlY3JlbWVudCBtZXRob2QgOyBmaXhlZCBvciBwcm9ncmVzc2l2ZVxuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKHRoaXMuc2V0dGluZ3Mud2hlZWxTdGVwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSArdGhpcy5zZXR0aW5ncy53aGVlbFN0ZXA7IC8vIFR5cGVjYXN0IHRvIGEgbnVtYmVyIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyBhZGRpdGlvbi9zdWJ0cmFjdGlvblxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHNpbXBsZXN0IG1ldGhvZCwgd2hlcmUgYSBmaXhlZCBvZmZzZXQgaW4gYWRkZWQvc3VidHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzV2hlZWxVcEV2ZW50KGUpKSB7IC8vIEluY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBzdGVwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNXaGVlbERvd25FdmVudChlKSkgeyAvLyBEZWNyZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIG1ldGhvZCwgd2UgY2FsY3VsYXRlIGFuIG9mZnNldCB0aGF0IGlzIGluIHJlbGF0aW9uIHRvIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IG51bWJlciAodXNpbmcgb25seSB0aGUgaW50ZWdlciBwYXJ0IHNpemUpLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBiaWdnZXIgdGhlIG51bWJlciwgdGhlIGJpZ2dlciB0aGUgb2Zmc2V0ICh1c3VhbGx5IHRoZSBudW1iZXIgY291bnQgaW4gdGhlIGludGVnZXIgcGFydCBtaW51cyAzLCBleGNlcHQgZm9yIHNtYWxsIG51bWJlcnMgd2hlcmUgYSBkaWZmZXJlbnQgYmVoYXZpb3IgaXMgYmV0dGVyIGZvciB0aGUgdXNlciBleHBlcmllbmNlKS5cbiAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNXaGVlbFVwRXZlbnQoZSkpIHsgLy8gSW5jcmVtZW50XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljSGVscGVyLmFkZEFuZFJvdW5kVG9OZWFyZXN0QXV0byhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNXaGVlbERvd25FdmVudChlKSkgeyAvLyBEZWNyZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuc3VidHJhY3RBbmRSb3VuZFRvTmVhcmVzdEF1dG8ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDMpIFNldCB0aGUgbmV3IHZhbHVlIHNvIGl0IGdldHMgZm9ybWF0dGVkXG4gICAgICAgICAgICAvLyBGaXJzdCBjbGFtcCB0aGUgcmVzdWx0IGlmIG5lZWRlZFxuICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuY2xhbXBUb1JhbmdlTGltaXRzKHJlc3VsdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSArY3VycmVudFVuZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5ICdzZXQnIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gRm9yIGluc3RhbmNlICdzZXQnIHNob3VsZCBub3QgaGFwcGVuIGlmIHRoZSB1c2VyIGhpdHMgYSBsaW1pdCBhbmQgY29udGludWUgdG8gdHJ5IHRvIGdvIHBhc3QgaXQgc2luY2Ugd2UgY2xhbXAgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vWFhYIERvIG5vdCBwcmV2ZW50IGlmIHRoZSB2YWx1ZSBpcyBub3QgbW9kaWZpZWQ/IEZyb20gYSBVWCBwb2ludCBvZiB2aWV3LCBwcmV2ZW50aW5nIHRoZSB3aGVlbCBldmVudCB3aGVuIHRoZSB1c2VyIHVzZSBpdCBvbiB0b3Agb2YgYW4gYXV0b051bWVyaWMgZWxlbWVudCBzaG91bGQgYWx3YXlzIGJlIGRvbmUsIGV2ZW4gaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS4gUGVyaGFwcyB0aGF0IGNvdWxkIGFmZmVjdCBvdGhlciBzY3JpcHRzIHJlbHlpbmcgb24gdGhpcyBldmVudCB0byBiZSBzZW50IHRob3VnaC5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gV2UgcHJldmVudCB0aGUgcGFnZSB0byBzY3JvbGwgd2hpbGUgd2UgaW5jcmVtZW50L2RlY3JlbWVudCB0aGUgdmFsdWVcblxuICAgICAgICAgICAgLy8gNCkgRmluYWxseSwgd2Ugc2V0IGJhY2sgdGhlIGNhcmV0IHBvc2l0aW9uL3NlbGVjdGlvblxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgZmFjdCB0aGF0IHRoZSBudW1iZXIgY291bnQgY291bGQgYmUgZGlmZmVyZW50IGF0IHRoZSBlbmQgb2YgdGhlIHdoZWVsIGV2ZW50IDsgaXQgd291bGQgYmUgdG9vIGNvbXBsZXggYW5kIG1vc3Qgb2YgdGhlIHRpbWUgdW5yZWxpYWJsZVxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2Ryb3AnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbkRyb3AoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRyb3BwZWRUZXh0ID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWUgPSB0aGlzLnVuZm9ybWF0T3RoZXIoZHJvcHBlZFRleHQpO1xuICAgICAgICB0aGlzLnNldChjbGVhbmVkVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdzdWJtaXQnIGV2ZW50cyBoYXBwZW5pbmcgb24gdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudFxuICAgICAqL1xuICAgIF9vbkZvcm1TdWJtaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgdGhlIGBhbHRgIGtleSBrZXlkb3duIGV2ZW50IGdsb2JhbGx5LCBhbmQgaWYgdGhlIGV2ZW50IGlzIGNhdWdodCwgdW5mb3JtYXQgdGhlIEF1dG9OdW1lcmljIGVsZW1lbnQgdGhhdCBpcyBob3ZlcmVkIGJ5IHRoZSBtb3VzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uS2V5ZG93bkdsb2JhbChlKSB7XG4gICAgICAgIC8vVE9ETyBGaW5kIGEgd2F5IHRvIGtlZXAgdGhlIGNhcmV0IHBvc2l0aW9uIGJldHdlZW4gdGhlIGFsdCBrZXl1cC9rZXlkb3duIHN0YXRlc1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY2hhcmFjdGVyKGUpID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5BbHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRFbGVtZW50ID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0SG92ZXJlZEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpYy5pc01hbmFnZWRCeUF1dG9OdW1lcmljKGhvdmVyZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuRWxlbWVudCA9IEF1dG9OdW1lcmljLmdldEF1dG9OdW1lcmljRWxlbWVudChob3ZlcmVkRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdW5mb3JtYXRBbHRIb3ZlcmVkKGFuRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIHRoZSBgYWx0YCBrZXkga2V5dXAgZXZlbnQgZ2xvYmFsbHksIGFuZCBpZiB0aGUgZXZlbnQgaXMgY2F1Z2h0LCByZWZvcm1hdCB0aGUgQXV0b051bWVyaWMgZWxlbWVudCB0aGF0IGlzIGhvdmVyZWQgYnkgdGhlIG1vdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25LZXl1cEdsb2JhbChlKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5jaGFyYWN0ZXIoZSkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkFsdCkge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEVsZW1lbnQgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRIb3ZlcmVkRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljLmlzTWFuYWdlZEJ5QXV0b051bWVyaWMoaG92ZXJlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5FbGVtZW50ID0gQXV0b051bWVyaWMuZ2V0QXV0b051bWVyaWNFbGVtZW50KGhvdmVyZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9yZWZvcm1hdEFsdEhvdmVyZWQoYW5FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIERPTSBlbGVtZW50IGlzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKiBBIHN1cHBvcnRlZCBlbGVtZW50IGlzIGFuIGVsZW1lbnQgd2hpdGVsaXN0ZWQgaW4gdGhlIGBhbGxvd2VkVGFnTGlzdGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0VsZW1lbnRUYWdTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNFbGVtZW50KHRoaXMuZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBET00gZWxlbWVudCBpcyBub3QgdmFsaWQsICR7dGhpcy5kb21FbGVtZW50fSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkodGhpcy5kb21FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5hbGxvd2VkVGFnTGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpbiB0aGUgRE9NIGVsZW1lbnQgaXMgYW4gPGlucHV0Pi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzSW5wdXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBpbnB1dCB0eXBlIGlzIHN1cHBvcnRlZCBieSBBdXRvTnVtZXJpY1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHRocm93c1xuICAgICAqL1xuICAgIF9pc0lucHV0VHlwZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbUVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LnR5cGUgPT09ICdoaWRkZW4nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LnR5cGUgPT09ICd0ZWwnIHx8XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuZG9tRWxlbWVudC50eXBlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIERPTSBlbGVtZW50IGlzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKiBBIHN1cHBvcnRlZCBlbGVtZW50IGlzIGVpdGhlciBhbiA8aW5wdXQ+IGVsZW1lbnQgd2l0aCB0aGUgcmlnaHQgJ3R5cGUnIGF0dHJpYnV0ZSwgb3IgYSB0YWcgd2hpdGVsaXN0ZWQgaW4gdGhlIGBhbGxvd2VkVGFnTGlzdGAuXG4gICAgICogSWYgdGhlIGNoZWNrIGZhaWxzLCB0aGlzIG1ldGhvZCB0aHJvd3MuXG4gICAgICogVGhpcyBmdW5jdGlvbiBhbHNvIHNldCB0aGUgaW5mbyBgdGhpcy5pc0lucHV0RWxlbWVudGAgd2hpY2gga2VlcCB0cmFja3MgaWYgdGhlIERPTSBlbGVtZW50IGlzIGFuIDxpbnB1dD4gb3Igbm90LCBhbmQgdGhlIGB0aGlzLmlzQ29udGVudEVkaXRhYmxlYCBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGBjb250ZW50ZWRpdGFibGVgIGF0dHJpYnV0ZSBzZXQgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHRocm93c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRUYWcgPSB0aGlzLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5faXNFbGVtZW50VGFnU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSA8JHtjdXJyZW50RWxlbWVudFRhZ30+IHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNJbnB1dEVsZW1lbnQoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0lucHV0VHlwZVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIke3RoaXMuZG9tRWxlbWVudC50eXBlfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0lucHV0RWxlbWVudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzSW5wdXRFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQ29udGVudEVkaXRhYmxlID0gdGhpcy5kb21FbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgJiYgdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgaWYgdGhlIGBmb3JtYXRPblBhZ2VMb2FkYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBmb3JjZWRJbml0aWFsVmFsdWUgVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGluaXRpYWxpemF0aW9uLCBpbiBwbGFjZSBvbiB0aGUgZXZlbnR1YWwgaHRtbCBvbmVcbiAgICAgKi9cbiAgICBfZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChmb3JjZWRJbml0aWFsVmFsdWUgPSBudWxsKSB7XG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWU7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGZvcmNlZEluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGZvcmNlZEluaXRpYWxWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEVsZW1lbnQgfHwgdGhpcy5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb24gKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiB0aGUgYHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWRgIG9wdGlvbikpLlxuICAgICAgICAgICAgICogTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXIgaGFzIHNldCBmb3IgYGRhdGEtZGVmYXVsdC12YWx1ZS1vdmVycmlkZWAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIHRoZSBodG1sIGB2YWx1ZWAgYXR0cmlidXRlIGlzIG5vdCBzZXQsIHRoZW4gaXQgbWVhbnMgdGhlIGRldiBoYXNcbiAgICAgICAgICAgICAqIGNoYW5nZWQgdGhlIGlucHV0IHZhbHVlLCBhbmQgdGhlbiBpdCBtZWFucyB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSBoaXMgb3duIGRlY2lzaW9uIHRvIGRvIHNvLlxuICAgICAgICAgICAgICogSGVuY2UsIGlmIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgaXMgbm90IG51bGwsIGJ1dCBgaW5wdXQudmFsdWVgIGlzIGEgbnVtYmVyIGFuZCBgdGhpcy5kb21FbGVtZW50Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKWBcbiAgICAgICAgICAgICAqIGlzIGZhbHNlLCB3ZSBzaG91bGQgaWdub3JlIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl90b051bWVyaWNWYWx1ZShjdXJyZW50VmFsdWUsIHRoaXMuc2V0dGluZ3MpOyAvLyBUaGlzIGFsbG93cyB0byB1c2UgYSBsb2NhbGl6ZWQgdmFsdWUgb24gc3RhcnR1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbUVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpIHx8IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpKSAmJiBJbmZpbml0eSAhPT0gdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQodW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09IG51bGwgJiYgdGhpcy5zZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZS50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSB0aGlzLmRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiB0aGlzLmRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcih1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiB0aGlzLnNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZSh0aGlzLl9zYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCdnZXQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB2YWx1ZSBzaG91bGQgTk9UIGJlIHNhdmVkIGluIHNlc3Npb25TdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IHRoaXMuY29uc3RydWN0b3IuX3JlbW92ZUJyYWNrZXRzKGN1cnJlbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXggJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJhd1ZhbHVlKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgdGhpcy5jb25zdHJ1Y3Rvci5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRvU3RyaXAsIHRoaXMuc2V0dGluZ3MsIHRydWUsIHRoaXMuaXNGb2N1c2VkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJhd1ZhbHVlKHRoaXMuY29uc3RydWN0b3IuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0b1N0cmlwLCB0aGlzLnNldHRpbmdzLCB0cnVlLCB0aGlzLmlzRm9jdXNlZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmZvY3VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gV2hhdCBhYm91dCB0aGUgYEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLnByZXNzYCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5hbHdheXM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSB0aGlzLmRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2UgdGhlIHVzZXIgZXhwZXJpZW5jZSBieSBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gZGVwZW5kaW5nIG9uIGBjdXJyZW5jeVN5bWJvbGAgYW5kIGBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdXNlciBoYXMgbm90IHNldCB0aGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIChgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgKSwgYnV0IGhhcyBzZXQgYSBjdXJyZW5jeSBzeW1ib2wgKGBjdXJyZW5jeVN5bWJvbGApLFxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgaW4gb3JkZXIgdG8ga2VlcCB0aGUgcmVzdWx0aW5nIG91dHB1dCBsb2dpY2FsIGJ5IGRlZmF1bHQgOlxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSlcbiAgICAgKiAtIFwiLTEsMjM0LjU2JFwiIGluc3RlYWQgb2YgXCIxLDIzNC41Ni0kXCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSlcbiAgICAgKi9cbiAgICBfY29ycmVjdE5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50T3B0aW9uKCkge1xuICAgICAgICAvLyBJZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyBhbHJlYWR5IHNldCwgd2UgZG8gbm90IG92ZXJ3cml0ZSBpdFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZCh0aGlzLnNldHRpbmdzKSAmJlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpICYmXG4gICAgICAgICAgICAhQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg7IC8vIERlZmF1bHQgLTEsMjM0LjU2IOKCrFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OyAvLyBEZWZhdWx0IC0kMSwyMzQuNTZcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldHMgdGhlIGRlZmF1bHQgdmFsdWUgaWYgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBpcyBgbnVsbGBcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3JyZWN0IHRoZSBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIGFuZCBgc2VsZWN0T25Gb2N1c2Agb3B0aW9ucywgc2luY2Ugc2V0dGluZyBib3RoIGxlYWRzIHRvIGEgY29uZmxpY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYW4gYXJndW1lbnQgYnkgdGhlIHVzZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9jb3JyZWN0Q2FyZXRQb3NpdGlvbk9uRm9jdXNBbmRTZWxlY3RPbkZvY3VzT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIHNldCB0aGUgYGNhcmV0UG9zaXRpb25PbkZvY3VzYCBvcHRpb24sIGRvIG5vdCBzZXQgYHNlbGVjdE9uRm9jdXNgIHRvIGB0cnVlYCBieSBkZWZhdWx0XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMpICYmIEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShvcHRpb25zLnNlbGVjdE9uRm9jdXMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdE9uRm9jdXMgPSBBdXRvTnVtZXJpYy5vcHRpb25zLnNlbGVjdE9uRm9jdXMuZG9Ob3RTZWxlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXMgc2V0IHRoZSBgc2VsZWN0T25Gb2N1c2Agb3B0aW9uIHRvIGB0cnVlYCwgc2V0IGBjYXJldFBvc2l0aW9uT25Gb2N1c2AgdG8gYGRvTm9Gb3JjZUNhcmV0UG9zaXRpb25gXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cykgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShvcHRpb25zLnNlbGVjdE9uRm9jdXMpICYmIG9wdGlvbnMuc2VsZWN0T25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5zZWxlY3RPbkZvY3VzLnNlbGVjdCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emUgYW5kIHNhdmUgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIGludGVnZXIgc2l6ZSBmb3IgbGF0ZXIgdXNlc1xuICAgICAqL1xuICAgIF9jYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcygpIHtcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSB0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBbbWluaW11bVZhbHVlSW50ZWdlclBhcnRdID0gKCF0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSAmJiB0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSAhPT0gMCk/W106dGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1heGltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWluaW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heChtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLnNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBhcyBuZWVkZWRcbiAgICAgKi9cbiAgICBfY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbigpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGhpcy5jb25zdHJ1Y3Rvci5fbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCh0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSwgdGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcmlnaW5hbERlY2ltYWxQbGFjZXNPdmVycmlkZSA9IFN0cmluZyh0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gTW9zdCBjYWxjdWx1cyBhc3N1bWUgYGRlY2ltYWxQbGFjZXNPdmVycmlkZWAgaXMgYW4gaW50ZWdlciwgdGhlIGZvbGxvd2luZyBzdGF0ZW1lbnQgbWFrZXMgaXQgY2xlYXIgKG90aGVyd2lzZSBoYXZpbmcgaXQgYXMgYSBzdHJpbmcgbGVhZHMgdG8gcHJvYmxlbXMgaW4gcm91bmRpbmcgZm9yIGluc3RhbmNlKVxuICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcih0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5LlxuICAgICAqL1xuICAgIF9zZXRBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmIE51bWJlcih0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLicgJiYgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLCcgJiYgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBfc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVnZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzLCByZWdleCkge1xuICAgICAgICBjb25zdCBhbGxOdW1iZXJzUmVnID0gJ1swLTldJztcbiAgICAgICAgY29uc3Qgbm9BbGxOdW1iZXJzUmVnID0gJ1teMC05XSc7XG5cbiAgICAgICAgLy8gVGVzdCBpZiB0aGVyZSBpcyBhIG5lZ2F0aXZlIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcbiAgICAgICAgcmVnZXguYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG5cbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnblJlZ1BhcnQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSBgXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25SZWdQYXJ0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHtuZWdhdGl2ZVNpZ25SZWdQYXJ0fVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfV0uKj8oJHthbGxOdW1iZXJzUmVnfXxcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKCR7YWxsTnVtYmVyc1JlZ31cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dJHtub0FsbE51bWJlcnNSZWd9KiRgKTtcblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8oJHthbGxOdW1iZXJzUmVnfStcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30rKXwoJHthbGxOdW1iZXJzUmVnfSooPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30qKT8pKWApO1xuXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7cmVnZXguYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgc2V0dGluZ3Muc3RyaXBSZWcgPSBuZXcgUmVnRXhwKGBeJHtyZWdleC5hTmVnUmVnQXV0b1N0cmlwfTAqKCR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnIGxhdGVyLlxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2V0dGluZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZ3MgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMgaW4gb3B0aW9ucyB0byBzdHJpbmdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIE9ubHkgdHJhbnNmb3JtIHRoZSB2YWx1ZXMgb2YgdHlwZSAnTnVtYmVyJyB0byAnU3RyaW5nJyBpZiBpdCdzIGEgY3VycmVuY3kgbnVtYmVyIChzbyB0aGF0IHdlIGNhbiBoYXZlIGJpZyBudW1iZXJzKS4gRG8gbm90IGNvbnZlcnQgb3RoZXIgbnVtYmVycyAoaWUuIGBoaXN0b3J5U2l6ZWApXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBvbGQgc2V0dGluZ3Mgb3B0aW9ucyBuYW1lIHRvIG5ldyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcbiAgICAgICAgLy9UT0RPIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgdGhlIG9sZCBvcHRpb25zIGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnNDb252ZXJ0ZXIgPSB7XG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWVzLCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbmV3IG5hbWVzXG4gICAgICAgICAgICBhU2VwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXG4gICAgICAgICAgICBuU2VwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9TZXBhcmF0b3JPbkZvY3VzJyxcbiAgICAgICAgICAgIGRHcm91cCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdGFsR3JvdXBTcGFjaW5nJyxcbiAgICAgICAgICAgIGFEZWMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyJyxcbiAgICAgICAgICAgIGFsdERlYyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnLFxuICAgICAgICAgICAgYVNpZ24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sJyxcbiAgICAgICAgICAgIHBTaWduICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcsXG4gICAgICAgICAgICBwTmVnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnLFxuICAgICAgICAgICAgYVN1ZmZpeCAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N1ZmZpeFRleHQnLFxuICAgICAgICAgICAgb0xpbWl0cyAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ292ZXJyaWRlTWluTWF4TGltaXRzJyxcbiAgICAgICAgICAgIHZNYXggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtYXhpbXVtVmFsdWUnLFxuICAgICAgICAgICAgdk1pbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pbmltdW1WYWx1ZScsXG4gICAgICAgICAgICBtRGVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyxcbiAgICAgICAgICAgIGVEZWMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyxcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbCAgICAgICAgICAgICAgICAgICAgICA6ICdzY2FsZURlY2ltYWxQbGFjZXMnLFxuICAgICAgICAgICAgYVN0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnLFxuICAgICAgICAgICAgbVJvdW5kICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3JvdW5kaW5nTWV0aG9kJyxcbiAgICAgICAgICAgIGFQYWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbGxvd0RlY2ltYWxQYWRkaW5nJyxcbiAgICAgICAgICAgIG5CcmFja2V0ICAgICAgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicsXG4gICAgICAgICAgICB3RW1wdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZW1wdHlJbnB1dEJlaGF2aW9yJyxcbiAgICAgICAgICAgIGxaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdsZWFkaW5nWmVybycsXG4gICAgICAgICAgICBhRm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZm9ybWF0T25QYWdlTG9hZCcsXG4gICAgICAgICAgICBzTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2VsZWN0TnVtYmVyT25seScsXG4gICAgICAgICAgICBhbkRlZmF1bHQgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgdW5TZXRPblN1Ym1pdCAgICAgICAgICAgICAgICAgICAgIDogJ3VuZm9ybWF0T25TdWJtaXQnLFxuICAgICAgICAgICAgb3V0cHV0VHlwZSAgICAgICAgICAgICAgICAgICAgICAgIDogJ291dHB1dEZvcm1hdCcsXG4gICAgICAgICAgICBkZWJ1ZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd1dhcm5pbmdzJyxcblxuICAgICAgICAgICAgLy8gQ3VycmVudCBvcHRpb25zIDpcbiAgICAgICAgICAgIGFsbG93RGVjaW1hbFBhZGRpbmcgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Gb2N1cyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlTG9jYWxMaXN0ICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBmYWlsT25Vbmtub3duT3B0aW9uICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhpc3RvcnlTaXplICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBpc0NhbmNlbGxhYmxlICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbW9kaWZ5VmFsdWVPbldoZWVsICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbm9FdmVudExpc3RlbmVycyAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICByZWFkT25seSAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWxQbGFjZXMgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVEaXZpc29yICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlU3ltYm9sICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0T25Gb2N1cyAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZVNwYWNlcyAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzaG93UG9zaXRpdmVTaWduICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2hvd1dhcm5pbmdzICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlUnVsZXMgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzdWZmaXhUZXh0ICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdW5mb3JtYXRPbkhvdmVyICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB3aGVlbFN0ZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBgc2V0dGluZ3NgIG9iamVjdCA6XG4gICAgICAgICAgICAvL0ZJWE1FIEZpbmQgYSB3YXkgdG8gZXhjbHVkZSB0aG9zZSBpbnRlcm5hbCBkYXRhIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCAoaWRlYWxseSBieSB1c2luZyBhbm90aGVyIG9iamVjdCwgb3IgYmV0dGVyIHlldCwgY2xhc3MgYXR0cmlidXRlcykgLS0+XG4gICAgICAgICAgICBhbGxvd2VkQXV0b1N0cmlwICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbUludE5lZyAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnRQb3MgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbnVtUmVnQXV0b1N0cmlwICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aXZlU2lnbkNoYXJhY3RlciAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcEZpcnN0QXV0b1N0cmlwICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBMYXN0QXV0b1N0cmlwICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzdHJpcFJlZyAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXMgYSAnbmV3JyBvcHRpb24sIHdlIGNvbnRpbnVlIGxvb3BpbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXIuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHdlIGhhdmUgYW4gJ29sZCcgb3B0aW9uIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgWW91IGFyZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBvcHRpb24gbmFtZSAnJHtvcHRpb259Jy4gUGxlYXNlIHVzZSAnJHtvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl19JyBpbnN0ZWFkIGZyb20gbm93IG9uLiBUaGUgb2xkIG9wdGlvbiBuYW1lIHdpbGwgYmUgZHJvcHBlZCBzb29uLmAsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gd2UgbW9kaWZ5IHRoZSBpbml0aWFsIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBuZXcgb3B0aW9ucyBpbnN0ZWFkIG9mIHRoZSBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXV0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3IgdGhlIG9wdGlvbiBuYW1lIGlzIHVua25vd24uIFRoaXMgbWVhbnMgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVyZWZvcmUgd2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYE9wdGlvbiBuYW1lICcke29wdGlvbn0nIGlzIHVua25vd24uIFBsZWFzZSBmaXggdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGF1dG9OdW1lcmljYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHlzZSB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBwYXNzZWQgYnkgdGhlIHVzZXIsIHZhbGlkYXRlIGFuZCBjbGVhbiB0aGVtLCB0aGVuIHNldCB0aGVtIGludG8gYHRoaXMuc2V0dGluZ3NgLlxuICAgICAqIE5vdGU6IFRoaXMgc2V0cyB0aGUgc2V0dGluZ3MgdG8gYG51bGxgIGlmIHNvbWVob3cgdGhlIHNldHRpbmdzIG9iamV0IGlzIHVuZGVmaW5lZCBvciBlbXB0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBfc2V0U2V0dGluZ3Mob3B0aW9ucywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIHVwZGF0ZWRcbiAgICAgICAgICAgIHRoaXMuX21lcmdlU2V0dGluZ3Mob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhcyB3ZWxsIGFzIHdpdGggdGhlIEhUTUw1IGBkYXRhLSpgIGluZm8gKHZpYSBgdGhpcy5kb21FbGVtZW50LmRhdGFzZXRgKSwgaWYgYW55LlxuICAgICAgICAgICAgdGhpcy5fbWVyZ2VTZXR0aW5ncyh0aGlzLmNvbnN0cnVjdG9yLmdldERlZmF1bHRDb25maWcoKSwgdGhpcy5kb21FbGVtZW50LmRhdGFzZXQsIG9wdGlvbnMsIHsgcmF3VmFsdWUgOiAnJyB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXRGaXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IHRydWU7IC8vIFRocm93IGlucHV0IGV2ZW50XG4gICAgICAgICAgICB0aGlzLmFsbG93ZWRUYWdMaXN0ID0gQXV0b051bWVyaWNFbnVtLmFsbG93ZWRUYWdMaXN0O1xuICAgICAgICAgICAgdGhpcy5ydW5PbmNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhvdmVyZWRXaXRoQWx0ID0gZmFsc2U7IC8vIEtlZXAgdHJhY2tzIGlmIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIGVsZW1lbnQgaXMgaG92ZXJlZCBieSB0aGUgbW91c2UgY3Vyc29yIHdoaWxlIGBBbHRgIGlzIHByZXNzZWRcbiAgICAgICAgICAgIHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gbnVsbDsgLy8gSWYgYG51bGxgLCB0aGVuIHdlIGFyZSBub3Qgb24gYW4gQW5kcm9pZCBkZXZpY2UgKHRoZSBrZXlDb2RlIGlzIG5vdCBhbHdheXMgZXF1YWwgdG8gMjI5KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcygpO1xuXG4gICAgICAgIC8vIEltcHJvdmUgdGhlIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGlmIG5lZWRlZFxuICAgICAgICB0aGlzLl9jb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGBjYXJldFBvc2l0aW9uT25Gb2N1c2AgYW5kIGBzZWxlY3RPbkZvY3VzYCBvcHRpb25zIHNvIHRoYXQgdGhleSBkbyBub3QgY29uZmxpY3QsIGlmIG9uZSBvZiB0aG9zZSBoYXZlIGJlZW4gc2V0IG1hbnVhbGx5IGJ5IHRoZSB1c2VyLlxuICAgICAgICAvLyBJZiBvcmRlciB0byBjaGVjayB0aGF0LCB3ZSB0YWtlIGEgbG9vayBhdCB0aGUgb3JpZ2luYWwgb3B0aW9ucyB0aGUgdXNlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQsIG5vdCBgdGhpcy5zZXR0aW5nc2AgdGhhdCBoYXZlIGJlZW4gbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgc2V0dGluZ3MuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb3JyZWN0Q2FyZXRQb3NpdGlvbk9uRm9jdXNBbmRTZWxlY3RPbkZvY3VzT3B0aW9ucyh0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBTZXQgdGhlIG5lZ2F0aXZlIGFuZCBwb3NpdGl2ZSBzaWducywgYXMgbmVlZGVkXG4gICAgICAgIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gdGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyID0gdGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWUgPj0gMCA/ICcrJyA6ICcnO1xuXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgY2hhbmdlcyB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgpO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcygpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uKCk7XG4gICAgICAgIHRoaXMuX3NldEFsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcigpO1xuICAgICAgICB0aGlzLl9zZXRUcmFpbGluZ05lZ2F0aXZlU2lnbkluZm8oKTtcbiAgICAgICAgdGhpcy5yZWdleCA9IHt9OyAvLyBDcmVhdGUgdGhlIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnModGhpcy5zZXR0aW5ncywgdGhpcy5yZWdleCk7XG4gICAgICAgIHRoaXMuX3NldEJyYWNrZXRzKCk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzLiBCb3RoIHRlc3RzIHRocm93cyBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IudmFsaWRhdGUodGhpcy5zZXR0aW5ncywgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNFbXB0eU9iaih0aGlzLnNldHRpbmdzKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcignVW5hYmxlIHRvIHNldCB0aGUgc2V0dGluZ3MsIHRob3NlIGFyZSBpbnZhbGlkIDsgYW4gZW1wdHkgb2JqZWN0IHdhcyBnaXZlbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzLCBzY2FsZURpdmlzb3IgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICB0aGlzLl9rZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyIHRoYXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICogLSBhIHJlYWwgbnVtYmVyLFxuICAgICAqIC0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVhbCBudW1iZXIsIG9yXG4gICAgICogLSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBsb2NhbGl6ZWQgbnVtYmVyICh3aXRoIHNwZWNpZmljIGdyb3VwIHNlcGFyYXRvcnMgYW5kIGRlY2ltYWwgY2hhcmFjdGVyKSxcbiAgICAgKiAuLi50byBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWFsICdqYXZhc2NyaXB0JyBudW1iZXIgKGllLiAnMTIzNCcgb3IgJzEyMzQuNTY3JykuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYE5hTmAgaWYgc3VjaCBjb252ZXJzaW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR8ZmxvYXR8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TmFOfVxuICAgICAqL1xuICAgIHN0YXRpYyBfdG9OdW1lcmljVmFsdWUodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vWFhYIE5vdGU7IHRoaXMgZnVuY3Rpb24gaXMgc3RhdGljIHNpbmNlIHdlIG5lZWQgdG8gcGFzcyBhIGBzZXR0aW5nc2Agb2JqZWN0IHdoZW4gY2FsbGluZyB0aGUgc3RhdGljIGBBdXRvTnVtZXJpYy5mb3JtYXQoKWAgbWV0aG9kXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGhhcyBlaXRoZXIgYWxyZWFkeSBiZWVuIHN0cmlwcGVkLCBvciBhICdyZWFsJyBqYXZhc2NyaXB0IG51bWJlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRWxzZSBpZiBpdCdzIGEgc3RyaW5nIHRoYXQgYE51bWJlcigpYCBjYW5ub3QgdHlwZWNhc3QsIHRoZW4gd2UgdHJ5IHRvIGNvbnZlcnQgdGhlIGxvY2FsaXplZCBudW1lcmljIHN0cmluZyB0byBhIG51bWVyaWMgb25lXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWVyaWMgc3RyaW5nLCBzdHJpcHBpbmcgdW5uZWNlc3NhcnkgY2hhcmFjdGVycyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fY29udmVydFRvTnVtZXJpY1N0cmluZyh2YWx1ZS50b1N0cmluZygpLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc3RpbGwgbm90IGEgbnVtZXJpYyBzdHJpbmcsIHRoZW4gd2UgdGhyb3cgYSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKE51bWJlcihyZXN1bHQpKSkge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCwgc2V0dGluZ3Muc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBfcHJlcGFyZVBhc3RlZFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRleHQsIHRoaXMuc2V0dGluZ3MsIHRydWUsIHRoaXMuaXNGb2N1c2VkKS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gdmFsdWUgKGEgbnVtYmVyIGFzIGEgc3RyaW5nKSBpcyB3aXRoaW4gdGhlIHJhbmdlIHNldCBpbiB0aGUgc2V0dGluZ3MgYG1pbmltdW1WYWx1ZWAgYW5kIGBtYXhpbXVtVmFsdWVgLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWluVmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1heFZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBfY2hlY2tJZkluUmFuZ2UodmFsdWUsIHBhcnNlZE1pblZhbHVlLCBwYXJzZWRNYXhWYWx1ZSkge1xuICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLnBhcnNlU3RyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEF1dG9OdW1lcmljSGVscGVyLnRlc3RNaW5NYXgocGFyc2VkTWluVmFsdWUsIHBhcnNlZFZhbHVlKSA+IC0xICYmIEF1dG9OdW1lcmljSGVscGVyLnRlc3RNaW5NYXgocGFyc2VkTWF4VmFsdWUsIHBhcnNlZFZhbHVlKSA8IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZWxlY3Rpb24gdmFsdWVzIGFzIHdlbGwgYXMgcmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBvYmplY3QuXG4gICAgICogVGhpcyBrZWVwcyB0cmFja3Mgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCByZXNldHMgdGhlICdwcm9jZXNzZWQnIGFuZCAnZm9ybWF0dGVkJyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgOiBUaG9zZSB0d28gY2FuIGNoYW5nZSBiZXR3ZWVuIHRoZSBrZXlkb3duLCBrZXlwcmVzcyBhbmQga2V5dXAgZXZlbnRzLCB0aGF0J3Mgd2h5XG4gICAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggZXZlbnQgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUludGVybmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBgZXZlbnQua2V5YCBhdHRyaWJ1dGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogYGV2ZW50LmtleWAgZGVzY3JpYmVzOlxuICAgICAqIC0gdGhlIGtleSBuYW1lIChpZiBhIG5vbi1wcmludGFibGUgY2hhcmFjdGVyKSxcbiAgICAgKiAtIG9yIGRpcmVjdGx5IHRoZSBjaGFyYWN0ZXIgdGhhdCByZXN1bHQgZnJvbSB0aGUga2V5IHByZXNzIHVzZWQgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgKiBUaGUga2V5IGxpc3QgaXMgZGVzY3JpYmVkIGhlcmU6XG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5L0tleV9WYWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR8S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUV2ZW50S2V5SW5mbyhlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRLZXkgPSBBdXRvTnVtZXJpY0hlbHBlci5jaGFyYWN0ZXIoZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgdW5mb3JtYXR0ZWQgZWxlbWVudCB2YWx1ZS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlICdjYW5jZWxsYWJsZScgZmVhdHVyZSB3aGVyZSB0aGUgZWxlbWVudCB2YWx1ZSBpcyBzYXZlZCBvbiBmb2N1cyBhbmQgaW5wdXQgdmFsaWRhdGlvbiwgdG8gYmUgdXNlZCBpZiB0aGUgdXNlciB3YW50cyB0byBjYW5jZWwgaGlzIG1vZGlmaWNhdGlvbnMgYnkgaGl0dGluZyB0aGUgJ0VzY2FwZScga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZUNhbmNlbGxhYmxlVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuc2F2ZWRDYW5jZWxsYWJsZVZhbHVlID0gdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRleHQgc2VsZWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgd2l0aCB0aGUgZ2l2ZW4gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxuICAgICAqIEBwYXJhbSB7aW50fSBlbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICAvL1RPRE8gdXNlIHRoaXMgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aGUgZGlyZWN0IGNhbGxzIHRvIGBzZXRFbGVtZW50U2VsZWN0aW9uKClgLCB3aGVyZXZlciBwb3NzaWJsZVxuICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5sZW5ndGgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgICAgfTtcblxuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYXJldCBwb3NpdGlvbiBpbnNpZGUgdGhlIGlucHV0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBwYXJ0cyBsb2NhdGVkIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24uXG4gICAgICogVGhvc2UgcGFydHMgYXJlIGxlZnQgJ3VudG91Y2hlZCcsIGllLiBmb3JtYXR0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX0gVGhlIHBhcnRzIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdmFsdWUuc3Vic3RyaW5nKHRoaXMuc2VsZWN0aW9uLmVuZCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cbiAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgdW5mb3JtYXR0ZWQgKHN0cmlwcGVkKSBvZiBhbnkgbm9uLW51bWJlcnMgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb24sIHVuZm9ybWF0dGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNoYW5naW5nIHRoZSBzaWduIGFuZCBgbGVmdGAgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvLCBwcmV2ZW50IHN0cmlwcGluZyB0aGUgbGVhZGluZyB6ZXJvKHMpXG4gICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkh5cGhlbiAmJiBOdW1iZXIobGVmdCkgPT09IDApIHtcbiAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVHJhaWxpbmdOZWdhdGl2ZSAmJlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShyaWdodCkgJiZcbiAgICAgICAgICAgICFBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKGxlZnQpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgbmVnYXRpdmUgc2lnbiBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0ID0gQXV0b051bWVyaWMuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCB0aGlzLnNldHRpbmdzLCBzdHJpcFplcm9zLCB0aGlzLmlzRm9jdXNlZCk7XG4gICAgICAgIHJpZ2h0ID0gQXV0b051bWVyaWMuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgdGhpcy5zZXR0aW5ncywgZmFsc2UsIHRoaXMuaXNGb2N1c2VkKTtcblxuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBwYXJ0cyBmcm9tIGV4Y2VzcyBjaGFyYWN0ZXJzIGFuZCBsZWFkaW5nIHplcm9zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAgICAgKiBAcmV0dXJucyB7WyosKiwqXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAvL1RPRE8gUmVmYWN0b3Igd2l0aCBgX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbmAgd2hpY2ggc2hhcmUgYSBsb3Qgb2Ygc2ltaWxhciBjb2RlXG4gICAgICAgIC8vIGlmIGNoYW5naW5nIHRoZSBzaWduIGFuZCBsZWZ0IGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgemVybyAtIHByZXZlbnRzIHN0cmlwcGluZyB0aGUgbGVhZGluZyB6ZXJvc1xuICAgICAgICBsZXQgc3RyaXBaZXJvcyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XG4gICAgICAgICAgICBzdHJpcFplcm9zID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1RyYWlsaW5nTmVnYXRpdmUgJiZcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUocmlnaHQpICYmXG4gICAgICAgICAgICAhQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShsZWZ0KSkge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVmdCA9IEF1dG9OdW1lcmljLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgdGhpcy5zZXR0aW5ncywgc3RyaXBaZXJvcywgdGhpcy5pc0ZvY3VzZWQpO1xuICAgICAgICByaWdodCA9IEF1dG9OdW1lcmljLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocmlnaHQsIHRoaXMuc2V0dGluZ3MsIGZhbHNlLCB0aGlzLmlzRm9jdXNlZCk7XG5cbiAgICAgICAgLy8gUHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSAmJlxuICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLm51bTAgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUubnVtcGFkMCkgJiZcbiAgICAgICAgICAgIE51bWJlcihsZWZ0KSA9PT0gMCAmJlxuICAgICAgICAgICAgLy8gSWYgYHJpZ2h0YCBpcyBub3QgZW1wdHkgYW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGBkZWNpbWFsQ2hhcmFjdGVyYFxuICAgICAgICAgICAgIUF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKGxlZnQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikgJiYgcmlnaHQgIT09ICcnKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCB6ZXJvIHRoZXJlIGlzIGEgbGVhZGluZyBkb3RcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3VmFsdWUubWF0Y2gobmV3IFJlZ0V4cChgXiR7dGhpcy5yZWdleC5hTmVnUmVnQXV0b1N0cmlwfVxcXFwke3RoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gKSk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0LCBuZXdWYWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvbi4gLy9UT0RPIFdoYXQgYWJvdXQgdGhlIGN1cnNvciBzZWxlY3Rpb24/XG4gICAgICogVGhpcyBmdW5jdGlvbiBhbHNvIHNldHMgdGhlIHJhdyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bhc3RlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgaXNQYXN0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IFtub3JtYWxpemVkTGVmdCwgbm9ybWFsaXplZFJpZ2h0LCBub3JtYWxpemVkTmV3VmFsdWVdID0gdGhpcy5fbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBBdXRvTnVtZXJpYy5fY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24obm9ybWFsaXplZE5ld1ZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gbm9ybWFsaXplZExlZnQubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSBub3JtYWxpemVkTmV3VmFsdWU7XG5cbiAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBBdXRvTnVtZXJpYy5fdHJ1bmNhdGVEZWNpbWFsUGxhY2VzKG5ld1ZhbHVlLCB0aGlzLnNldHRpbmdzLCBpc1Bhc3RlKTtcbiAgICAgICAgICAgIC8vVE9ETyBDaGVjayBpZiB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGhhcmQtY29kZWQgJywnIHdpdGggc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlclxuICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKEF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKG5ld1ZhbHVlLCAnLCcpKSA/IG5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUoKHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci56ZXJvKSA/ICcwJyA6ICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUodGhpcy5fdHJpbUxlYWRpbmdBbmRUcmFpbGluZ1plcm9zKHRlc3RWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiBuZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMSAmJiBub3JtYWxpemVkTGVmdCA9PT0gJzAnICYmIHRoaXMuc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGVudGVyIGAwYCwgdGhlbiB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSByaWdodCBzaWRlIG9mIGl0IChGaXggaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFJpZ2h0ID09PSAnJyB8fCBub3JtYWxpemVkTGVmdCA9PT0gJzAnICYmIG5vcm1hbGl6ZWRSaWdodCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5taW5SYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm1heFJhbmdlRXhjZWVkZWQsIHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBbc2lnblBvc2l0aW9uLCBjdXJyZW5jeVN5bWJvbFBvc2l0aW9uXSBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgdmFsdWUgJiYgdmFsdWUuY2hhckF0KDApID09PSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsxLCBjdXJyZW5jeVN5bWJvbExlbiArIDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFswLCBjdXJyZW5jeVN5bWJvbExlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdmFsdWVMZW4gLSBjdXJyZW5jeVN5bWJvbExlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gWzEwMDAsIC0xXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAqIFByZXZlbnRzIHBhcnRpYWwgZGVsZXRpb24vY29weWluZy9vdmVyd3JpdGluZyBvZiBhIHNpZ25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leHBhbmRTZWxlY3Rpb25PblNpZ24oKSB7XG4gICAgICAgIGNvbnN0IFtzaWduUG9zaXRpb24sIGN1cnJlbmN5U3ltYm9sUG9zaXRpb25dID0gdGhpcy5fZ2V0U2lnblBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgIC8vIElmIHNlbGVjdGlvbiBjYXRjaGVzIHNvbWV0aGluZyBleGNlcHQgc2lnbiBhbmQgY2F0Y2hlcyBvbmx5IHNwYWNlIGZyb20gc2lnblxuICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgY3VycmVuY3lTeW1ib2xQb3NpdGlvbiAmJiBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBUaGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvbiB8fCBzZWxlY3Rpb24uZW5kID4gY3VycmVuY3lTeW1ib2xQb3NpdGlvbikgJiZcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb24pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBjdXJyZW5jeVN5bWJvbFBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oY3VycmVuY3lTeW1ib2xQb3NpdGlvbiwgc2VsZWN0aW9uLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFbHNlIHNlbGVjdCB3aXRoIHdob2xlIHNpZ25cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oTWF0aC5taW4oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb24pLCBNYXRoLm1heChzZWxlY3Rpb24uZW5kLCBjdXJyZW5jeVN5bWJvbFBvc2l0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAqL1xuICAgIF9jaGVja1Bhc3RlKCkge1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBzdHJpcCB0aGUgcGFzdGVkIHZhbHVlIGZpcnN0XG4gICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0LnN1YnN0cigwLCBvbGRQYXJ0c1swXS5sZW5ndGgpICsgQXV0b051bWVyaWMuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzLCB0cnVlLCB0aGlzLmlzRm9jdXNlZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NldFZhbHVlUGFydHMobW9kaWZpZWRMZWZ0UGFydCwgcmlnaHQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCwgb2xkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaXMgdGhlIGdpdmVuIGtleSBzaG91bGQgYmUgaWdub3JlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRLZXlOYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Nob3VsZFNraXBFdmVudEtleShldmVudEtleU5hbWUpIHtcbiAgICAgICAgY29uc3QgaXNGbktleXMgPSBBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkoZXZlbnRLZXlOYW1lLCBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5fYWxsRm5LZXlzKTtcbiAgICAgICAgY29uc3QgaXNPU0tleXMgPSBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk9TTGVmdCB8fCBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk9TUmlnaHQ7XG4gICAgICAgIGNvbnN0IGlzQ29udGV4dE1lbnUgPSBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkNvbnRleHRNZW51O1xuICAgICAgICBjb25zdCBpc1NvbWVOb25QcmludGFibGVLZXlzID0gQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KGV2ZW50S2V5TmFtZSwgQXV0b051bWVyaWNFbnVtLmtleU5hbWUuX3NvbWVOb25QcmludGFibGVLZXlzKTtcbiAgICAgICAgY29uc3QgaXNPdGhlck5vblByaW50YWJsZUtleXMgPSBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bUxvY2sgfHxcbiAgICAgICAgICAgIGV2ZW50S2V5TmFtZSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5JbnNlcnQgfHxcbiAgICAgICAgICAgIGV2ZW50S2V5TmFtZSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQ29tbWFuZDtcbiAgICAgICAgY29uc3QgaXNVbnJlY29nbml6YWJsZUtleXMgPSBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlVuaWRlbnRpZmllZDtcblxuICAgICAgICByZXR1cm4gaXNGbktleXMgfHwgaXNPU0tleXMgfHwgaXNDb250ZXh0TWVudSB8fCBpc1NvbWVOb25QcmludGFibGVLZXlzIHx8IGlzVW5yZWNvZ25pemFibGVLZXlzIHx8IGlzT3RoZXJOb25QcmludGFibGVLZXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgY29weWluZywgY3V0dGluZyBhbmQgcGFzdGluZywgYXMgd2VsbCBhcyB1bmRvL3JlZG9pbmcgYW5kIGN1cnNvciBtb3ZpbmcuXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiBmdXJ0aGVyIHByb2Nlc3Npbmcgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzTm9uUHJpbnRhYmxlS2V5c0FuZFNob3J0Y3V0cyhlKSB7XG4gICAgICAgIC8vIENhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICBpZiAoKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKGUuc2hpZnRLZXkgJiYgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuSW5zZXJ0KSkge1xuICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhpcyB0ZXN0IGluc2lkZSB0aGUgYG9uS2V5dXBgIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBhbGwgZnVuY3Rpb24ga2V5cyAoRjEtRjEyKSwgV2luZG93cyBrZXlzLCB0YWIgYW5kIG90aGVyIHNwZWNpYWwga2V5c1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fc2hvdWxkU2tpcEV2ZW50S2V5KHRoaXMuZXZlbnRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgXCJTZWxlY3QgYWxsXCIga2V5Ym9hcmQgc2hvcnRjdXQgaXMgZGV0ZWN0ZWQgKGN0cmwgKyBhKVxuICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLmEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaXMgdXNlZCBoZXJlIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gZmlyc3Qgc2VsZWN0IGFsbCB0aGUgaW5wdXQgdGV4dCAoaW5jbHVkaW5nIHRoZSBjdXJyZW5jeSBzaWduKSwgb3RoZXJ3aXNlIHdlIHdvdWxkIHNlZSB0aGF0IHdob2xlIHNlbGVjdGlvbiBmaXJzdCBpbiBhIGZsYXNoLCB0aGVuIHRoZSBzZWxlY3Rpb24gd2l0aCBvbmx5IHRoZSBudW1iZXIgcGFydCB3aXRob3V0IHRoZSBjdXJyZW5jeSBzaWduLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gcmVwbGFjZSBgc2VsZWN0TnVtYmVyYCBieSBgc2VsZWN0YD9cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE51bWJlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgXCJDb3B5XCIsIFwiUGFzdGVcIiBvciBcIkN1dFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChyZXNwZWN0aXZlbHkgJ2N0cmwgKyBjJywgJ2N0cmwgKyB2JyBvciAnY3RybCArIHgnKVxuICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5jIHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLnYgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUueCkpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLnYgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuWiB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS56KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEp1bXAgb3ZlciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleWRvd25gIGhhbmRsZXJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkxlZnRBcnJvdyB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5MZWZ0QXJyb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMikgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuUmlnaHRBcnJvdyAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSkgPT09IHRoaXMuc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKSA9PT0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkodGhpcy5ldmVudEtleSwgQXV0b051bWVyaWNFbnVtLmtleU5hbWUuX2RpcmVjdGlvbktleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnQgVGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodCBUaGUgcGFydCBvbiB0aGUgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQpICYmIHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dCAhPT0gJycpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHZhbHVlLmxlbmd0aCAtIHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0KSAmJiB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQgIT09ICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKSArIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKGxlZnQpICYmIHZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSAmJiBBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgfHwgIUF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKHZhbHVlLCB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIEF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKHZhbHVlLCB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIC0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKSB7XG4gICAgICAgIGxldCBsZWZ0O1xuICAgICAgICBsZXQgcmlnaHQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmFpbGluZ05lZ2F0aXZlICYmIEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBhbGxvd2VkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGVjaWRlcyBpZiB0aGUga2V5IHByZXNzZWQgc2hvdWxkIGJlIGRyb3BwZWQgb3IgYWNjZXB0ZWQsIGFuZCBtb2RpZnkgdGhlIHZhbHVlICdvbi10aGUtZmx5JyBhY2NvcmRpbmdseS5cbiAgICAgKiAvL1RPRE8gVGhpcyBzaG91bGQgdXNlIGFub3RoZXIgZnVuY3Rpb24gaW4gb3JkZXIgdG8gc2VwYXJhdGUgdGhlIHRlc3QgYW5kIHRoZSBtb2RpZmljYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIF9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKCkge1xuICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5ldmVudEtleSAhPT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQW5kcm9pZERlZmF1bHQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBydWxlcyB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBrZXkgaXMgcHJlc3NlZCBhbHdheXMgdXNlIG51bWVyaWMgcGFkIGRvdCB0byBpbnNlcnQgZGVjaW1hbCBzZXBhcmF0b3JcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgfHxcbiAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiB0aGlzLmV2ZW50S2V5ID09PSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgfHxcbiAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5ID09PSAnLicgfHwgdGhpcy5ldmVudEtleSA9PT0gJywnIHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZERvdCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgfHwgIXRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIG5lZ2F0aXZlU2lnbkNoYXJhY3RlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhyaWdodCwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBhIGRlY2ltYWwgY2hhcmFjdGVyIGlmIGFub3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMobGVmdCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZih0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZih0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgcmlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgZW50ZXJpbmcgdGhlIG1pbnVzIHNpZ24gaWYgaXQncyBub3QgYWxsb3dlZCAoTm90ZTogYHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBpcyBvbmx5IHNldCBpZiB0aGUgbWluaW11bVZhbHVlIG9yIG1heGltdW1WYWx1ZSBpcyBsb3dlciB0aGFuIHplcm8sIGFsbG93aW5nIG5lZ2F0aXZlIG51bWJlcnMgdG8gYmUgZW50ZXJlZClcbiAgICAgICAgaWYgKCh0aGlzLmV2ZW50S2V5ID09PSAnLScgfHwgdGhpcy5ldmVudEtleSA9PT0gJysnKSAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9PT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMocmlnaHQsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IG5lZ2F0aXZlICh3aXRoIGEgdHJhaWxpbmcgbmVnYXRpdmUgc2lnbilcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnJlcGxhY2UodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShsZWZ0KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IG5lZ2F0aXZlICh3aXRoIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduKVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnbiwgZWZmZWN0aXZlbHkgY29udmVydGluZyB0aGUgdmFsdWUgdG8gYSBwb3NpdGl2ZSBvbmVcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpOyAvL1RPRE8gcmVwbGFjZSB3aXRoICcrJyBpZiBgc2hvd1Bvc2l0aXZlU2lnbmA/XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgbGVmdCA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdHJpZXMgdG8gaW5zZXJ0IGEgZGlnaXQgYmVmb3JlIHRoZSBtaW51cyBzaWduXG4gICAgICAgIGNvbnN0IGV2ZW50TnVtYmVyID0gTnVtYmVyKHRoaXMuZXZlbnRLZXkpO1xuICAgICAgICBpZiAoZXZlbnROdW1iZXIgPj0gMCAmJiBldmVudE51bWJlciA8PSA5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgbGVmdCA9PT0gJycgJiYgQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMocmlnaHQsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWUgPD0gMCAmJiB0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IHRoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlICYmICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIHRoaXMuZXZlbnRLZXkgIT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHRoaXMuZXZlbnRLZXksIHJpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdFZhbHVlKGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcblxuICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgID09PSAnJyB8fCAodGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJyAgJiYgIUF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKGVsZW1lbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yKSkpICYmXG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhlbGVtZW50VmFsdWUsIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpKSkpIHtcbiAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gZWxlbWVudFZhbHVlLnNwbGl0KHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmVTaWduID0gJyc7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShzdWJQYXJ0cykpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZVNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChuZWdhdGl2ZVNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChuZWdhdGl2ZVNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiB0aGlzLnNldHRpbmdzLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ID0gbmVnYXRpdmVTaWduICsgbGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fYWRkR3JvdXBTZXBhcmF0b3JzKGVsZW1lbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncywgdGhpcy5pc0ZvY3VzZWQpO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgIC8vIEZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxuICAgICAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeCAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkpICYmXG4gICAgICAgICAgICAgICAgbGVmdEFyWzBdID09PSAnLScgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkJhY2tzcGFjZSB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5EZWxldGUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXggJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4ICYmIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnblBhcnRzLmZvckVhY2goKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcblxuICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb3NpdGl2ZSBzaWduIGlzIHNob3duLCBjYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgbmV3TGVmdC5pbnB1dC5jaGFyQXQoMCkgPT09IHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IChuZXdMZWZ0LmlucHV0LmluZGV4T2YodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkgPT09IDEpID8gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAxIDogMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdCh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkgPT09IHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB0aGUgdGVzdCBiZSAnaXNOZWdhdGl2ZScgaW5zdGVhZCBvZiAnaXNOZWdhdGl2ZVN0cmljdCcgaW4gb3JkZXIgdG8gc2VhcmNoIGZvciAnLScgZXZlcnl3aGVyZSBpbiB0aGUgc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVTdHJpY3QodmFsdWUpID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4IGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gVGhpcyBwcmV2ZW50cyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbiwgaWYgYW55LlxuICAgICAgICBpZiAodmFsdWUgIT09IGVsZW1lbnRWYWx1ZSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IGVsZW1lbnRWYWx1ZSAmJiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUubnVtMCB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5udW1wYWQwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBBbmRyb2lkIGJyb3dzZXIgaXMgZGV0ZWN0ZWQsIGZpeCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhpcyBkb2VzIG5vdCBmaXggYWxsIGFuZHJvaWQgYnJvd3NlcnMsIG9ubHkgQW5kcm9pZCBDaHJvbWUgY3VycmVudGx5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhvc2UgcHJvdmlkZSBkaWZmZXJlbnQgb3JkZXIgb2YgZXZlbnRzIGFuZC9vciBrZXljb2RlcyB0aHJvd24gKHRoaXMgaXMgYSByZWFsIG1lc3MgOnwpLlxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IHRydWU7IC8vVE9ETyBSZW5hbWUgYHRoaXMuZm9ybWF0dGVkYCB0byBgdGhpcy5fZm9ybWF0RXhlY3V0ZWRgLCBzaW5jZSBpdCdzIHBvc3NpYmxlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbmVlZCB0byBmb3JtYXQgYW55dGhpbmcgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBrZXljb2RlIGlzIGRyb3BwZWQgZm9yIGluc3RhbmNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZm9ybSBjaGlsZCA8aW5wdXQ+IGVsZW1lbnQgdmFsdWVzIHRvIGEgc3RyaW5nLCBvciBhbiBBcnJheS5cbiAgICAgKiBUaGUgb3V0cHV0IGZvcm1hdCBpcyBkZWZpbmVkIHdpdGggdGhlIGBmb3JtYXRUeXBlYCBhcmd1bWVudC5cbiAgICAgKiBUaGlzIGlzIGxvb3NlbHkgYmFzZWQgdXBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDcwNTk5My8yODM0ODk4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGludG9BbkFycmF5IElmIGB0cnVlYCwgaW5zdGVhZCBvZiBnZW5lcmF0aW5nIGEgc3RyaW5nLCBpdCBnZW5lcmF0ZXMgYW4gQXJyYXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFR5cGUgSWYgYCd1bmZvcm1hdHRlZCdgLCB0aGVuIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50cyB2YWx1ZXMgYXJlIHVuZm9ybWF0dGVkLCBpZiBgJ2xvY2FsaXplZCdgLCB0aGVuIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50cyB2YWx1ZXMgYXJlIGxvY2FsaXplZCwgYW5kIGlmIGAnZm9ybWF0dGVkJ2AsIHRoZW4gdGhlIEF1dG9OdW1lcmljIGVsZW1lbnRzIHZhbHVlcyBhcmUga2VwdCBmb3JtYXR0ZWQuIEluIGVpdGhlciB3YXksIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSB2YWx1ZSBvZiBlYWNoIERPTSBlbGVtZW50LCBidXQgb25seSBhZmZlY3QgdGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhhdCBzZXJpYWxpemUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciBDYW4gZWl0aGVyIGJlIHRoZSAnKycgY2hhcmFjdGVyLCBvciB0aGUgJyUyMCcgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplKGZvcm0sIGludG9BbkFycmF5ID0gZmFsc2UsIGZvcm1hdFR5cGUgPSAndW5mb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycsIGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtID09PSAnb2JqZWN0JyAmJiBmb3JtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb3JtJykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZm9ybS5lbGVtZW50cykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICFlbGVtZW50LmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgIFsnZmlsZScsICdyZXNldCcsICdzdWJtaXQnLCAnYnV0dG9uJ10uaW5kZXhPZihlbGVtZW50LnR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudC5vcHRpb25zKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHVuZm9ybWF0L2Zvcm1hdC9sb2NhbGl6ZSB0aGUgc2VsZWN0aW9uIG9wdGlvbiAod2hpY2ggYmUgZGVmYXVsdCBzaG91bGQgYmUgcmVhZC1vbmx5KT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludG9BbkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgdmFsdWU6IG9wdGlvbi52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW50byBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQubmFtZSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbi52YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZihlbGVtZW50LnR5cGUpID09PSAtMSB8fCBlbGVtZW50LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFuYWdlZEJ5QXV0b051bWVyaWMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYW5PYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZm9ybWF0dGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuT2JqZWN0ID0gdGhpcy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChhbk9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlc3VsdCA9IHRoaXMudW5mb3JtYXQoZWxlbWVudCwgYW5PYmplY3QuZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG9jYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuT2JqZWN0ID0gdGhpcy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChhbk9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIEkgbmVlZCB0byBjbG9uZSB0aGUgc2V0dGluZyBvYmplY3QsIG90aGVyd2lzZSBJIHdvdWxkIG1vZGlmeSBpdCB3aGVuIGNoYW5naW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBvcHRpb24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChhbk9iamVjdC5nZXRTZXR0aW5ncygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChmb3JjZWRPdXRwdXRGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncy5vdXRwdXRGb3JtYXQgPSBmb3JjZWRPdXRwdXRGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZXN1bHQgPSB0aGlzLmxvY2FsaXplKGVsZW1lbnQsIGN1cnJlbnRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9ybWF0dGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHZhbHVlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1RoaXMgZXJyb3Igc2hvdWxkIG5ldmVyIGJlIGhpdC4gSWYgaXQgaGFzLCBzb21ldGhpbmcgcmVhbGx5IHdyb25nIGhhcHBlbmVkIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50b0FuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgdmFsdWU6IHZhbHVlUmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW50byBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2VuY29kZVVSSUNvbXBvbmVudChlbGVtZW50Lm5hbWUpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVJlc3VsdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaW5hbFJlc3VsdDtcblxuICAgICAgICBpZiAoaW50b0FuQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBhcyBhbiBBcnJheVxuICAgICAgICAgICAgLy8gTm90ZTogYHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlcmAgZG9lcyBub3QgYWZmZWN0IHRoZSBhcnJheSByZXN1bHQgc2luY2Ugd2UgZG8gbm90IGNoYW5nZSB0aGUgc3BhY2UgY2hhcmFjdGVyIGZvciB0aGlzIG9uZVxuICAgICAgICAgICAgZmluYWxSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXN1bHQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIGZpbmFsUmVzdWx0ID0gcmVzdWx0LmpvaW4oJyYnKTtcblxuICAgICAgICAgICAgaWYgKCcrJyA9PT0gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQgPSBmaW5hbFJlc3VsdC5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGZvcm0gdmFsdWVzIHRvIGEgc3RyaW5nLCBvdXRwdXR0aW5nIG51bWVyaWMgc3RyaW5ncyBmb3IgZWFjaCBBdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmcoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgZmFsc2UsICd1bmZvcm1hdHRlZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBmb3JtIHZhbHVlcyB0byBhIHN0cmluZywgb3V0cHV0dGluZyB0aGUgZm9ybWF0dGVkIHZhbHVlIGFzIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIF9zZXJpYWxpemVGb3JtYXR0ZWQoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgZmFsc2UsICdmb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZm9ybSB2YWx1ZXMgdG8gYSBzdHJpbmcsIG91dHB1dHRpbmcgbG9jYWxpemVkIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZUxvY2FsaXplZChmb3JtLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycsIGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShmb3JtLCBmYWxzZSwgJ2xvY2FsaXplZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciwgZm9yY2VkT3V0cHV0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBBcnJheSB3aXRoIHRoZSBmb3JtIHZhbHVlcywgb3V0cHV0dGluZyBudW1lcmljIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmdBcnJheShmb3JtLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShmb3JtLCB0cnVlLCAndW5mb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIEFycmF5IHdpdGggdGhlIGZvcm0gdmFsdWVzLCBvdXRwdXR0aW5nIHRoZSBmb3JtYXR0ZWQgdmFsdWUgYXMgc3RyaW5ncyBmb3IgZWFjaCBBdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplRm9ybWF0dGVkQXJyYXkoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgdHJ1ZSwgJ2Zvcm1hdHRlZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gQXJyYXkgd2l0aCB0aGUgZm9ybSB2YWx1ZXMsIG91dHB1dHRpbmcgbG9jYWxpemVkIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplTG9jYWxpemVkQXJyYXkoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnLCBmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgdHJ1ZSwgJ2xvY2FsaXplZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciwgZm9yY2VkT3V0cHV0Rm9ybWF0KTtcbiAgICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBtdWx0aXBsZSBET00gZWxlbWVudHMgaW4gb25lIGNhbGwgKGFuZCBwb3NzaWJseSBwYXNzIG11bHRpcGxlIHZhbHVlcyB0aGF0IHdpbGwgYmUgbWFwcGVkIHRvIGVhY2ggRE9NIGVsZW1lbnQpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fHsgcm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50IH18eyByb290RWxlbWVudDogSFRNTEVsZW1lbnQsIGV4Y2x1ZGU6IEFycmF5PEhUTUxJbnB1dEVsZW1lbnQ+fX0gYXJnMVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl8b2JqZWN0fG51bGx9IGluaXRpYWxWYWx1ZVxuICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5BdXRvTnVtZXJpYy5tdWx0aXBsZSA9IChhcmcxLCBpbml0aWFsVmFsdWUgPSBudWxsLCBvcHRpb25zID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgLy8gQW5hbHl6ZSB0aGUgYXJndW1lbnRzIGFuZCB0cmFuc2Zvcm0gdGhlbSB0byBtYWtlIHRoZW0gZXhwbG9pdGFibGVcbiAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3QoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBnYXZlIGFuIG9wdGlvbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgb3B0aW9ucyA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcoYXJnMSkpIHtcbiAgICAgICAgYXJnMSA9IFsuLi4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhcmcxKV07IC8vIENvbnZlcnQgYSBOb2RlTGlzdCB0byBhbiBBcnJheSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3Mjk3MjkyLzI4MzQ4OTgpXG4gICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc09iamVjdChhcmcxKSkge1xuICAgICAgICBpZiAoIWFyZzEuaGFzT3duUHJvcGVydHkoJ3Jvb3RFbGVtZW50JykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSAnbXVsdGlwbGUnIGZ1bmN0aW9uIGlzIGludmFsaWQgOyBubyAncm9vdEVsZW1lbnQnIGF0dHJpYnV0ZSBmb3VuZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBET00gZWxlbWVudCBsaXN0IGZyb20gdGhlIGdpdmVuIDxmb3JtPiBlbGVtZW50XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLiBhcmcxLnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyldO1xuICAgICAgICBpZiAoYXJnMS5oYXNPd25Qcm9wZXJ0eSgnZXhjbHVkZScpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMS5leGNsdWRlKSkge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSAnZXhjbHVkZScgYXJyYXkgcGFzc2VkIHRvIHRoZSAnbXVsdGlwbGUnIGZ1bmN0aW9uIGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIGV4Y2x1ZGVkIGVsZW1lbnRzXG4gICAgICAgICAgICBhcmcxID0gQXV0b051bWVyaWNIZWxwZXIuZmlsdGVyT3V0KGVsZW1lbnRzLCBhcmcxLmV4Y2x1ZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnMSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gcGFyYW1ldGVycyB0byB0aGUgJ211bHRpcGxlJyBmdW5jdGlvbiBhcmUgaW52YWxpZC5gKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgTm8gdmFsaWQgRE9NIGVsZW1lbnRzIHdlcmUgZ2l2ZW4gaGVuY2Ugbm8gQXV0b051bWVyaWMgb2JqZWN0IHdlcmUgaW5zdGFudGlhdGVkLmApO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICBjb25zdCBpc0luaXRpYWxWYWx1ZUFycmF5ID0gQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShpbml0aWFsVmFsdWUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbFZhbHVlTnVtYmVyID0gQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXIoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaW5pdGlhbFZhbHVlQXJyYXlTaXplO1xuICAgIGlmIChpc0luaXRpYWxWYWx1ZUFycmF5KSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZUFycmF5U2l6ZSA9IGluaXRpYWxWYWx1ZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFudGlhdGUgZWFjaCBBdXRvTnVtZXJpYyBvYmplY3RzXG4gICAgYXJnMS5mb3JFYWNoKChkb21FbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIHNldCB0aGUgc2FtZSB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50c1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIGluaXRpYWxWYWx1ZSwgb3B0aW9ucykpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSW5pdGlhbFZhbHVlQXJyYXkgJiYgaW5kZXggPD0gaW5pdGlhbFZhbHVlQXJyYXlTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgaW5pdGlhbFZhbHVlW2luZGV4XSwgb3B0aW9ucykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAqIC8vVE9ETyBNYWtlIHN1cmUgd2UgY2FsbCB0aGF0IGF0IGxlYXN0IG9uY2Ugd2hlbiBsb2FkaW5nIHRoZSBBdXRvTnVtZXJpYyBsaWJyYXJ5XG4gKi9cbihmdW5jdGlvbigpIHtcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG59XG5cbkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG53aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbn0pKCk7XG5cblxuLyoqXG4gKiAvL1hYWCBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBnZXQgZGlyZWN0IGFjY2VzcyB0byB0aGUgYEF1dG9OdW1lcmljYCBjb25zdHJ1Y3RvciB3aXRob3V0IGhhdmluZyB0byB1c2UgYG5ldyBBdXRvTnVtZXJpYy5kZWZhdWx0KClgIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzYzODkyNDQvMjgzNDg5OCkgOiB1c2luZyBgZXhwb3J0IHZhciBfX3VzZURlZmF1bHQgPSB0cnVlO2AgZG9lcyBub3Qgd29yayB0aG91Z2guXG4gKiAvL1hYWCBUaGUgd29ya2Fyb3VuZCAodXNpbmcgYG1vZHVsZS5leHBvcnRzID0gQXV0b051bWVyaWNgIGluc3RlYWQgb2YgYGV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9OdW1lcmljIHt9YCkgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy83MDYjaXNzdWVjb21tZW50LTE2NzkwODU3NlxuICogLy9YWFggQW5kIHRoZSBleHBsYW5hdGlvbiB3aHkgQmFiZWwgNiBjaGFuZ2VkIHRoZSB3YXkgQmFiZWwgNSB3b3JrZWQgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzUwNjE2OS8yODM0ODk4XG4gKiAvL1hYWCBJZGVhbGx5LCB3ZSBzaG91bGQgYmUgYWJsZSB0byBqdXN0IGRlY2xhcmUgYGV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9OdW1lcmljIHt9YCBpbiB0aGUgZnV0dXJlLCBhbmQgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgYG1vZHVsZS5leHBvcnRzID0gQXV0b051bWVyaWM7YCBsaW5lXG4gKlxuICogQHR5cGUge0F1dG9OdW1lcmljfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9OdW1lcmljO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enumerations for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Object that store the helper enumerations\n * @type {{ allowedTagList: [string], keyCode: {}, fromCharCodeKeyCode: [string], keyName: {} }}\n */\nvar AutoNumericEnum = {\n  /**\n   * List of allowed tag on which autoNumeric can be used.\n   */\n  allowedTagList: ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'input', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'],\n\n  /**\n   * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n   * cf. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n   *\n   * This deprecated information is used for obsolete browsers.\n   * @deprecated\n   */\n  keyCode: {\n    Backspace: 8,\n    Tab: 9,\n    // No 10, 11\n    // 12 === NumpadEqual on Windows\n    // 12 === NumLock on Mac\n    Enter: 13,\n    // 14 reserved, but not used\n    // 15 does not exists\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    Pause: 19,\n    CapsLock: 20,\n    // 21, 22, 23, 24, 25 : Asiatic key codes\n    // 26 does not exists\n    Esc: 27,\n    // 28, 29, 30, 31 : Convert, NonConvert, Accept and ModeChange keys\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    OSLeft: 91,\n    OSRight: 92,\n    ContextMenu: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224,\n    AltGraph: 225,\n    AndroidDefault: 229 },\n\n  /**\n   * This object is the reverse of `keyCode`, and is used to translate the key code to named keys when no valid characters can be obtained by `String.fromCharCode`.\n   * Note: this sparse array is initialized later in the source code.\n   */\n  fromCharCodeKeyCode: [],\n\n  /**\n   * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n   * Those names are listed here :\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n   */\n  keyName: {\n    // Special values\n    Unidentified: 'Unidentified',\n    AndroidDefault: 'AndroidDefault',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta',\n    OSLeft: 'OS',\n    OSRight: 'OS',\n    Command: 'OS',\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageUp: 'PageUp',\n    PageDown: 'PageDown',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    A: 'A',\n    B: 'B',\n    C: 'C',\n    D: 'D',\n    E: 'E',\n    F: 'F',\n    G: 'G',\n    H: 'H',\n    I: 'I',\n    J: 'J',\n    K: 'K',\n    L: 'L',\n    M: 'M',\n    N: 'N',\n    O: 'O',\n    P: 'P',\n    Q: 'Q',\n    R: 'R',\n    S: 'S',\n    T: 'T',\n    U: 'U',\n    V: 'V',\n    W: 'W',\n    X: 'X',\n    Y: 'Y',\n    Z: 'Z',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\",\n\n    // Numeric keypad keys\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    NumpadDot: '.',\n    NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n    NumpadMultiply: '*',\n    NumpadPlus: '+',\n    NumpadMinus: '-',\n    NumpadSlash: '/',\n    NumpadDotObsoleteBrowsers: 'Decimal',\n    NumpadMultiplyObsoleteBrowsers: 'Multiply',\n    NumpadPlusObsoleteBrowsers: 'Add',\n    NumpadMinusObsoleteBrowsers: 'Subtract',\n    NumpadSlashObsoleteBrowsers: 'Divide',\n\n    // Special arrays for quicker tests\n    _allFnKeys: ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'],\n    _someNonPrintableKeys: ['Tab', 'Enter', 'Shift', 'ShiftLeft', 'ShiftRight', 'Control', 'ControlLeft', 'ControlRight', 'Alt', 'AltLeft', 'AltRight', 'Pause', 'CapsLock', 'Escape'],\n    _directionKeys: ['PageUp', 'PageDown', 'End', 'Home', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp']\n  }\n};\n\n// Here we populate the sparse array that uses the `event.keyCode` as index, and returns the corresponding key name (à la event.key)\nAutoNumericEnum.fromCharCodeKeyCode[0] = 'LaunchCalculator';\nAutoNumericEnum.fromCharCodeKeyCode[8] = 'Backspace';\nAutoNumericEnum.fromCharCodeKeyCode[9] = 'Tab';\nAutoNumericEnum.fromCharCodeKeyCode[13] = 'Enter';\nAutoNumericEnum.fromCharCodeKeyCode[16] = 'Shift';\nAutoNumericEnum.fromCharCodeKeyCode[17] = 'Ctrl';\nAutoNumericEnum.fromCharCodeKeyCode[18] = 'Alt';\nAutoNumericEnum.fromCharCodeKeyCode[19] = 'Pause';\nAutoNumericEnum.fromCharCodeKeyCode[20] = 'CapsLock';\nAutoNumericEnum.fromCharCodeKeyCode[27] = 'Escape';\nAutoNumericEnum.fromCharCodeKeyCode[32] = ' ';\nAutoNumericEnum.fromCharCodeKeyCode[33] = 'PageUp';\nAutoNumericEnum.fromCharCodeKeyCode[34] = 'PageDown';\nAutoNumericEnum.fromCharCodeKeyCode[35] = 'End';\nAutoNumericEnum.fromCharCodeKeyCode[36] = 'Home';\nAutoNumericEnum.fromCharCodeKeyCode[37] = 'ArrowLeft';\nAutoNumericEnum.fromCharCodeKeyCode[38] = 'ArrowUp';\nAutoNumericEnum.fromCharCodeKeyCode[39] = 'ArrowRight';\nAutoNumericEnum.fromCharCodeKeyCode[40] = 'ArrowDown';\nAutoNumericEnum.fromCharCodeKeyCode[45] = 'Insert';\nAutoNumericEnum.fromCharCodeKeyCode[46] = 'Delete';\nAutoNumericEnum.fromCharCodeKeyCode[48] = '0';\nAutoNumericEnum.fromCharCodeKeyCode[49] = '1';\nAutoNumericEnum.fromCharCodeKeyCode[50] = '2';\nAutoNumericEnum.fromCharCodeKeyCode[51] = '3';\nAutoNumericEnum.fromCharCodeKeyCode[52] = '4';\nAutoNumericEnum.fromCharCodeKeyCode[53] = '5';\nAutoNumericEnum.fromCharCodeKeyCode[54] = '6';\nAutoNumericEnum.fromCharCodeKeyCode[55] = '7';\nAutoNumericEnum.fromCharCodeKeyCode[56] = '8';\nAutoNumericEnum.fromCharCodeKeyCode[57] = '9';\n// [65, 'a'],\n// [66, 'b'],\n// [67, 'c'],\n// [68, 'd'],\n// [69, 'e'],\n// [70, 'f'],\n// [71, 'g'],\n// [72, 'h'],\n// [73, 'i'],\n// [74, 'j'],\n// [75, 'k'],\n// [76, 'l'],\n// [77, 'm'],\n// [78, 'n'],\n// [79, 'o'],\n// [80, 'p'],\n// [81, 'q'],\n// [82, 'r'],\n// [83, 's'],\n// [84, 't'],\n// [85, 'u'],\n// [86, 'v'],\n// [87, 'w'],\n// [88, 'x'],\n// [89, 'y'],\n// [90, 'z'],\nAutoNumericEnum.fromCharCodeKeyCode[91] = 'OS'; // Note: Firefox and Chrome reports 'OS' instead of 'OSLeft'\nAutoNumericEnum.fromCharCodeKeyCode[92] = 'OSRight';\nAutoNumericEnum.fromCharCodeKeyCode[93] = 'ContextMenu';\nAutoNumericEnum.fromCharCodeKeyCode[96] = '0';\nAutoNumericEnum.fromCharCodeKeyCode[97] = '1';\nAutoNumericEnum.fromCharCodeKeyCode[98] = '2';\nAutoNumericEnum.fromCharCodeKeyCode[99] = '3';\nAutoNumericEnum.fromCharCodeKeyCode[100] = '4';\nAutoNumericEnum.fromCharCodeKeyCode[101] = '5';\nAutoNumericEnum.fromCharCodeKeyCode[102] = '6';\nAutoNumericEnum.fromCharCodeKeyCode[103] = '7';\nAutoNumericEnum.fromCharCodeKeyCode[104] = '8';\nAutoNumericEnum.fromCharCodeKeyCode[105] = '9';\nAutoNumericEnum.fromCharCodeKeyCode[106] = '*';\nAutoNumericEnum.fromCharCodeKeyCode[107] = '+';\nAutoNumericEnum.fromCharCodeKeyCode[109] = '-';\nAutoNumericEnum.fromCharCodeKeyCode[110] = '.';\nAutoNumericEnum.fromCharCodeKeyCode[111] = '/';\nAutoNumericEnum.fromCharCodeKeyCode[112] = 'F1';\nAutoNumericEnum.fromCharCodeKeyCode[113] = 'F2';\nAutoNumericEnum.fromCharCodeKeyCode[114] = 'F3';\nAutoNumericEnum.fromCharCodeKeyCode[115] = 'F4';\nAutoNumericEnum.fromCharCodeKeyCode[116] = 'F5';\nAutoNumericEnum.fromCharCodeKeyCode[117] = 'F6';\nAutoNumericEnum.fromCharCodeKeyCode[118] = 'F7';\nAutoNumericEnum.fromCharCodeKeyCode[119] = 'F8';\nAutoNumericEnum.fromCharCodeKeyCode[120] = 'F9';\nAutoNumericEnum.fromCharCodeKeyCode[121] = 'F10';\nAutoNumericEnum.fromCharCodeKeyCode[122] = 'F11';\nAutoNumericEnum.fromCharCodeKeyCode[123] = 'F12';\nAutoNumericEnum.fromCharCodeKeyCode[144] = 'NumLock';\nAutoNumericEnum.fromCharCodeKeyCode[145] = 'ScrollLock';\nAutoNumericEnum.fromCharCodeKeyCode[182] = 'MyComputer';\nAutoNumericEnum.fromCharCodeKeyCode[183] = 'MyCalculator';\nAutoNumericEnum.fromCharCodeKeyCode[186] = ';';\nAutoNumericEnum.fromCharCodeKeyCode[187] = '=';\nAutoNumericEnum.fromCharCodeKeyCode[188] = ',';\nAutoNumericEnum.fromCharCodeKeyCode[189] = '-';\nAutoNumericEnum.fromCharCodeKeyCode[190] = '.';\nAutoNumericEnum.fromCharCodeKeyCode[191] = '/';\nAutoNumericEnum.fromCharCodeKeyCode[192] = '`';\nAutoNumericEnum.fromCharCodeKeyCode[219] = '[';\nAutoNumericEnum.fromCharCodeKeyCode[220] = '\\\\';\nAutoNumericEnum.fromCharCodeKeyCode[221] = ']';\nAutoNumericEnum.fromCharCodeKeyCode[222] = \"'\";\nAutoNumericEnum.fromCharCodeKeyCode[224] = 'Meta';\nAutoNumericEnum.fromCharCodeKeyCode[225] = 'AltGraph';\n\nexports.default = AutoNumericEnum;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNFbnVtLmpzP2M1N2MiXSwibmFtZXMiOlsiQXV0b051bWVyaWNFbnVtIiwiYWxsb3dlZFRhZ0xpc3QiLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZSIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIk9TTGVmdCIsIk9TUmlnaHQiLCJDb250ZXh0TWVudSIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJBbHRHcmFwaCIsIkFuZHJvaWREZWZhdWx0IiwiZnJvbUNoYXJDb2RlS2V5Q29kZSIsImtleU5hbWUiLCJVbmlkZW50aWZpZWQiLCJBbHRHciIsIkZuIiwiRm5Mb2NrIiwiSHlwZXIiLCJNZXRhIiwiU3VwZXIiLCJTeW1ib2wiLCJTeW1ib2xMb2NrIiwiQ2xlYXIiLCJDb3B5IiwiQ3JTZWwiLCJDdXQiLCJFcmFzZUVvZiIsIkV4U2VsIiwiUGFzdGUiLCJSZWRvIiwiVW5kbyIsIkFjY2VwdCIsIkFnYWluIiwiQXR0biIsIkNhbmNlbCIsIkV4ZWN1dGUiLCJGaW5kIiwiRmluaXNoIiwiSGVscCIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsIk1pbnVzIiwiUGx1cyIsIk51bXBhZERvdCIsIk51bXBhZERvdEFsdCIsIk51bXBhZE11bHRpcGx5IiwiTnVtcGFkUGx1cyIsIk51bXBhZE1pbnVzIiwiTnVtcGFkU2xhc2giLCJOdW1wYWREb3RPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTXVsdGlwbHlPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkUGx1c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRNaW51c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRTbGFzaE9ic29sZXRlQnJvd3NlcnMiLCJfYWxsRm5LZXlzIiwiX3NvbWVOb25QcmludGFibGVLZXlzIiwiX2RpcmVjdGlvbktleXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7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QUFDQTNHLGdCQUFnQjJHLG1CQUFoQixDQUFvQyxHQUFwQyxJQUEyQyxHQUEzQztBQUNBM0csZ0JBQWdCMkcsbUJBQWhCLENBQW9DLEdBQXBDLElBQTJDLEdBQTNDO0FBQ0EzRyxnQkFBZ0IyRyxtQkFBaEIsQ0FBb0MsR0FBcEMsSUFBMkMsR0FBM0M7QUFDQTNHLGdCQUFnQjJHLG1CQUFoQixDQUFvQyxHQUFwQyxJQUEyQyxHQUEzQztBQUNBM0csZ0JBQWdCMkcsbUJBQWhCLENBQW9DLEdBQXBDLElBQTJDLEdBQTNDO0FBQ0EzRyxnQkFBZ0IyRyxtQkFBaEIsQ0FBb0MsR0FBcEMsSUFBMkMsR0FBM0M7QUFDQTNHLGdCQUFnQjJHLG1CQUFoQixDQUFvQyxHQUFwQyxJQUEyQyxHQUEzQztBQUNBM0csZ0JBQWdCMkcsbUJBQWhCLENBQW9DLEdBQXBDLElBQTJDLElBQTNDO0FBQ0EzRyxnQkFBZ0IyRyxtQkFBaEIsQ0FBb0MsR0FBcEMsSUFBMkMsR0FBM0M7QUFDQTNHLGdCQUFnQjJHLG1CQUFoQixDQUFvQyxHQUFwQyxJQUEyQyxHQUEzQztBQUNBM0csZ0JBQWdCMkcsbUJBQWhCLENBQW9DLEdBQXBDLElBQTJDLE1BQTNDO0FBQ0EzRyxnQkFBZ0IyRyxtQkFBaEIsQ0FBb0MsR0FBcEMsSUFBMkMsVUFBM0M7O2tCQUVlM0csZSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbnVtZXJhdGlvbnMgZm9yIGF1dG9OdW1lcmljLmpzXG4gKiBAYXV0aG9yIEFsZXhhbmRyZSBCb25uZWF1IDxhbGV4YW5kcmUuYm9ubmVhdUBsaW51eGZyLmV1PlxuICogQGNvcHlyaWdodCDCqSAyMDE2IEFsZXhhbmRyZSBCb25uZWF1XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIE9iamVjdCB0aGF0IHN0b3JlIHRoZSBoZWxwZXIgZW51bWVyYXRpb25zXG4gKiBAdHlwZSB7eyBhbGxvd2VkVGFnTGlzdDogW3N0cmluZ10sIGtleUNvZGU6IHt9LCBmcm9tQ2hhckNvZGVLZXlDb2RlOiBbc3RyaW5nXSwga2V5TmFtZToge30gfX1cbiAqL1xuY29uc3QgQXV0b051bWVyaWNFbnVtID0ge1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsb3dlZCB0YWcgb24gd2hpY2ggYXV0b051bWVyaWMgY2FuIGJlIHVzZWQuXG4gICAgICovXG4gICAgYWxsb3dlZFRhZ0xpc3Q6IFtcbiAgICAgICAgJ2InLFxuICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICdjaXRlJyxcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICAnY29uc3QnLFxuICAgICAgICAnZGQnLFxuICAgICAgICAnZGVsJyxcbiAgICAgICAgJ2RpdicsXG4gICAgICAgICdkZm4nLFxuICAgICAgICAnZHQnLFxuICAgICAgICAnZW0nLFxuICAgICAgICAnaDEnLFxuICAgICAgICAnaDInLFxuICAgICAgICAnaDMnLFxuICAgICAgICAnaDQnLFxuICAgICAgICAnaDUnLFxuICAgICAgICAnaDYnLFxuICAgICAgICAnaW5wdXQnLFxuICAgICAgICAnaW5zJyxcbiAgICAgICAgJ2tkYicsXG4gICAgICAgICdsYWJlbCcsXG4gICAgICAgICdsaScsXG4gICAgICAgICdvcHRpb24nLFxuICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgJ3AnLFxuICAgICAgICAncScsXG4gICAgICAgICdzJyxcbiAgICAgICAgJ3NhbXBsZScsXG4gICAgICAgICdzcGFuJyxcbiAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICd0ZCcsXG4gICAgICAgICd0aCcsXG4gICAgICAgICd1JyxcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXG4gICAgICogY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleUNvZGVcbiAgICAgKlxuICAgICAqIFRoaXMgZGVwcmVjYXRlZCBpbmZvcm1hdGlvbiBpcyB1c2VkIGZvciBvYnNvbGV0ZSBicm93c2Vycy5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGtleUNvZGU6IHtcbiAgICAgICAgQmFja3NwYWNlOiAgICAgIDgsXG4gICAgICAgIFRhYjogICAgICAgICAgICA5LFxuICAgICAgICAvLyBObyAxMCwgMTFcbiAgICAgICAgLy8gMTIgPT09IE51bXBhZEVxdWFsIG9uIFdpbmRvd3NcbiAgICAgICAgLy8gMTIgPT09IE51bUxvY2sgb24gTWFjXG4gICAgICAgIEVudGVyOiAgICAgICAgICAxMyxcbiAgICAgICAgLy8gMTQgcmVzZXJ2ZWQsIGJ1dCBub3QgdXNlZFxuICAgICAgICAvLyAxNSBkb2VzIG5vdCBleGlzdHNcbiAgICAgICAgU2hpZnQ6ICAgICAgICAgIDE2LFxuICAgICAgICBDdHJsOiAgICAgICAgICAgMTcsXG4gICAgICAgIEFsdDogICAgICAgICAgICAxOCxcbiAgICAgICAgUGF1c2U6ICAgICAgICAgIDE5LFxuICAgICAgICBDYXBzTG9jazogICAgICAgMjAsXG4gICAgICAgIC8vIDIxLCAyMiwgMjMsIDI0LCAyNSA6IEFzaWF0aWMga2V5IGNvZGVzXG4gICAgICAgIC8vIDI2IGRvZXMgbm90IGV4aXN0c1xuICAgICAgICBFc2M6ICAgICAgICAgICAgMjcsXG4gICAgICAgIC8vIDI4LCAyOSwgMzAsIDMxIDogQ29udmVydCwgTm9uQ29udmVydCwgQWNjZXB0IGFuZCBNb2RlQ2hhbmdlIGtleXNcbiAgICAgICAgU3BhY2U6ICAgICAgICAgIDMyLFxuICAgICAgICBQYWdlVXA6ICAgICAgICAgMzMsXG4gICAgICAgIFBhZ2VEb3duOiAgICAgICAzNCxcbiAgICAgICAgRW5kOiAgICAgICAgICAgIDM1LFxuICAgICAgICBIb21lOiAgICAgICAgICAgMzYsXG4gICAgICAgIExlZnRBcnJvdzogICAgICAzNyxcbiAgICAgICAgVXBBcnJvdzogICAgICAgIDM4LFxuICAgICAgICBSaWdodEFycm93OiAgICAgMzksXG4gICAgICAgIERvd25BcnJvdzogICAgICA0MCxcbiAgICAgICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxuICAgICAgICBEZWxldGU6ICAgICAgICAgNDYsXG4gICAgICAgIG51bTA6ICAgICAgICAgICA0OCxcbiAgICAgICAgbnVtMTogICAgICAgICAgIDQ5LFxuICAgICAgICBudW0yOiAgICAgICAgICAgNTAsXG4gICAgICAgIG51bTM6ICAgICAgICAgICA1MSxcbiAgICAgICAgbnVtNDogICAgICAgICAgIDUyLFxuICAgICAgICBudW01OiAgICAgICAgICAgNTMsXG4gICAgICAgIG51bTY6ICAgICAgICAgICA1NCxcbiAgICAgICAgbnVtNzogICAgICAgICAgIDU1LFxuICAgICAgICBudW04OiAgICAgICAgICAgNTYsXG4gICAgICAgIG51bTk6ICAgICAgICAgICA1NyxcbiAgICAgICAgYTogICAgICAgICAgICAgIDY1LFxuICAgICAgICBiOiAgICAgICAgICAgICAgNjYsXG4gICAgICAgIGM6ICAgICAgICAgICAgICA2NyxcbiAgICAgICAgZDogICAgICAgICAgICAgIDY4LFxuICAgICAgICBlOiAgICAgICAgICAgICAgNjksXG4gICAgICAgIGY6ICAgICAgICAgICAgICA3MCxcbiAgICAgICAgZzogICAgICAgICAgICAgIDcxLFxuICAgICAgICBoOiAgICAgICAgICAgICAgNzIsXG4gICAgICAgIGk6ICAgICAgICAgICAgICA3MyxcbiAgICAgICAgajogICAgICAgICAgICAgIDc0LFxuICAgICAgICBrOiAgICAgICAgICAgICAgNzUsXG4gICAgICAgIGw6ICAgICAgICAgICAgICA3NixcbiAgICAgICAgbTogICAgICAgICAgICAgIDc3LFxuICAgICAgICBuOiAgICAgICAgICAgICAgNzgsXG4gICAgICAgIG86ICAgICAgICAgICAgICA3OSxcbiAgICAgICAgcDogICAgICAgICAgICAgIDgwLFxuICAgICAgICBxOiAgICAgICAgICAgICAgODEsXG4gICAgICAgIHI6ICAgICAgICAgICAgICA4MixcbiAgICAgICAgczogICAgICAgICAgICAgIDgzLFxuICAgICAgICB0OiAgICAgICAgICAgICAgODQsXG4gICAgICAgIHU6ICAgICAgICAgICAgICA4NSxcbiAgICAgICAgdjogICAgICAgICAgICAgIDg2LFxuICAgICAgICB3OiAgICAgICAgICAgICAgODcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICA4OCxcbiAgICAgICAgeTogICAgICAgICAgICAgIDg5LFxuICAgICAgICB6OiAgICAgICAgICAgICAgOTAsXG4gICAgICAgIE9TTGVmdDogICAgICAgICA5MSxcbiAgICAgICAgT1NSaWdodDogICAgICAgIDkyLFxuICAgICAgICBDb250ZXh0TWVudTogICAgOTMsXG4gICAgICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICAgICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgICAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICAgICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICAgICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICAgICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICAgICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICAgICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICAgICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICAgICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICAgICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICAgICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICAgICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICAgICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICAgICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICAgICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICAgICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICAgICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICAgICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICAgICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICAgICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICAgICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICAgICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICAgICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICAgICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICAgICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICAgICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICAgICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICAgICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICAgICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICAgICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICAgICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICAgICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICAgICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICAgICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICAgICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICAgICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICAgICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICAgICAgQ29tbWFuZDogICAgICAgIDIyNCxcbiAgICAgICAgQWx0R3JhcGg6ICAgICAgIDIyNSxcbiAgICAgICAgQW5kcm9pZERlZmF1bHQ6IDIyOSwgLy8gQW5kcm9pZCBDaHJvbWUgcmV0dXJucyB0aGUgc2FtZSBrZXljb2RlIG51bWJlciAyMjkgZm9yIGFsbCBrZXlzIHByZXNzZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaXMgdGhlIHJldmVyc2Ugb2YgYGtleUNvZGVgLCBhbmQgaXMgdXNlZCB0byB0cmFuc2xhdGUgdGhlIGtleSBjb2RlIHRvIG5hbWVkIGtleXMgd2hlbiBubyB2YWxpZCBjaGFyYWN0ZXJzIGNhbiBiZSBvYnRhaW5lZCBieSBgU3RyaW5nLmZyb21DaGFyQ29kZWAuXG4gICAgICogTm90ZTogdGhpcyBzcGFyc2UgYXJyYXkgaXMgaW5pdGlhbGl6ZWQgbGF0ZXIgaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZyb21DaGFyQ29kZUtleUNvZGU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5IG5hbWUgKGFzIHNldCBpbiBLZXlib2FyZEV2ZW50LmtleSkuXG4gICAgICogVGhvc2UgbmFtZXMgYXJlIGxpc3RlZCBoZXJlIDpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xuICAgICAqL1xuICAgIGtleU5hbWU6IHtcbiAgICAgICAgLy8gU3BlY2lhbCB2YWx1ZXNcbiAgICAgICAgVW5pZGVudGlmaWVkOiAgICdVbmlkZW50aWZpZWQnLFxuICAgICAgICBBbmRyb2lkRGVmYXVsdDogJ0FuZHJvaWREZWZhdWx0JyxcblxuICAgICAgICAvLyBNb2RpZmllciBrZXlzXG4gICAgICAgIEFsdDogICAgICAgICAgICAnQWx0JyxcbiAgICAgICAgQWx0R3I6ICAgICAgICAgICdBbHRHcmFwaCcsXG4gICAgICAgIENhcHNMb2NrOiAgICAgICAnQ2Fwc0xvY2snLCAvLyBVbmRlciBDaHJvbWUsIGUua2V5IGlzIGVtcHR5IGZvciBDYXBzTG9ja1xuICAgICAgICBDdHJsOiAgICAgICAgICAgJ0NvbnRyb2wnLFxuICAgICAgICBGbjogICAgICAgICAgICAgJ0ZuJyxcbiAgICAgICAgRm5Mb2NrOiAgICAgICAgICdGbkxvY2snLFxuICAgICAgICBIeXBlcjogICAgICAgICAgJ0h5cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XG4gICAgICAgIE1ldGE6ICAgICAgICAgICAnTWV0YScsXG4gICAgICAgIE9TTGVmdDogICAgICAgICAnT1MnLFxuICAgICAgICBPU1JpZ2h0OiAgICAgICAgJ09TJyxcbiAgICAgICAgQ29tbWFuZDogICAgICAgICdPUycsXG4gICAgICAgIE51bUxvY2s6ICAgICAgICAnTnVtTG9jaycsXG4gICAgICAgIFNjcm9sbExvY2s6ICAgICAnU2Nyb2xsTG9jaycsXG4gICAgICAgIFNoaWZ0OiAgICAgICAgICAnU2hpZnQnLFxuICAgICAgICBTdXBlcjogICAgICAgICAgJ1N1cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XG4gICAgICAgIFN5bWJvbDogICAgICAgICAnU3ltYm9sJyxcbiAgICAgICAgU3ltYm9sTG9jazogICAgICdTeW1ib2xMb2NrJyxcblxuICAgICAgICAvLyBXaGl0ZXNwYWNlIGtleXNcbiAgICAgICAgRW50ZXI6ICAgICAgICAgICdFbnRlcicsXG4gICAgICAgIFRhYjogICAgICAgICAgICAnVGFiJyxcbiAgICAgICAgU3BhY2U6ICAgICAgICAgICcgJywgLy8gJ1NwYWNlYmFyJyBmb3IgRmlyZWZveCA8MzcsIGFuZCBJRTlcblxuICAgICAgICAvLyBOYXZpZ2F0aW9uIGtleXNcbiAgICAgICAgTGVmdEFycm93OiAgICAgICdBcnJvd0xlZnQnLCAvLyAnTGVmdCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgICAgICBVcEFycm93OiAgICAgICAgJ0Fycm93VXAnLCAvLyAnVXAnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgUmlnaHRBcnJvdzogICAgICdBcnJvd1JpZ2h0JywgLy8gJ1JpZ2h0JyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgIERvd25BcnJvdzogICAgICAnQXJyb3dEb3duJywgLy8gJ0Rvd24nIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgRW5kOiAgICAgICAgICAgICdFbmQnLFxuICAgICAgICBIb21lOiAgICAgICAgICAgJ0hvbWUnLFxuICAgICAgICBQYWdlVXA6ICAgICAgICAgJ1BhZ2VVcCcsXG4gICAgICAgIFBhZ2VEb3duOiAgICAgICAnUGFnZURvd24nLFxuXG4gICAgICAgIC8vIEVkaXRpbmcga2V5c1xuICAgICAgICBCYWNrc3BhY2U6ICAgICAgJ0JhY2tzcGFjZScsXG4gICAgICAgIENsZWFyOiAgICAgICAgICAnQ2xlYXInLFxuICAgICAgICBDb3B5OiAgICAgICAgICAgJ0NvcHknLFxuICAgICAgICBDclNlbDogICAgICAgICAgJ0NyU2VsJywgLy8gJ0Nyc2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgIEN1dDogICAgICAgICAgICAnQ3V0JyxcbiAgICAgICAgRGVsZXRlOiAgICAgICAgICdEZWxldGUnLCAvLyAnRGVsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgIEVyYXNlRW9mOiAgICAgICAnRXJhc2VFb2YnLFxuICAgICAgICBFeFNlbDogICAgICAgICAgJ0V4U2VsJywgLy8gJ0V4c2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgIEluc2VydDogICAgICAgICAnSW5zZXJ0JyxcbiAgICAgICAgUGFzdGU6ICAgICAgICAgICdQYXN0ZScsXG4gICAgICAgIFJlZG86ICAgICAgICAgICAnUmVkbycsXG4gICAgICAgIFVuZG86ICAgICAgICAgICAnVW5kbycsXG5cbiAgICAgICAgLy8gVUkga2V5c1xuICAgICAgICBBY2NlcHQ6ICAgICAgICAgJ0FjY2VwdCcsXG4gICAgICAgIEFnYWluOiAgICAgICAgICAnQWdhaW4nLFxuICAgICAgICBBdHRuOiAgICAgICAgICAgJ0F0dG4nLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCwgQ2hyb21lLCBhbmQgSUU5ICgnS2FuYU1vZGUnIHdoZW4gdXNpbmcgdGhlIEphcGFuZXNlIGtleWJvYXJkIGxheW91dClcbiAgICAgICAgQ2FuY2VsOiAgICAgICAgICdDYW5jZWwnLFxuICAgICAgICBDb250ZXh0TWVudTogICAgJ0NvbnRleHRNZW51JywgLy8gJ0FwcHMnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgRXNjOiAgICAgICAgICAgICdFc2NhcGUnLCAvLyAnRXNjJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgIEV4ZWN1dGU6ICAgICAgICAnRXhlY3V0ZScsXG4gICAgICAgIEZpbmQ6ICAgICAgICAgICAnRmluZCcsXG4gICAgICAgIEZpbmlzaDogICAgICAgICAnRmluaXNoJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thdGFrYW5hJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXG4gICAgICAgIEhlbHA6ICAgICAgICAgICAnSGVscCcsXG4gICAgICAgIFBhdXNlOiAgICAgICAgICAnUGF1c2UnLFxuICAgICAgICBQbGF5OiAgICAgICAgICAgJ1BsYXknLFxuICAgICAgICBQcm9wczogICAgICAgICAgJ1Byb3BzJyxcbiAgICAgICAgU2VsZWN0OiAgICAgICAgICdTZWxlY3QnLFxuICAgICAgICBab29tSW46ICAgICAgICAgJ1pvb21JbicsXG4gICAgICAgIFpvb21PdXQ6ICAgICAgICAnWm9vbU91dCcsXG5cbiAgICAgICAgLy8gRGV2aWNlIGtleXNcbiAgICAgICAgQnJpZ2h0bmVzc0Rvd246ICdCcmlnaHRuZXNzRG93bicsXG4gICAgICAgIEJyaWdodG5lc3NVcDogICAnQnJpZ2h0bmVzc1VwJyxcbiAgICAgICAgRWplY3Q6ICAgICAgICAgICdFamVjdCcsXG4gICAgICAgIExvZ09mZjogICAgICAgICAnTG9nT2ZmJyxcbiAgICAgICAgUG93ZXI6ICAgICAgICAgICdQb3dlcicsXG4gICAgICAgIFBvd2VyT2ZmOiAgICAgICAnUG93ZXJPZmYnLFxuICAgICAgICBQcmludFNjcmVlbjogICAgJ1ByaW50U2NyZWVuJyxcbiAgICAgICAgSGliZXJuYXRlOiAgICAgICdIaWJlcm5hdGUnLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCA8PTM3XG4gICAgICAgIFN0YW5kYnk6ICAgICAgICAnU3RhbmRieScsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgV2FrZVVwOiAgICAgICAgICdXYWtlVXAnLFxuXG4gICAgICAgIC8vIElNRSBhbmQgY29tcG9zaXRpb24ga2V5c1xuICAgICAgICBDb21wb3NlOiAgICAgICAgJ0NvbXBvc2UnLFxuICAgICAgICBEZWFkOiAgICAgICAgICAgJ0RlYWQnLFxuXG4gICAgICAgIC8vIEZ1bmN0aW9uIGtleXNcbiAgICAgICAgRjE6ICAgICAgICAgICAgICdGMScsXG4gICAgICAgIEYyOiAgICAgICAgICAgICAnRjInLFxuICAgICAgICBGMzogICAgICAgICAgICAgJ0YzJyxcbiAgICAgICAgRjQ6ICAgICAgICAgICAgICdGNCcsXG4gICAgICAgIEY1OiAgICAgICAgICAgICAnRjUnLFxuICAgICAgICBGNjogICAgICAgICAgICAgJ0Y2JyxcbiAgICAgICAgRjc6ICAgICAgICAgICAgICdGNycsXG4gICAgICAgIEY4OiAgICAgICAgICAgICAnRjgnLFxuICAgICAgICBGOTogICAgICAgICAgICAgJ0Y5JyxcbiAgICAgICAgRjEwOiAgICAgICAgICAgICdGMTAnLFxuICAgICAgICBGMTE6ICAgICAgICAgICAgJ0YxMScsXG4gICAgICAgIEYxMjogICAgICAgICAgICAnRjEyJyxcblxuICAgICAgICAvLyBEb2N1bWVudCBrZXlzXG4gICAgICAgIFByaW50OiAgICAgICAgICAnUHJpbnQnLFxuXG4gICAgICAgIC8vICdOb3JtYWwnIGtleXNcbiAgICAgICAgbnVtMDogICAgICAgICAgICcwJyxcbiAgICAgICAgbnVtMTogICAgICAgICAgICcxJyxcbiAgICAgICAgbnVtMjogICAgICAgICAgICcyJyxcbiAgICAgICAgbnVtMzogICAgICAgICAgICczJyxcbiAgICAgICAgbnVtNDogICAgICAgICAgICc0JyxcbiAgICAgICAgbnVtNTogICAgICAgICAgICc1JyxcbiAgICAgICAgbnVtNjogICAgICAgICAgICc2JyxcbiAgICAgICAgbnVtNzogICAgICAgICAgICc3JyxcbiAgICAgICAgbnVtODogICAgICAgICAgICc4JyxcbiAgICAgICAgbnVtOTogICAgICAgICAgICc5JyxcbiAgICAgICAgYTogICAgICAgICAgICAgICdhJyxcbiAgICAgICAgYjogICAgICAgICAgICAgICdiJyxcbiAgICAgICAgYzogICAgICAgICAgICAgICdjJyxcbiAgICAgICAgZDogICAgICAgICAgICAgICdkJyxcbiAgICAgICAgZTogICAgICAgICAgICAgICdlJyxcbiAgICAgICAgZjogICAgICAgICAgICAgICdmJyxcbiAgICAgICAgZzogICAgICAgICAgICAgICdnJyxcbiAgICAgICAgaDogICAgICAgICAgICAgICdoJyxcbiAgICAgICAgaTogICAgICAgICAgICAgICdpJyxcbiAgICAgICAgajogICAgICAgICAgICAgICdqJyxcbiAgICAgICAgazogICAgICAgICAgICAgICdrJyxcbiAgICAgICAgbDogICAgICAgICAgICAgICdsJyxcbiAgICAgICAgbTogICAgICAgICAgICAgICdtJyxcbiAgICAgICAgbjogICAgICAgICAgICAgICduJyxcbiAgICAgICAgbzogICAgICAgICAgICAgICdvJyxcbiAgICAgICAgcDogICAgICAgICAgICAgICdwJyxcbiAgICAgICAgcTogICAgICAgICAgICAgICdxJyxcbiAgICAgICAgcjogICAgICAgICAgICAgICdyJyxcbiAgICAgICAgczogICAgICAgICAgICAgICdzJyxcbiAgICAgICAgdDogICAgICAgICAgICAgICd0JyxcbiAgICAgICAgdTogICAgICAgICAgICAgICd1JyxcbiAgICAgICAgdjogICAgICAgICAgICAgICd2JyxcbiAgICAgICAgdzogICAgICAgICAgICAgICd3JyxcbiAgICAgICAgeDogICAgICAgICAgICAgICd4JyxcbiAgICAgICAgeTogICAgICAgICAgICAgICd5JyxcbiAgICAgICAgejogICAgICAgICAgICAgICd6JyxcbiAgICAgICAgQTogICAgICAgICAgICAgICdBJyxcbiAgICAgICAgQjogICAgICAgICAgICAgICdCJyxcbiAgICAgICAgQzogICAgICAgICAgICAgICdDJyxcbiAgICAgICAgRDogICAgICAgICAgICAgICdEJyxcbiAgICAgICAgRTogICAgICAgICAgICAgICdFJyxcbiAgICAgICAgRjogICAgICAgICAgICAgICdGJyxcbiAgICAgICAgRzogICAgICAgICAgICAgICdHJyxcbiAgICAgICAgSDogICAgICAgICAgICAgICdIJyxcbiAgICAgICAgSTogICAgICAgICAgICAgICdJJyxcbiAgICAgICAgSjogICAgICAgICAgICAgICdKJyxcbiAgICAgICAgSzogICAgICAgICAgICAgICdLJyxcbiAgICAgICAgTDogICAgICAgICAgICAgICdMJyxcbiAgICAgICAgTTogICAgICAgICAgICAgICdNJyxcbiAgICAgICAgTjogICAgICAgICAgICAgICdOJyxcbiAgICAgICAgTzogICAgICAgICAgICAgICdPJyxcbiAgICAgICAgUDogICAgICAgICAgICAgICdQJyxcbiAgICAgICAgUTogICAgICAgICAgICAgICdRJyxcbiAgICAgICAgUjogICAgICAgICAgICAgICdSJyxcbiAgICAgICAgUzogICAgICAgICAgICAgICdTJyxcbiAgICAgICAgVDogICAgICAgICAgICAgICdUJyxcbiAgICAgICAgVTogICAgICAgICAgICAgICdVJyxcbiAgICAgICAgVjogICAgICAgICAgICAgICdWJyxcbiAgICAgICAgVzogICAgICAgICAgICAgICdXJyxcbiAgICAgICAgWDogICAgICAgICAgICAgICdYJyxcbiAgICAgICAgWTogICAgICAgICAgICAgICdZJyxcbiAgICAgICAgWjogICAgICAgICAgICAgICdaJyxcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgICc7JyxcbiAgICAgICAgRXF1YWw6ICAgICAgICAgICc9JyxcbiAgICAgICAgQ29tbWE6ICAgICAgICAgICcsJyxcbiAgICAgICAgSHlwaGVuOiAgICAgICAgICctJyxcbiAgICAgICAgTWludXM6ICAgICAgICAgICctJyxcbiAgICAgICAgUGx1czogICAgICAgICAgICcrJyxcbiAgICAgICAgRG90OiAgICAgICAgICAgICcuJyxcbiAgICAgICAgU2xhc2g6ICAgICAgICAgICcvJyxcbiAgICAgICAgQmFja3F1b3RlOiAgICAgICdgJyxcbiAgICAgICAgTGVmdEJyYWNrZXQ6ICAgICdbJyxcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgICddJyxcbiAgICAgICAgQmFja3NsYXNoOiAgICAgICdcXFxcJyxcbiAgICAgICAgUXVvdGU6ICAgICAgICAgIFwiJ1wiLFxuXG4gICAgICAgIC8vIE51bWVyaWMga2V5cGFkIGtleXNcbiAgICAgICAgbnVtcGFkMDogICAgICAgICcwJyxcbiAgICAgICAgbnVtcGFkMTogICAgICAgICcxJyxcbiAgICAgICAgbnVtcGFkMjogICAgICAgICcyJyxcbiAgICAgICAgbnVtcGFkMzogICAgICAgICczJyxcbiAgICAgICAgbnVtcGFkNDogICAgICAgICc0JyxcbiAgICAgICAgbnVtcGFkNTogICAgICAgICc1JyxcbiAgICAgICAgbnVtcGFkNjogICAgICAgICc2JyxcbiAgICAgICAgbnVtcGFkNzogICAgICAgICc3JyxcbiAgICAgICAgbnVtcGFkODogICAgICAgICc4JyxcbiAgICAgICAgbnVtcGFkOTogICAgICAgICc5JyxcbiAgICAgICAgTnVtcGFkRG90OiAgICAgICcuJyxcbiAgICAgICAgTnVtcGFkRG90QWx0OiAgICcsJywgLy8gTW9kZXJuIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgYWRhcHQgdGhlIGNoYXJhY3RlciBzZW50IGJ5IHRoaXMga2V5IHRvIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgICAgICBOdW1wYWRNdWx0aXBseTogJyonLFxuICAgICAgICBOdW1wYWRQbHVzOiAgICAgJysnLFxuICAgICAgICBOdW1wYWRNaW51czogICAgJy0nLFxuICAgICAgICBOdW1wYWRTbGFzaDogICAgJy8nLFxuICAgICAgICBOdW1wYWREb3RPYnNvbGV0ZUJyb3dzZXJzOiAgICAgICdEZWNpbWFsJyxcbiAgICAgICAgTnVtcGFkTXVsdGlwbHlPYnNvbGV0ZUJyb3dzZXJzOiAnTXVsdGlwbHknLFxuICAgICAgICBOdW1wYWRQbHVzT2Jzb2xldGVCcm93c2VyczogICAgICdBZGQnLFxuICAgICAgICBOdW1wYWRNaW51c09ic29sZXRlQnJvd3NlcnM6ICAgICdTdWJ0cmFjdCcsXG4gICAgICAgIE51bXBhZFNsYXNoT2Jzb2xldGVCcm93c2VyczogICAgJ0RpdmlkZScsXG5cbiAgICAgICAgLy8gU3BlY2lhbCBhcnJheXMgZm9yIHF1aWNrZXIgdGVzdHNcbiAgICAgICAgX2FsbEZuS2V5czogICAgIFsnRjEnLCAnRjInLCAnRjMnLCAnRjQnLCAnRjUnLCAnRjYnLCAnRjcnLCAnRjgnLCAnRjknLCAnRjEwJywgJ0YxMScsICdGMTInXSxcbiAgICAgICAgX3NvbWVOb25QcmludGFibGVLZXlzOiBbJ1RhYicsICdFbnRlcicsICdTaGlmdCcsICdTaGlmdExlZnQnLCAnU2hpZnRSaWdodCcsICdDb250cm9sJywgJ0NvbnRyb2xMZWZ0JywgJ0NvbnRyb2xSaWdodCcsICdBbHQnLCAnQWx0TGVmdCcsICdBbHRSaWdodCcsICdQYXVzZScsICdDYXBzTG9jaycsICdFc2NhcGUnXSxcbiAgICAgICAgX2RpcmVjdGlvbktleXM6IFsnUGFnZVVwJywgJ1BhZ2VEb3duJywgJ0VuZCcsICdIb21lJywgJ0Fycm93RG93bicsICdBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCcsICdBcnJvd1VwJ10sXG4gICAgfSxcbn07XG5cbi8vIEhlcmUgd2UgcG9wdWxhdGUgdGhlIHNwYXJzZSBhcnJheSB0aGF0IHVzZXMgdGhlIGBldmVudC5rZXlDb2RlYCBhcyBpbmRleCwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcga2V5IG5hbWUgKMOgIGxhIGV2ZW50LmtleSlcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzBdID0gJ0xhdW5jaENhbGN1bGF0b3InO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbOF0gPSAnQmFja3NwYWNlJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzldID0gJ1RhYic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxM10gPSAnRW50ZXInO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTZdID0gJ1NoaWZ0JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzE3XSA9ICdDdHJsJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzE4XSA9ICdBbHQnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTldID0gJ1BhdXNlJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzIwXSA9ICdDYXBzTG9jayc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsyN10gPSAnRXNjYXBlJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzMyXSA9ICcgJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzMzXSA9ICdQYWdlVXAnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMzRdID0gJ1BhZ2VEb3duJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzM1XSA9ICdFbmQnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMzZdID0gJ0hvbWUnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMzddID0gJ0Fycm93TGVmdCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVszOF0gPSAnQXJyb3dVcCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVszOV0gPSAnQXJyb3dSaWdodCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs0MF0gPSAnQXJyb3dEb3duJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzQ1XSA9ICdJbnNlcnQnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbNDZdID0gJ0RlbGV0ZSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs0OF0gPSAnMCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs0OV0gPSAnMSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1MF0gPSAnMic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1MV0gPSAnMyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1Ml0gPSAnNCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1M10gPSAnNSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1NF0gPSAnNic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1NV0gPSAnNyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1Nl0gPSAnOCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs1N10gPSAnOSc7XG4vLyBbNjUsICdhJ10sXG4vLyBbNjYsICdiJ10sXG4vLyBbNjcsICdjJ10sXG4vLyBbNjgsICdkJ10sXG4vLyBbNjksICdlJ10sXG4vLyBbNzAsICdmJ10sXG4vLyBbNzEsICdnJ10sXG4vLyBbNzIsICdoJ10sXG4vLyBbNzMsICdpJ10sXG4vLyBbNzQsICdqJ10sXG4vLyBbNzUsICdrJ10sXG4vLyBbNzYsICdsJ10sXG4vLyBbNzcsICdtJ10sXG4vLyBbNzgsICduJ10sXG4vLyBbNzksICdvJ10sXG4vLyBbODAsICdwJ10sXG4vLyBbODEsICdxJ10sXG4vLyBbODIsICdyJ10sXG4vLyBbODMsICdzJ10sXG4vLyBbODQsICd0J10sXG4vLyBbODUsICd1J10sXG4vLyBbODYsICd2J10sXG4vLyBbODcsICd3J10sXG4vLyBbODgsICd4J10sXG4vLyBbODksICd5J10sXG4vLyBbOTAsICd6J10sXG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs5MV0gPSAnT1MnOyAvLyBOb3RlOiBGaXJlZm94IGFuZCBDaHJvbWUgcmVwb3J0cyAnT1MnIGluc3RlYWQgb2YgJ09TTGVmdCdcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzkyXSA9ICdPU1JpZ2h0JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzkzXSA9ICdDb250ZXh0TWVudSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs5Nl0gPSAgJzAnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbOTddID0gICcxJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzk4XSA9ICAnMic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVs5OV0gPSAgJzMnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTAwXSA9ICc0JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzEwMV0gPSAnNSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMDJdID0gJzYnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTAzXSA9ICc3JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzEwNF0gPSAnOCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMDVdID0gJzknO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTA2XSA9ICcqJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzEwN10gPSAnKyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMDldID0gJy0nO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTEwXSA9ICcuJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzExMV0gPSAnLyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMTJdID0gJ0YxJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzExM10gPSAnRjInO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTE0XSA9ICdGMyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMTVdID0gJ0Y0JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzExNl0gPSAnRjUnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTE3XSA9ICdGNic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMThdID0gJ0Y3JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzExOV0gPSAnRjgnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTIwXSA9ICdGOSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMjFdID0gJ0YxMCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMjJdID0gJ0YxMSc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxMjNdID0gJ0YxMic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxNDRdID0gJ051bUxvY2snO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTQ1XSA9ICdTY3JvbGxMb2NrJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzE4Ml0gPSAnTXlDb21wdXRlcic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxODNdID0gJ015Q2FsY3VsYXRvcic7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxODZdID0gJzsnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTg3XSA9ICc9JztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzE4OF0gPSAnLCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxODldID0gJy0nO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMTkwXSA9ICcuJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzE5MV0gPSAnLyc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsxOTJdID0gJ2AnO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMjE5XSA9ICdbJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzIyMF0gPSAnXFxcXCc7XG5BdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVsyMjFdID0gJ10nO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMjIyXSA9IFwiJ1wiO1xuQXV0b051bWVyaWNFbnVtLmZyb21DaGFyQ29kZUtleUNvZGVbMjI0XSA9ICdNZXRhJztcbkF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlWzIyNV0gPSAnQWx0R3JhcGgnO1xuXG5leHBvcnQgZGVmYXVsdCBBdXRvTnVtZXJpY0VudW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNFbnVtLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Helper functions for autoNumeric.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright © 2016 Alexandre Bonneau\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * obtaining a copy of this software and associated documentation\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * files (the \"Software\"), to deal in the Software without\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * restriction, including without limitation the rights to use,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copy, modify, merge, publish, distribute, sub license, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Software is furnished to do so, subject to the following\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * included in all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OTHER DEALINGS IN THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _AutoNumericEnum = __webpack_require__(2);\n\nvar _AutoNumericEnum2 = _interopRequireDefault(_AutoNumericEnum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Static class that holds all the helper functions autoNumeric uses.\n * Note : none of the functions in there are aware of any autoNumeric internals (which means there are no references to autoNumeric-specific info like options names or data structures).\n */\nvar AutoNumericHelper = function () {\n    function AutoNumericHelper() {\n        _classCallCheck(this, AutoNumericHelper);\n    }\n\n    _createClass(AutoNumericHelper, null, [{\n        key: 'isNull',\n\n        /**\n         * Return `true` if the `value` is null\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is null, FALSE otherwise\n         */\n        value: function isNull(value) {\n            return value === null;\n        }\n\n        /**\n         * Return `true` if the `value` is undefined\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is undefined, FALSE otherwise\n         */\n\n    }, {\n        key: 'isUndefined',\n        value: function isUndefined(value) {\n            return value === void 0;\n        }\n\n        /**\n         * Return `true` if the `value` is undefined, null or empty\n         *\n         * @param {*} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isUndefinedOrNullOrEmpty',\n        value: function isUndefinedOrNullOrEmpty(value) {\n            return value === null || value === void 0 || '' === value;\n        }\n\n        /**\n         * Return `true` if the given parameter is a String\n         *\n         * @param {*} str\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isString',\n        value: function isString(str) {\n            return typeof str === 'string' || str instanceof String;\n        }\n        /**\n         * Return `true` if the `value` is an empty string ''\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is an empty string '', FALSE otherwise\n         */\n\n    }, {\n        key: 'isEmptyString',\n        value: function isEmptyString(value) {\n            return value === '';\n        }\n\n        /**\n         * Return `true` if the parameter is a boolean\n         *\n         * @static\n         * @param {*} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isBoolean',\n        value: function isBoolean(value) {\n            return typeof value === 'boolean';\n        }\n\n        /**\n         * Return `true` if the parameter is a string 'true' or 'false'\n         *\n         * This function accepts any cases for those strings.\n         * @param {string} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isTrueOrFalseString',\n        value: function isTrueOrFalseString(value) {\n            var lowercaseValue = String(value).toLowerCase();\n            return lowercaseValue === 'true' || lowercaseValue === 'false';\n        }\n\n        /**\n         * Return `true` if the parameter is an object\n         *\n         * @param {*} reference\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isObject',\n        value: function isObject(reference) {\n            return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n        }\n\n        /**\n         * Return `true` if the given object is empty\n         * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n         *\n         * @param {object} obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isEmptyObj',\n        value: function isEmptyObj(obj) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Return `true` if the parameter is a real number (and not a numeric string).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumberStrict',\n        value: function isNumberStrict(n) {\n            return typeof n === 'number';\n        }\n\n        /**\n         * Return `true` if the parameter is a number (or a number written as a string).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumber',\n        value: function isNumber(n) {\n            return !this.isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n        }\n\n        /**\n         * Return `true` if the parameter is a number (or a number written as a string).\n         * This version also accepts Arabic and Persian numbers.\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumberOrArabic',\n        value: function isNumberOrArabic(n) {\n            var latinConvertedNumber = this.arabicToLatinNumbers(n, false, true, true);\n            return this.isNumber(latinConvertedNumber);\n        }\n\n        /**\n         * Return `true` if the parameter is an integer (and not a float).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isInt',\n        value: function isInt(n) {\n            return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n        }\n\n        /**\n         * Return `true` if the parameter is a function.\n         *\n         * @param {function} func\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isFunction',\n        value: function isFunction(func) {\n            return typeof func === 'function';\n        }\n\n        /**\n         * Return `true` is the string `str` contains the string `needle`\n         * Note: this function does not coerce the parameters types\n         *\n         * @param {string} str\n         * @param {string} needle\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'contains',\n        value: function contains(str, needle) {\n            //TODO Use `Array.prototype.includes()` when available (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n            if (!this.isString(str) || !this.isString(needle) || str === '' || needle === '') {\n                return false;\n            }\n\n            return str.indexOf(needle) !== -1;\n        }\n\n        /**\n         * Return `true` if the `needle` is in the array\n         *\n         * @param {*} needle\n         * @param {Array} array\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isInArray',\n        value: function isInArray(needle, array) {\n            if (!this.isArray(array) || array === [] || this.isUndefined(needle)) {\n                return false;\n            }\n\n            return array.indexOf(needle) !== -1;\n        }\n\n        /**\n         * Return `true` if the parameter is an Array\n         * //TODO Replace this by the default `Array.isArray()` function?\n         *\n         * @param {*} arr\n         * @throws Error\n         * @returns {*|boolean}\n         */\n\n    }, {\n        key: 'isArray',\n        value: function isArray(arr) {\n            if (Object.prototype.toString.call([]) === '[object Array]') {\n                // Make sure an array has a class attribute of [object Array]\n                // Test passed, now check if is an Array\n                return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n            } else {\n                throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n            }\n        }\n\n        /**\n         * Return `true` if the parameter is a DOM element\n         * cf. http://stackoverflow.com/a/4754104/2834898\n         *\n         * @param {*} obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isElement',\n        value: function isElement(obj) {\n            // return !!(obj && obj.nodeName);\n            // return obj && 'nodeType' in obj;\n            // return obj instanceof Element || obj instanceof HTMLInputElement || obj instanceof HTMLElement;\n            return obj instanceof Element;\n        }\n\n        /**\n         * Return `true` in the given DOM element is an <input>.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: 'isInputElement',\n        value: function isInputElement(domElement) {\n            return this.isElement(domElement) && domElement.tagName.toLowerCase() === 'input';\n        }\n\n        /**\n         * Return `true` if the parameter is a string that represents a float number, and that number has a decimal part\n         *\n         * @param {string} str\n         * @returns {boolean}\n         */\n        // static hasDecimals(str) {\n        //     const [, decimalPart] = str.split('.');\n        //     return !isUndefined(decimalPart);\n        // }\n\n        /**\n         * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n         *\n         * @param {string} str\n         * @returns {int}\n         */\n\n    }, {\n        key: 'decimalPlaces',\n        value: function decimalPlaces(str) {\n            var _str$split = str.split('.'),\n                _str$split2 = _slicedToArray(_str$split, 2),\n                decimalPart = _str$split2[1];\n\n            if (!this.isUndefined(decimalPart)) {\n                return decimalPart.length;\n            }\n\n            return 0;\n        }\n\n        /**\n         * Return the code for the key used to generate the given event.\n         *\n         * @param {Event} event\n         * @returns {string|Number}\n         */\n\n    }, {\n        key: 'keyCodeNumber',\n        value: function keyCodeNumber(event) {\n            // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n            // Also, do note that Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n            return typeof event.which === 'undefined' ? event.keyCode : event.which;\n        }\n\n        /**\n         * Return the character from the event key code.\n         * If the KeyboardEvent does not represent a printable character, then the key name is used (ie. 'Meta', 'Shift', 'F1', etc.)\n         * @example character(50) => '2'\n         *\n         * @param {KeyboardEvent} event\n         * @returns {string}\n         */\n\n    }, {\n        key: 'character',\n        value: function character(event) {\n            var result = void 0;\n            if (event.key === 'Unidentified' || event.key === void 0 || this.isSeleniumBot()) {\n                //XXX The selenium geckodriver do not understand `event.key`, hence when using it, we need to rely on the old deprecated `keyCode` attribute, cf. upstream issue https://github.com/mozilla/geckodriver/issues/440\n                // Use the old deprecated keyCode property, if the new `key` one is not supported\n                var keyCode = this.keyCodeNumber(event);\n                if (keyCode === _AutoNumericEnum2.default.keyCode.AndroidDefault) {\n                    return _AutoNumericEnum2.default.keyName.AndroidDefault;\n                }\n\n                var potentialResult = _AutoNumericEnum2.default.fromCharCodeKeyCode[keyCode];\n                if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(potentialResult)) {\n                    // Since `String.fromCharCode` do not return named keys for some keys ('Escape' and 'Enter' for instance), we convert the characters to the key names\n                    result = potentialResult;\n                } else {\n                    result = String.fromCharCode(keyCode);\n                }\n            } else {\n                var browser = void 0;\n                switch (event.key) {\n                    // Manages all the special cases for obsolete browsers that return the non-standard names\n                    case 'Add':\n                        result = _AutoNumericEnum2.default.keyName.NumpadPlus;\n                        break;\n                    case 'Apps':\n                        result = _AutoNumericEnum2.default.keyName.ContextMenu;\n                        break;\n                    case 'Crsel':\n                        result = _AutoNumericEnum2.default.keyName.CrSel;\n                        break;\n                    case 'Decimal':\n                        result = _AutoNumericEnum2.default.keyName.NumpadDot;\n                        break;\n                    case 'Del':\n                        browser = this.browser();\n                        if ((browser.name = 'firefox' && browser.version <= 36) || (browser.name = 'ie' && browser.version <= 9)) {\n                            // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401\n                            // This workaround break the usage of the 'Delete' key for Firefox <=36, and IE9, since those browser send 'Del' instead of 'Delete', therefore we only use it for those obsolete browsers\n                            result = _AutoNumericEnum2.default.keyName.Dot;\n                        } else {\n                            result = _AutoNumericEnum2.default.keyName.Delete;\n                        }\n                        break;\n                    case 'Divide':\n                        result = _AutoNumericEnum2.default.keyName.NumpadSlash;\n                        break;\n                    case 'Down':\n                        result = _AutoNumericEnum2.default.keyName.DownArrow;\n                        break;\n                    case 'Esc':\n                        result = _AutoNumericEnum2.default.keyName.Esc;\n                        break;\n                    case 'Exsel':\n                        result = _AutoNumericEnum2.default.keyName.ExSel;\n                        break;\n                    case 'Left':\n                        result = _AutoNumericEnum2.default.keyName.LeftArrow;\n                        break;\n                    case 'Meta':\n                    case 'Super':\n                        result = _AutoNumericEnum2.default.keyName.OSLeft;\n                        break;\n                    case 'Multiply':\n                        result = _AutoNumericEnum2.default.keyName.NumpadMultiply;\n                        break;\n                    case 'Right':\n                        result = _AutoNumericEnum2.default.keyName.RightArrow;\n                        break;\n                    case 'Spacebar':\n                        result = _AutoNumericEnum2.default.keyName.Space;\n                        break;\n                    case 'Subtract':\n                        result = _AutoNumericEnum2.default.keyName.NumpadMinus;\n                        break;\n                    case 'Up':\n                        result = _AutoNumericEnum2.default.keyName.UpArrow;\n                        break;\n                    default:\n                        // The normal case\n                        result = event.key;\n                }\n            }\n\n            return result;\n        }\n\n        /**\n         * Return an object containing the name and version of the current browser.\n         * @example `browserVersion()` => { name: 'Firefox', version: '42' }\n         * Based on http://stackoverflow.com/a/38080051/2834898\n         *\n         * @returns {{ name: string, version: string }}\n         */\n\n    }, {\n        key: 'browser',\n        value: function browser() {\n            var ua = navigator.userAgent;\n            var tem = void 0;\n            var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n\n            if (/trident/i.test(M[1])) {\n                tem = /\\brv[ :]+(\\d+)/g.exec(ua) || [];\n                return { name: 'ie', version: tem[1] || '' };\n            }\n\n            if (M[1] === 'Chrome') {\n                tem = ua.match(/\\b(OPR|Edge)\\/(\\d+)/);\n                if (tem !== null) {\n                    return { name: tem[1].replace('OPR', 'opera'), version: tem[2] };\n                }\n            }\n\n            M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];\n            if ((tem = ua.match(/version\\/(\\d+)/i)) !== null) {\n                M.splice(1, 1, tem[1]);\n            }\n\n            return { name: M[0].toLowerCase(), version: M[1] };\n        }\n\n        /**\n         * Check if the browser is controlled by Selenium.\n         * Note: This only works within the geckodriver.\n         * cf. http://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isSeleniumBot',\n        value: function isSeleniumBot() {\n            // noinspection JSUnresolvedVariable\n            return window.navigator.webdriver === true;\n        }\n\n        /**\n         * Return `true` if the given number is negative, or if the given string contains a negative sign :\n         * - everywhere in the string (by default), or\n         * - on the first character only if the `checkEverywhere` parameter is set to `false`.\n         *\n         * @param {number|string} numberOrNumericString A Number, or a number represented by a string\n         * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegative',\n        value: function isNegative(numberOrNumericString) {\n            var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (numberOrNumericString === '-') {\n                return true;\n            }\n\n            if (numberOrNumericString === '') {\n                return false;\n            }\n\n            //TODO Use the `negativeSignCharacter` from the settings here\n            if (AutoNumericHelper.isNumber(numberOrNumericString)) {\n                return numberOrNumericString < 0;\n            }\n\n            if (checkEverywhere) {\n                return this.contains(numberOrNumericString, '-');\n            }\n\n            return this.isNegativeStrict(numberOrNumericString);\n        }\n\n        /**\n         * Return `true` if the given string contains a negative sign on the first character (on the far left).\n         *\n         * @example isNegativeStrict('1234.56')     => false\n         * @example isNegativeStrict('1234.56-')    => false\n         * @example isNegativeStrict('-1234.56')    => true\n         * @example isNegativeStrict('-1,234.56 €') => true\n         *\n         * @param {string} numericString\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegativeStrict',\n        value: function isNegativeStrict(numericString) {\n            //TODO Using the `negativeSignCharacter` from the settings here\n            return numericString.charAt(0) === '-';\n        }\n\n        /**\n         * Return `true` if the very first character is the opening bracket, and if the rest of the `valueString` also has the closing bracket.\n         *\n         * @param {string} valueString\n         * @param {string} leftBracket\n         * @param {string} rightBracket\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegativeWithBrackets',\n        value: function isNegativeWithBrackets(valueString, leftBracket, rightBracket) {\n            return valueString.charAt(0) === leftBracket && this.contains(valueString, rightBracket);\n        }\n\n        /**\n         * Return `true` if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\n         * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\n         *\n         * @param {string} numericString\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isZeroOrHasNoValue',\n        value: function isZeroOrHasNoValue(numericString) {\n            return !/[1-9]/g.test(numericString);\n        }\n\n        /**\n         * Return the negative version of the value (represented as a string) given as a parameter.\n         *\n         * @param {string} value\n         * @returns {*}\n         */\n\n    }, {\n        key: 'setRawNegativeSign',\n        value: function setRawNegativeSign(value) {\n            if (!this.isNegativeStrict(value)) {\n                return '-' + value;\n            }\n\n            return value;\n        }\n\n        /**\n         * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n         *\n         * @param {string} string\n         * @param {int} index\n         * @param {string} newCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: 'replaceCharAt',\n        value: function replaceCharAt(string, index, newCharacter) {\n            return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n        }\n\n        /**\n         * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n         *\n         * @param {string|number} value\n         * @param {object} settings\n         * @returns {number}\n         */\n\n    }, {\n        key: 'clampToRangeLimits',\n        value: function clampToRangeLimits(value, settings) {\n            //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n            return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n        }\n\n        /**\n         * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n         *\n         * @param {string} formattedNumberString\n         * @param {int} caretPosition This must be a positive integer\n         * @param {string} decimalCharacter\n         * @returns {number}\n         */\n\n    }, {\n        key: 'countNumberCharactersOnTheCaretLeftSide',\n        value: function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n            // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n            var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n            var numberDotAndNegativeSignCount = 0;\n            for (var i = 0; i < caretPosition; i++) {\n                // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n                if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                    numberDotAndNegativeSignCount++;\n                }\n            }\n\n            return numberDotAndNegativeSignCount;\n        }\n\n        /**\n         * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n         * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n         * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n         * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n         *\n         * @example\n         * 1234567|89.01   : position 7 (rawNumberString)\n         * 123.456.7|89,01 : position 9 (formattedNumberString)\n         *\n         * @param {string} rawNumberString\n         * @param {int} caretPositionInRawValue\n         * @param {string} formattedNumberString\n         * @param {string} decimalCharacter\n         * @returns {*}\n         */\n\n    }, {\n        key: 'findCaretPositionInFormattedNumber',\n        value: function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n            var formattedNumberStringSize = formattedNumberString.length;\n            var rawNumberStringSize = rawNumberString.length;\n\n            var formattedNumberStringIndex = void 0;\n            var rawNumberStringIndex = 0;\n            for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n                if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                    rawNumberStringIndex++;\n                }\n            }\n\n            return formattedNumberStringIndex;\n        }\n\n        /**\n         * Count the number of occurrence of the given character, in the given text.\n         *\n         * @param {string} character\n         * @param {string} text\n         * @returns {number}\n         */\n\n    }, {\n        key: 'countCharInText',\n        value: function countCharInText(character, text) {\n            var charCounter = 0;\n            for (var i = 0; i < text.length; i++) {\n                if (text[i] === character) {\n                    charCounter++;\n                }\n            }\n\n            return charCounter;\n        }\n\n        /**\n         * Return the index that can be used to set the caret position.\n         * This takes into account that the position is starting at '0', not 1.\n         *\n         * @param {int} characterCount\n         * @returns {number}\n         */\n\n    }, {\n        key: 'convertCharacterCountToIndexPosition',\n        value: function convertCharacterCountToIndexPosition(characterCount) {\n            return Math.max(characterCount, characterCount - 1);\n        }\n\n        /**\n         * Cross browser routine for getting selected range/cursor position.\n         * Note: this also works with edge cases like contenteditable-enabled elements, and hidden inputs.\n         *\n         * @param {HTMLInputElement|EventTarget} element\n         * @returns {{}}\n         */\n\n    }, {\n        key: 'getElementSelection',\n        value: function getElementSelection(element) {\n            var position = {};\n\n            var isSelectionStartUndefined = void 0;\n            try {\n                isSelectionStartUndefined = this.isUndefined(element.selectionStart);\n            } catch (error) {\n                isSelectionStartUndefined = false;\n            }\n\n            try {\n                if (isSelectionStartUndefined) {\n                    var selection = window.getSelection();\n                    var selectionInfo = selection.getRangeAt(0);\n                    position.start = selectionInfo.startOffset;\n                    position.end = selectionInfo.endOffset;\n                    position.length = position.end - position.start;\n                } else {\n                    position.start = element.selectionStart;\n                    position.end = element.selectionEnd;\n                    position.length = position.end - position.start;\n                }\n            } catch (error) {\n                // Manages the cases where :\n                // - the 'contenteditable' elements that have no selections\n                // - the <input> element is of type 'hidden'\n                position.start = 0;\n                position.end = 0;\n                position.length = 0;\n            }\n\n            return position;\n        }\n\n        /**\n         * Cross browser routine for setting selected range/cursor position\n         *\n         * @param {HTMLInputElement|EventTarget} element\n         * @param {int} start\n         * @param {int|null} end\n         */\n\n    }, {\n        key: 'setElementSelection',\n        value: function setElementSelection(element, start) {\n            var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (this.isUndefinedOrNullOrEmpty(end)) {\n                end = start;\n            }\n\n            if (this.isInputElement(element)) {\n                element.setSelectionRange(start, end);\n            } else if (!AutoNumericHelper.isNull(element.firstChild)) {\n                var range = document.createRange();\n                range.setStart(element.firstChild, start);\n                range.setEnd(element.firstChild, end);\n                var selection = window.getSelection();\n                selection.removeAllRanges();\n                selection.addRange(range);\n            }\n        }\n\n        /**\n         * Function that throw error messages\n         *\n         * @param {string} message\n         * @throws\n         */\n\n    }, {\n        key: 'throwError',\n        value: function throwError(message) {\n            throw new Error(message);\n        }\n\n        /**\n         * Function that display a warning messages, according to the debug level.\n         *\n         * @param {string} message\n         * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n         */\n\n    }, {\n        key: 'warning',\n        value: function warning(message) {\n            var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (showWarning) {\n                /* eslint no-console: 0 */\n                console.warn('Warning: ' + message);\n            }\n        }\n\n        /**\n         * Return `true` if the given event is a wheelup event\n         *\n         * @param {WheelEvent} wheelEvent\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isWheelUpEvent',\n        value: function isWheelUpEvent(wheelEvent) {\n            if (!wheelEvent.deltaY) {\n                this.throwError('The event passed as a parameter is not a wheel event, ' + wheelEvent.type + ' given.');\n            }\n\n            return wheelEvent.deltaY < 0;\n        }\n\n        /**\n         * Return `true` if the given event is a wheeldown event\n         *\n         * @param {WheelEvent} wheelEvent\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isWheelDownEvent',\n        value: function isWheelDownEvent(wheelEvent) {\n            if (!wheelEvent.deltaY) {\n                this.throwError('The event passed as a parameter is not a wheel event, ' + wheelEvent.type + ' given.');\n            }\n\n            return wheelEvent.deltaY > 0;\n        }\n\n        /**\n         * Return the 'nearest rounded' value, according to the given step size.\n         * @example roundToNearest(264789, 10000)) => 260000\n         *\n         * @param {number} value\n         * @param {number} stepPlace\n         * @returns {*}\n         */\n\n    }, {\n        key: 'roundToNearest',\n        value: function roundToNearest(value) {\n            var stepPlace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n            if (value <= 10 && value >= -10) {\n                return value;\n            }\n\n            if (0 === value) {\n                return 0;\n            }\n\n            return Math.round(value / stepPlace) * stepPlace;\n        }\n\n        /**\n         * Return the 'nearest rounded' value automatically by adding or subtracting the calculated offset to the initial value.\n         * This is done without having to pass a step to this function.\n         * @example                    Calculated offset\n         *           1 ->           1 (10)\n         *          14 ->          10 (10)\n         *         143 ->         140 (10)\n         *       1.278 ->       1.300 (100)\n         *      28.456 ->      28.500 (100)\n         *     276.345 ->     276.000 (1000)\n         *   4.534.061 ->   4.530.000 (10000)\n         *  66.723.844 ->  66.700.000 (100000)\n         * 257.833.411 -> 258.000.000 (1000000)\n         *\n         * @param {number} value\n         * @param {boolean} isAddition\n         * @returns {*}\n         */\n\n    }, {\n        key: 'modifyAndRoundToNearestAuto',\n        value: function modifyAndRoundToNearestAuto(value, isAddition) {\n            value = parseInt(value, 10);\n            var lengthValue = Math.abs(value).toString().length; // Math.abs is needed here to omit the negative sign '-' in case of a negative value\n\n            var pow = void 0;\n            switch (lengthValue) {\n                // Special cases for small numbers\n                case 1:\n                case 2:\n                case 3:\n                    pow = 1;\n                    break;\n                case 4:\n                case 5:\n                    pow = 2;\n                    break;\n                // Default behavior\n                default:\n                    pow = lengthValue - 3;\n            }\n            var offset = Math.pow(10, pow);\n\n            var result = void 0;\n            if (isAddition) {\n                result = value + offset;\n            } else {\n                result = value - offset;\n            }\n\n            return this.roundToNearest(result, Math.pow(10, pow));\n        }\n\n        /**\n         * Return the 'nearest rounded' value automatically by adding the calculated offset to the initial value.\n         *\n         * @param {number} value\n         * @returns {*}\n         */\n\n    }, {\n        key: 'addAndRoundToNearestAuto',\n        value: function addAndRoundToNearestAuto(value) {\n            return this.modifyAndRoundToNearestAuto(value, true);\n        }\n\n        /**\n         * Return the 'nearest rounded' value automatically by subtracting the calculated offset to the initial value.\n         *\n         * @param {number} value\n         * @returns {*}\n         */\n\n    }, {\n        key: 'subtractAndRoundToNearestAuto',\n        value: function subtractAndRoundToNearestAuto(value) {\n            return this.modifyAndRoundToNearestAuto(value, false);\n        }\n\n        /**\n         * Take an arabic number as a string and return a javascript number.\n         * By default, this function does not try to convert the arabic decimal and thousand separator characters.\n         * This returns `NaN` is the conversion is not possible.\n         * Based on http://stackoverflow.com/a/17025392/2834898\n         *\n         * @param {string} arabicNumbers\n         * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\n         * @param {boolean} parseDecimalCharacter\n         * @param {boolean} parseThousandSeparator\n         * @returns {string|number|NaN}\n         */\n\n    }, {\n        key: 'arabicToLatinNumbers',\n        value: function arabicToLatinNumbers(arabicNumbers) {\n            var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            if (this.isNull(arabicNumbers)) {\n                return arabicNumbers;\n            }\n\n            var result = arabicNumbers.toString();\n            if (result === '') {\n                return arabicNumbers;\n            }\n\n            if (result.match(/[٠١٢٣٤٥٦٧٨٩۴۵۶]/g) === null) {\n                // If no Arabic/Persian numbers are found, return the numeric string or number directly\n                if (returnANumber) {\n                    result = Number(result);\n                }\n\n                return result;\n            }\n\n            if (parseDecimalCharacter) {\n                result = result.replace(/٫/, '.'); // Decimal character\n            }\n\n            if (parseThousandSeparator) {\n                result = result.replace(/٬/g, ''); // Thousand separator\n            }\n\n            // Replace the numbers only\n            result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n                return d.charCodeAt(0) - 1632;\n            }) // Arabic numbers\n            .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n                return d.charCodeAt(0) - 1776;\n            }); // Persian numbers\n\n            // `NaN` has precedence over the string `'NaN'`\n            var resultAsNumber = Number(result);\n            if (isNaN(resultAsNumber)) {\n                return resultAsNumber;\n            }\n\n            if (returnANumber) {\n                result = resultAsNumber;\n            }\n\n            return result;\n        }\n\n        /**\n         * Create a custom event and immediately sent it from the given element.\n         * By default, if no element is given, the event is thrown from `document`.\n         *\n         * @param {string} eventName\n         * @param {HTMLElement|HTMLDocument} element\n         * @param {object} detail\n         */\n\n    }, {\n        key: 'triggerEvent',\n        value: function triggerEvent(eventName) {\n            var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n            var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            var event = void 0;\n            if (window.CustomEvent) {\n                event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n            } else {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(eventName, true, true, { detail: detail });\n            }\n\n            element.dispatchEvent(event);\n        }\n\n        /**\n         * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n         * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n         *\n         * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n         *\n         * @param {number|string} n A numeric value.\n         * @returns {{}}\n         */\n\n    }, {\n        key: 'parseStr',\n        value: function parseStr(n) {\n            var x = {}; // A Big number instance.\n            var e = void 0;\n            var i = void 0;\n            var nL = void 0;\n            var j = void 0;\n\n            // Minus zero?\n            if (n === 0 && 1 / n < 0) {\n                n = '-0';\n            }\n\n            // Determine sign. 1 positive, -1 negative\n            n = n.toString();\n            if (this.isNegativeStrict(n)) {\n                n = n.slice(1);\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n\n            // Decimal point?\n            e = n.indexOf('.');\n            if (e > -1) {\n                n = n.replace('.', '');\n            }\n\n            // length of string if no decimal character\n            if (e < 0) {\n                // Integer\n                e = n.length;\n            }\n\n            // Determine leading zeros\n            i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n            nL = n.length;\n            if (i === nL) {\n                // Zero\n                x.e = 0;\n                x.c = [0];\n            } else {\n                // Determine trailing zeros\n                for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                    nL -= 1;\n                }\n                nL -= 1;\n\n                // Decimal location\n                x.e = e - i - 1;\n                x.c = [];\n\n                // Convert string to array of digits without leading/trailing zeros\n                for (e = 0; i <= nL; i += 1) {\n                    x.c[e] = +n.charAt(i);\n                    e += 1;\n                }\n            }\n\n            return x;\n        }\n\n        /**\n         * Function to test if the input value falls with the Min / Max settings.\n         * This uses the parsed strings for the above parseStr function.\n         *\n         * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n         *\n         * @param {object} y Big number instance\n         * @param {object} x Big number instance\n         * @returns {*}\n         */\n\n    }, {\n        key: 'testMinMax',\n        value: function testMinMax(y, x) {\n            var xc = x.c;\n            var yc = y.c;\n            var i = x.s;\n            var j = y.s;\n            var k = x.e;\n            var l = y.e;\n\n            // Either zero?\n            if (!xc[0] || !yc[0]) {\n                var _result = void 0;\n                if (!xc[0]) {\n                    _result = !yc[0] ? 0 : -j;\n                } else {\n                    _result = i;\n                }\n                return _result;\n            }\n\n            // Signs differ?\n            if (i !== j) {\n                return i;\n            }\n            var xNeg = i < 0;\n\n            // Compare exponents\n            if (k !== l) {\n                return k > l ^ xNeg ? 1 : -1;\n            }\n            i = -1;\n            k = xc.length;\n            l = yc.length;\n            j = k < l ? k : l;\n\n            // Compare digit by digit\n            for (i += 1; i < j; i += 1) {\n                if (xc[i] !== yc[i]) {\n                    return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n                }\n            }\n\n            // Compare lengths\n            var result = void 0;\n            if (k === l) {\n                result = 0;\n            } else {\n                result = k > l ^ xNeg ? 1 : -1;\n            }\n\n            return result;\n        }\n\n        /**\n         * Generate a random string.\n         * cf. http://stackoverflow.com/a/8084248/2834898\n         *\n         * @param {Number} strLength Length of the generated string (in character count)\n         * @returns {string}\n         */\n\n    }, {\n        key: 'randomString',\n        value: function randomString() {\n            var strLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n            return Math.random().toString(36).substr(2, strLength);\n        }\n\n        /**\n         * Retrieve the current element value.\n         *\n         * @param {HTMLElement|HTMLInputElement|EventTarget} element\n         * @returns {number|string|null}\n         */\n\n    }, {\n        key: 'getElementValue',\n        value: function getElementValue(element) {\n            if (element.tagName.toLowerCase() === 'input') {\n                return element.value;\n            }\n\n            return this.text(element);\n        }\n\n        /**\n         * Modify the element value directly.\n         *\n         * @param {HTMLElement|HTMLInputElement} element\n         * @param {number|string|null} value\n         */\n\n    }, {\n        key: 'setElementValue',\n        value: function setElementValue(element) {\n            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (element.tagName.toLowerCase() === 'input') {\n                element.value = value;\n            } else {\n                element.textContent = value;\n            }\n        }\n\n        /**\n         * This clone the given object, and return it.\n         * WARNING: This does not do a deep cloning.\n         * cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Examples\n         * //TODO Add a `deep` option to clone object with more than one depth\n         *\n         * @param {object} obj\n         * @returns {object}\n         */\n\n    }, {\n        key: 'cloneObject',\n        value: function cloneObject(obj) {\n            return _extends({}, obj);\n        }\n\n        /**\n         * Return a 'camelized' version of the given string.\n         * By default, this assume that :\n         * - the separators are hyphens '-',\n         * - the 'data-' string should be removed, and\n         * - that the very first word should not be capitalized.\n         *\n         * @example camelize('data-currency-symbol') => 'currencySymbol'\n         *\n         * @param {string} str Text to camelize\n         * @param {string} separator Character that separate each word\n         * @param {boolean} removeData If set to `true`, remove the `data-` part that you can find on some html attributes\n         * @param {boolean} skipFirstWord If set to `true`, do not capitalize the very first word\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'camelize',\n        value: function camelize(str) {\n            var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n            var removeData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            var skipFirstWord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (this.isNull(str)) {\n                return null;\n            }\n\n            if (removeData) {\n                str = str.replace(/^data-/, '');\n            }\n\n            // Cut the string into words\n            var words = str.split(separator);\n\n            // Capitalize each word\n            var result = words.map(function (word) {\n                return '' + word.charAt(0).toUpperCase() + word.slice(1);\n            });\n\n            // Then concatenate them back\n            result = result.join('');\n\n            if (skipFirstWord) {\n                // Skip the very first letter\n                result = '' + result.charAt(0).toLowerCase() + result.slice(1);\n            }\n\n            return result;\n        }\n\n        /**\n         * Return the text component of the given DOM element.\n         *\n         * @param {Element} domElement\n         * @returns {string}\n         */\n\n    }, {\n        key: 'text',\n        value: function text(domElement) {\n            var nodeType = domElement.nodeType;\n\n            var result = void 0;\n            // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n            if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                result = domElement.textContent;\n            } else if (nodeType === Node.TEXT_NODE) {\n                result = domElement.nodeValue;\n            } else {\n                result = '';\n            }\n\n            return result;\n        }\n\n        /**\n         * Set the text content of the given DOM element.\n         * @param {Element} domElement\n         * @param {string} text\n         */\n\n    }, {\n        key: 'setText',\n        value: function setText(domElement, text) {\n            var nodeType = domElement.nodeType;\n            if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                domElement.textContent = text;\n            }\n            //TODO Display a warning if that function does not do anything?\n        }\n\n        /**\n         * Filter out the given `arr` array with the elements found in `excludedElements`.\n         * This returns a new array and does not modify the source.\n         * cf. verification here : http://codepen.io/AnotherLinuxUser/pen/XpvrMg?editors=0012\n         *\n         * @param {Array} arr\n         * @param {Array} excludedElements\n         * @returns {*|Array.<T>}\n         */\n\n    }, {\n        key: 'filterOut',\n        value: function filterOut(arr, excludedElements) {\n            var _this = this;\n\n            return arr.filter(function (element) {\n                return !_this.isInArray(element, excludedElements);\n            });\n        }\n\n        /**\n         * Remove the trailing zeros in the decimal part of a number.\n         *\n         * @param {string} numericString\n         * @returns {*}\n         */\n\n    }, {\n        key: 'trimPaddedZerosFromDecimalPlaces',\n        value: function trimPaddedZerosFromDecimalPlaces(numericString) {\n            numericString = String(numericString);\n            if (numericString === '') {\n                return '';\n            }\n\n            var _numericString$split = numericString.split('.'),\n                _numericString$split2 = _slicedToArray(_numericString$split, 2),\n                integerPart = _numericString$split2[0],\n                decimalPart = _numericString$split2[1];\n\n            if (this.isUndefinedOrNullOrEmpty(decimalPart)) {\n                return integerPart;\n            }\n\n            var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n            var result = void 0;\n            if (trimmedDecimalPart === '') {\n                result = integerPart;\n            } else {\n                result = integerPart + '.' + trimmedDecimalPart;\n            }\n\n            return result;\n        }\n\n        /**\n         * Return the top-most hovered item by the mouse cursor.\n         *\n         * @returns {*}\n         */\n\n    }, {\n        key: 'getHoveredElement',\n        value: function getHoveredElement() {\n            var hoveredElements = [].concat(_toConsumableArray(document.querySelectorAll(':hover')));\n            return hoveredElements[hoveredElements.length - 1];\n        }\n\n        /**\n         * Return the given array trimmed to the given length.\n         * @example arrayTrim([1, 2, 3, 4], 2) -> [1, 2]\n         *\n         * @param {Array} array\n         * @param {Number} length\n         * @returns {*}\n         */\n\n    }, {\n        key: 'arrayTrim',\n        value: function arrayTrim(array, length) {\n            var arrLength = array.length;\n            if (arrLength === 0 || length > arrLength) {\n                // Also manage the case where `length` is higher than the current length\n                return array;\n            }\n\n            if (length < 0) {\n                return [];\n            }\n\n            array.length = parseInt(length, 10);\n\n            return array;\n        }\n\n        /**\n         * Merge all the given arrays by keeping only unique elements, and return an array with de-duplicated values.\n         * cf. http://stackoverflow.com/a/27664971/2834898\n         *\n         * @param {...array} arrays\n         * @returns {[*]}\n         */\n\n    }, {\n        key: 'arrayUnique',\n        value: function arrayUnique() {\n            var _ref;\n\n            //FIXME à tester\n            return [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, arguments))));\n        }\n\n        /**\n         * Merge all the given Maps by keeping only unique elements, and return a new Map with de-duplicated keys.\n         *\n         * @param {...Map} mapObjects\n         * @returns {Map}\n         */\n\n    }, {\n        key: 'mergeMaps',\n        value: function mergeMaps() {\n            for (var _len = arguments.length, mapObjects = Array(_len), _key = 0; _key < _len; _key++) {\n                mapObjects[_key] = arguments[_key];\n            }\n\n            return new Map(mapObjects.reduce(function (as, b) {\n                return as.concat([].concat(_toConsumableArray(b)));\n            }, []));\n        }\n    }]);\n\n    return AutoNumericHelper;\n}();\n\nexports.default = AutoNumericHelper;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNIZWxwZXIuanM/ODU0YyJdLCJuYW1lcyI6WyJBdXRvTnVtZXJpY0hlbHBlciIsInZhbHVlIiwic3RyIiwiU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInJlZmVyZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsIm4iLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImxhdGluQ29udmVydGVkTnVtYmVyIiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJpc051bWJlciIsInBhcnNlSW50IiwiZnVuYyIsIm5lZWRsZSIsImlzU3RyaW5nIiwiaW5kZXhPZiIsImFycmF5IiwiaXNVbmRlZmluZWQiLCJhcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJFcnJvciIsIkVsZW1lbnQiLCJkb21FbGVtZW50IiwiaXNFbGVtZW50IiwidGFnTmFtZSIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJsZW5ndGgiLCJldmVudCIsIndoaWNoIiwia2V5Q29kZSIsInJlc3VsdCIsImtleSIsImlzU2VsZW5pdW1Cb3QiLCJrZXlDb2RlTnVtYmVyIiwiQW5kcm9pZERlZmF1bHQiLCJrZXlOYW1lIiwicG90ZW50aWFsUmVzdWx0IiwiZnJvbUNoYXJDb2RlS2V5Q29kZSIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsImZyb21DaGFyQ29kZSIsImJyb3dzZXIiLCJOdW1wYWRQbHVzIiwiQ29udGV4dE1lbnUiLCJDclNlbCIsIk51bXBhZERvdCIsIm5hbWUiLCJ2ZXJzaW9uIiwiRG90IiwiRGVsZXRlIiwiTnVtcGFkU2xhc2giLCJEb3duQXJyb3ciLCJFc2MiLCJFeFNlbCIsIkxlZnRBcnJvdyIsIk9TTGVmdCIsIk51bXBhZE11bHRpcGx5IiwiUmlnaHRBcnJvdyIsIlNwYWNlIiwiTnVtcGFkTWludXMiLCJVcEFycm93IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZW0iLCJNIiwibWF0Y2giLCJ0ZXN0IiwiZXhlYyIsInJlcGxhY2UiLCJhcHBOYW1lIiwiYXBwVmVyc2lvbiIsInNwbGljZSIsIndpbmRvdyIsIndlYmRyaXZlciIsIm51bWJlck9yTnVtZXJpY1N0cmluZyIsImNoZWNrRXZlcnl3aGVyZSIsImNvbnRhaW5zIiwiaXNOZWdhdGl2ZVN0cmljdCIsIm51bWVyaWNTdHJpbmciLCJjaGFyQXQiLCJ2YWx1ZVN0cmluZyIsImxlZnRCcmFja2V0IiwicmlnaHRCcmFja2V0Iiwic3RyaW5nIiwiaW5kZXgiLCJuZXdDaGFyYWN0ZXIiLCJzdWJzdHIiLCJzZXR0aW5ncyIsIk1hdGgiLCJtYXgiLCJtaW5pbXVtVmFsdWUiLCJtaW4iLCJtYXhpbXVtVmFsdWUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmciLCJjYXJldFBvc2l0aW9uIiwiZGVjaW1hbENoYXJhY3RlciIsIm51bWJlckRvdE9yTmVnYXRpdmVTaWduIiwiUmVnRXhwIiwibnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQiLCJpIiwicmF3TnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplIiwicmF3TnVtYmVyU3RyaW5nU2l6ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IiwicmF3TnVtYmVyU3RyaW5nSW5kZXgiLCJjaGFyYWN0ZXIiLCJ0ZXh0IiwiY2hhckNvdW50ZXIiLCJjaGFyYWN0ZXJDb3VudCIsImVsZW1lbnQiLCJwb3NpdGlvbiIsImlzU2VsZWN0aW9uU3RhcnRVbmRlZmluZWQiLCJzZWxlY3Rpb25TdGFydCIsImVycm9yIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uSW5mbyIsImdldFJhbmdlQXQiLCJzdGFydCIsInN0YXJ0T2Zmc2V0IiwiZW5kIiwiZW5kT2Zmc2V0Iiwic2VsZWN0aW9uRW5kIiwiaXNJbnB1dEVsZW1lbnQiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImlzTnVsbCIsImZpcnN0Q2hpbGQiLCJyYW5nZSIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInNldEVuZCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwibWVzc2FnZSIsInNob3dXYXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJ3aGVlbEV2ZW50IiwiZGVsdGFZIiwidGhyb3dFcnJvciIsInR5cGUiLCJzdGVwUGxhY2UiLCJyb3VuZCIsImlzQWRkaXRpb24iLCJsZW5ndGhWYWx1ZSIsImFicyIsInBvdyIsIm9mZnNldCIsInJvdW5kVG9OZWFyZXN0IiwibW9kaWZ5QW5kUm91bmRUb05lYXJlc3RBdXRvIiwiYXJhYmljTnVtYmVycyIsInJldHVybkFOdW1iZXIiLCJwYXJzZURlY2ltYWxDaGFyYWN0ZXIiLCJwYXJzZVRob3VzYW5kU2VwYXJhdG9yIiwiTnVtYmVyIiwiZCIsImNoYXJDb2RlQXQiLCJyZXN1bHRBc051bWJlciIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJ4IiwiZSIsIm5MIiwiaiIsInNsaWNlIiwicyIsInNlYXJjaCIsImMiLCJ5IiwieGMiLCJ5YyIsImsiLCJsIiwieE5lZyIsInN0ckxlbmd0aCIsInJhbmRvbSIsInRleHRDb250ZW50Iiwic2VwYXJhdG9yIiwicmVtb3ZlRGF0YSIsInNraXBGaXJzdFdvcmQiLCJ3b3JkcyIsIm1hcCIsIndvcmQiLCJ0b1VwcGVyQ2FzZSIsImpvaW4iLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIm5vZGVWYWx1ZSIsImV4Y2x1ZGVkRWxlbWVudHMiLCJmaWx0ZXIiLCJpc0luQXJyYXkiLCJpbnRlZ2VyUGFydCIsInRyaW1tZWREZWNpbWFsUGFydCIsImhvdmVyZWRFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhcnJMZW5ndGgiLCJTZXQiLCJjb25jYXQiLCJtYXBPYmplY3RzIiwiTWFwIiwicmVkdWNlIiwiYXMiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7cWpCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7OztBQUVBOzs7O0lBSXFCQSxpQjs7Ozs7Ozs7QUFDakI7Ozs7Ozs7K0JBT2NDLEssRUFBTztBQUNqQixtQkFBT0EsVUFBVSxJQUFqQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O29DQU9tQkEsSyxFQUFPO0FBQ3RCLG1CQUFPQSxVQUFVLEtBQUssQ0FBdEI7QUFDSDs7QUFFRDs7Ozs7Ozs7O2lEQU1nQ0EsSyxFQUFPO0FBQ25DLG1CQUFPQSxVQUFVLElBQVYsSUFBa0JBLFVBQVUsS0FBSyxDQUFqQyxJQUF1QyxPQUFPQSxLQUFyRDtBQUNIOztBQUVEOzs7Ozs7Ozs7aUNBTWdCQyxHLEVBQUs7QUFDakIsbUJBQVEsT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLGVBQWVDLE1BQWxEO0FBQ0g7QUFDRDs7Ozs7Ozs7OztzQ0FPcUJGLEssRUFBTztBQUN4QixtQkFBT0EsVUFBVSxFQUFqQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O2tDQU9pQkEsSyxFQUFPO0FBQ3BCLG1CQUFPLE9BQU9BLEtBQVAsS0FBa0IsU0FBekI7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs0Q0FPMkJBLEssRUFBTztBQUM5QixnQkFBTUcsaUJBQWlCRCxPQUFPRixLQUFQLEVBQWNJLFdBQWQsRUFBdkI7QUFDQSxtQkFBT0QsbUJBQW1CLE1BQW5CLElBQTZCQSxtQkFBbUIsT0FBdkQ7QUFDSDs7QUFFRDs7Ozs7Ozs7O2lDQU1nQkUsUyxFQUFXO0FBQ3ZCLG1CQUFPLFFBQU9BLFNBQVAseUNBQU9BLFNBQVAsT0FBcUIsUUFBckIsSUFBaUNBLGNBQWMsSUFBL0MsSUFBdUQsQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixTQUFkLENB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WkMsVUFBWTtBQUFaQSwwQkFBWTtBQUFBOztBQUM1QixtQkFBTyxJQUFJQyxHQUFKLENBQVFELFdBQVdFLE1BQVgsQ0FBa0IsVUFBQ0MsRUFBRCxFQUFLQyxDQUFMO0FBQUEsdUJBQVdELEdBQUdKLE1BQUgsOEJBQWNLLENBQWQsR0FBWDtBQUFBLGFBQWxCLEVBQWdELEVBQWhELENBQVIsQ0FBUDtBQUNIOzs7Ozs7a0JBNXRDZ0JsTyxpQiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBhdXRvTnVtZXJpYy5qc1xuICogQGF1dGhvciBBbGV4YW5kcmUgQm9ubmVhdSA8YWxleGFuZHJlLmJvbm5lYXVAbGludXhmci5ldT5cbiAqIEBjb3B5cmlnaHQgwqkgMjAxNiBBbGV4YW5kcmUgQm9ubmVhdVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEF1dG9OdW1lcmljRW51bSBmcm9tICcuL0F1dG9OdW1lcmljRW51bSc7XG5cbi8qKlxuICogU3RhdGljIGNsYXNzIHRoYXQgaG9sZHMgYWxsIHRoZSBoZWxwZXIgZnVuY3Rpb25zIGF1dG9OdW1lcmljIHVzZXMuXG4gKiBOb3RlIDogbm9uZSBvZiB0aGUgZnVuY3Rpb25zIGluIHRoZXJlIGFyZSBhd2FyZSBvZiBhbnkgYXV0b051bWVyaWMgaW50ZXJuYWxzICh3aGljaCBtZWFucyB0aGVyZSBhcmUgbm8gcmVmZXJlbmNlcyB0byBhdXRvTnVtZXJpYy1zcGVjaWZpYyBpbmZvIGxpa2Ugb3B0aW9ucyBuYW1lcyBvciBkYXRhIHN0cnVjdHVyZXMpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvTnVtZXJpY0hlbHBlciB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBudWxsXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIG51bGwsIEZBTFNFIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gZW1wdHkgc3RyaW5nICcnXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGVtcHR5IHN0cmluZyAnJywgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzRW1wdHlTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzVHJ1ZU9yRmFsc2VTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyY2FzZVZhbHVlID09PSAnZmFsc2UnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzT2JqZWN0KHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VtcHR5T2JqKG9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHJlYWwgbnVtYmVyIChhbmQgbm90IGEgbnVtZXJpYyBzdHJpbmcpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtYmVyU3RyaWN0KG4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIgKG9yIGEgbnVtYmVyIHdyaXR0ZW4gYXMgYSBzdHJpbmcpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQXJyYXkobikgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG51bWJlciAob3IgYSBudW1iZXIgd3JpdHRlbiBhcyBhIHN0cmluZykuXG4gICAgICogVGhpcyB2ZXJzaW9uIGFsc28gYWNjZXB0cyBBcmFiaWMgYW5kIFBlcnNpYW4gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc051bWJlck9yQXJhYmljKG4pIHtcbiAgICAgICAgY29uc3QgbGF0aW5Db252ZXJ0ZWROdW1iZXIgPSB0aGlzLmFyYWJpY1RvTGF0aW5OdW1iZXJzKG4sIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOdW1iZXIobGF0aW5Db252ZXJ0ZWROdW1iZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBpbnRlZ2VyIChhbmQgbm90IGEgZmxvYXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzSW50KG4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBwYXJzZUZsb2F0KG4pID09PSBwYXJzZUludChuLCAxMCkgJiYgIWlzTmFOKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIC8vVE9ETyBVc2UgYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcygpYCB3aGVuIGF2YWlsYWJsZSAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luY2x1ZGVzKVxuICAgICAgICBpZiAoIXRoaXMuaXNTdHJpbmcoc3RyKSB8fCAhdGhpcy5pc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGBuZWVkbGVgIGlzIGluIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBcnJheShhcnJheSkgfHwgYXJyYXkgPT09IFtdIHx8IHRoaXMuaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICogLy9UT0RPIFJlcGxhY2UgdGhpcyBieSB0aGUgZGVmYXVsdCBgQXJyYXkuaXNBcnJheSgpYCBmdW5jdGlvbj9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIERPTSBlbGVtZW50XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ3NTQxMDQvMjgzNDg5OFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbGVtZW50KG9iaikge1xuICAgICAgICAvLyByZXR1cm4gISEob2JqICYmIG9iai5ub2RlTmFtZSk7XG4gICAgICAgIC8vIHJldHVybiBvYmogJiYgJ25vZGVUeXBlJyBpbiBvYmo7XG4gICAgICAgIC8vIHJldHVybiBvYmogaW5zdGFuY2VvZiBFbGVtZW50IHx8IG9iaiBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaW4gdGhlIGdpdmVuIERPTSBlbGVtZW50IGlzIGFuIDxpbnB1dD4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0lucHV0RWxlbWVudChkb21FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRWxlbWVudChkb21FbGVtZW50KSAmJiBkb21FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgLy8gc3RhdGljIGhhc0RlY2ltYWxzKHN0cikge1xuICAgIC8vICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAvLyAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjaW1hbFBsYWNlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBrZXlDb2RlTnVtYmVyKGV2ZW50KSB7XG4gICAgICAgIC8vIGBldmVudC5rZXlDb2RlYCBhbmQgYGV2ZW50LndoaWNoYCBhcmUgZGVwcmVjYXRlZCwgYEtleWJvYXJkRXZlbnQua2V5YCAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KSBtdXN0IGJlIHVzZWQgbm93XG4gICAgICAgIC8vIEFsc28sIGRvIG5vdGUgdGhhdCBGaXJlZm94IGdlbmVyYXRlIGEgJ2tleXByZXNzJyBldmVudCAoZS5rZXlDb2RlID09PSAwKSBmb3IgdGhlIGtleXMgdGhhdCBkbyBub3QgcHJpbnQgYSBjaGFyYWN0ZXIgKGllLiAnSW5zZXJ0JywgJ0RlbGV0ZScsICdGbicga2V5cywgJ1BhZ2VVcCcsICdQYWdlRG93bicgZXRjLikuICdTaGlmdCcgb24gdGhlIG90aGVyIGhhbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBrZXlwcmVzcyBldmVudC5cbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2hhcmFjdGVyIGZyb20gdGhlIGV2ZW50IGtleSBjb2RlLlxuICAgICAqIElmIHRoZSBLZXlib2FyZEV2ZW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHByaW50YWJsZSBjaGFyYWN0ZXIsIHRoZW4gdGhlIGtleSBuYW1lIGlzIHVzZWQgKGllLiAnTWV0YScsICdTaGlmdCcsICdGMScsIGV0Yy4pXG4gICAgICogQGV4YW1wbGUgY2hhcmFjdGVyKDUwKSA9PiAnMidcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBjaGFyYWN0ZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ1VuaWRlbnRpZmllZCcgfHwgZXZlbnQua2V5ID09PSB2b2lkKDApIHx8IHRoaXMuaXNTZWxlbml1bUJvdCgpKSB7XG4gICAgICAgICAgICAvL1hYWCBUaGUgc2VsZW5pdW0gZ2Vja29kcml2ZXIgZG8gbm90IHVuZGVyc3RhbmQgYGV2ZW50LmtleWAsIGhlbmNlIHdoZW4gdXNpbmcgaXQsIHdlIG5lZWQgdG8gcmVseSBvbiB0aGUgb2xkIGRlcHJlY2F0ZWQgYGtleUNvZGVgIGF0dHJpYnV0ZSwgY2YuIHVwc3RyZWFtIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvZHJpdmVyL2lzc3Vlcy80NDBcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgb2xkIGRlcHJlY2F0ZWQga2V5Q29kZSBwcm9wZXJ0eSwgaWYgdGhlIG5ldyBga2V5YCBvbmUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgY29uc3Qga2V5Q29kZSA9IHRoaXMua2V5Q29kZU51bWJlcihldmVudCk7XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gQXV0b051bWVyaWNFbnVtLmtleUNvZGUuQW5kcm9pZERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQW5kcm9pZERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbFJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5mcm9tQ2hhckNvZGVLZXlDb2RlW2tleUNvZGVdO1xuICAgICAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkocG90ZW50aWFsUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGBTdHJpbmcuZnJvbUNoYXJDb2RlYCBkbyBub3QgcmV0dXJuIG5hbWVkIGtleXMgZm9yIHNvbWUga2V5cyAoJ0VzY2FwZScgYW5kICdFbnRlcicgZm9yIGluc3RhbmNlKSwgd2UgY29udmVydCB0aGUgY2hhcmFjdGVycyB0byB0aGUga2V5IG5hbWVzXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcG90ZW50aWFsUmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJyb3dzZXI7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgICAgIC8vIE1hbmFnZXMgYWxsIHRoZSBzcGVjaWFsIGNhc2VzIGZvciBvYnNvbGV0ZSBicm93c2VycyB0aGF0IHJldHVybiB0aGUgbm9uLXN0YW5kYXJkIG5hbWVzXG4gICAgICAgICAgICAgICAgY2FzZSAnQWRkJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTnVtcGFkUGx1cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXBwcyc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkNvbnRleHRNZW51O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDcnNlbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkNyU2VsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdEZWNpbWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTnVtcGFkRG90O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdEZWwnOlxuICAgICAgICAgICAgICAgICAgICBicm93c2VyID0gdGhpcy5icm93c2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYnJvd3Nlci5uYW1lID0gJ2ZpcmVmb3gnICYmIGJyb3dzZXIudmVyc2lvbiA8PSAzNikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChicm93c2VyLm5hbWUgPSAnaWUnICYmIGJyb3dzZXIudmVyc2lvbiA8PSA5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCB3b3JrYXJvdW5kIGZvciB0aGUgb2Jzb2xldGUgYnJvd3NlciBJRTExIHdoaWNoIG91dHB1dCBhICdEZWxldGUnIGtleSB3aGVuIHVzaW5nIHRoZSBudW1wYWQgJ2RvdCcgb25lISBUaGlzIGZpeGVzIGlzc3VlICM0MDFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd29ya2Fyb3VuZCBicmVhayB0aGUgdXNhZ2Ugb2YgdGhlICdEZWxldGUnIGtleSBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5LCBzaW5jZSB0aG9zZSBicm93c2VyIHNlbmQgJ0RlbCcgaW5zdGVhZCBvZiAnRGVsZXRlJywgdGhlcmVmb3JlIHdlIG9ubHkgdXNlIGl0IGZvciB0aG9zZSBvYnNvbGV0ZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRG90O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRGVsZXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RpdmlkZSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZFNsYXNoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRG93bkFycm93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFc2MnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5Fc2M7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0V4c2VsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRXhTZWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5MZWZ0QXJyb3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ01ldGEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1N1cGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuT1NMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdNdWx0aXBseSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZE11bHRpcGx5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlJpZ2h0QXJyb3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NwYWNlYmFyJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuU3BhY2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1N1YnRyYWN0JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTnVtcGFkTWludXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuVXBBcnJvdztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lIGFuZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gICAgICogQGV4YW1wbGUgYGJyb3dzZXJWZXJzaW9uKClgID0+IHsgbmFtZTogJ0ZpcmVmb3gnLCB2ZXJzaW9uOiAnNDInIH1cbiAgICAgKiBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zODA4MDA1MS8yODM0ODk4XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7eyBuYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZyB9fVxuICAgICAqL1xuICAgIHN0YXRpYyBicm93c2VyKCkge1xuICAgICAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgIGxldCB0ZW07XG4gICAgICAgIGxldCBNID0gdWEubWF0Y2goLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKSB8fCBbXTtcblxuICAgICAgICBpZiAoL3RyaWRlbnQvaS50ZXN0KE1bMV0pKSB7XG4gICAgICAgICAgICB0ZW0gPSAvXFxicnZbIDpdKyhcXGQrKS9nLmV4ZWModWEpIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ2llJywgdmVyc2lvbjogKHRlbVsxXSB8fCAnJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChNWzFdID09PSAnQ2hyb21lJykge1xuICAgICAgICAgICAgdGVtID0gdWEubWF0Y2goL1xcYihPUFJ8RWRnZSlcXC8oXFxkKykvKTtcbiAgICAgICAgICAgIGlmICh0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiB0ZW1bMV0ucmVwbGFjZSgnT1BSJywgJ29wZXJhJyksIHZlcnNpb246IHRlbVsyXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgTSA9IE1bMl0/W01bMV0sIE1bMl1dOltuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddO1xuICAgICAgICBpZiAoKHRlbSA9IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFxcZCspL2kpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgTS5zcGxpY2UoMSwgMSwgdGVtWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG5hbWU6IE1bMF0udG9Mb3dlckNhc2UoKSwgdmVyc2lvbjogTVsxXSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBicm93c2VyIGlzIGNvbnRyb2xsZWQgYnkgU2VsZW5pdW0uXG4gICAgICogTm90ZTogVGhpcyBvbmx5IHdvcmtzIHdpdGhpbiB0aGUgZ2Vja29kcml2ZXIuXG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzMyMjU5NDcvY2FuLWEtd2Vic2l0ZS1kZXRlY3Qtd2hlbi15b3UtYXJlLXVzaW5nLXNlbGVuaXVtLXdpdGgtY2hyb21lZHJpdmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlbml1bUJvdCgpIHtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFZhcmlhYmxlXG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLndlYmRyaXZlciA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBudW1iZXIgaXMgbmVnYXRpdmUsIG9yIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBuZWdhdGl2ZSBzaWduIDpcbiAgICAgKiAtIGV2ZXJ5d2hlcmUgaW4gdGhlIHN0cmluZyAoYnkgZGVmYXVsdCksIG9yXG4gICAgICogLSBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9ubHkgaWYgdGhlIGBjaGVja0V2ZXJ5d2hlcmVgIHBhcmFtZXRlciBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbnVtYmVyT3JOdW1lcmljU3RyaW5nIEEgTnVtYmVyLCBvciBhIG51bWJlciByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tFdmVyeXdoZXJlIElmIFRSVUUsIHRoZW4gdGhlIG5lZ2F0aXZlIHNpZ24gaXMgc2VhcmNoIGV2ZXJ5d2hlcmUgaW4gdGhlIG51bWVyaWMgc3RyaW5nICh0aGlzIGlzIG5lZWRlZCBmb3IgaW5zdGFuY2UgaWYgdGhlIHN0cmluZyBpcyAnMTIzNC41Ni0nKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc05lZ2F0aXZlKG51bWJlck9yTnVtZXJpY1N0cmluZywgY2hlY2tFdmVyeXdoZXJlID0gdHJ1ZSkge1xuICAgICAgICBpZiAobnVtYmVyT3JOdW1lcmljU3RyaW5nID09PSAnLScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlck9yTnVtZXJpY1N0cmluZyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBVc2UgdGhlIGBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXJgIGZyb20gdGhlIHNldHRpbmdzIGhlcmVcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKG51bWJlck9yTnVtZXJpY1N0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJPck51bWVyaWNTdHJpbmcgPCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoZWNrRXZlcnl3aGVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMobnVtYmVyT3JOdW1lcmljU3RyaW5nLCAnLScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOZWdhdGl2ZVN0cmljdChudW1iZXJPck51bWVyaWNTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIG5lZ2F0aXZlIHNpZ24gb24gdGhlIGZpcnN0IGNoYXJhY3RlciAob24gdGhlIGZhciBsZWZ0KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJzEyMzQuNTYnKSAgICAgPT4gZmFsc2VcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCcxMjM0LjU2LScpICAgID0+IGZhbHNlXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEyMzQuNTYnKSAgICA9PiB0cnVlXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEsMjM0LjU2IOKCrCcpID0+IHRydWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTmVnYXRpdmVTdHJpY3QobnVtZXJpY1N0cmluZykge1xuICAgICAgICAvL1RPRE8gVXNpbmcgdGhlIGBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXJgIGZyb20gdGhlIHNldHRpbmdzIGhlcmVcbiAgICAgICAgcmV0dXJuIG51bWVyaWNTdHJpbmcuY2hhckF0KDApID09PSAnLSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgdmVyeSBmaXJzdCBjaGFyYWN0ZXIgaXMgdGhlIG9wZW5pbmcgYnJhY2tldCwgYW5kIGlmIHRoZSByZXN0IG9mIHRoZSBgdmFsdWVTdHJpbmdgIGFsc28gaGFzIHRoZSBjbG9zaW5nIGJyYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdEJyYWNrZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRCcmFja2V0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTmVnYXRpdmVXaXRoQnJhY2tldHModmFsdWVTdHJpbmcsIGxlZnRCcmFja2V0LCByaWdodEJyYWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLmNoYXJBdCgwKSA9PT0gbGVmdEJyYWNrZXQgJiYgdGhpcy5jb250YWlucyh2YWx1ZVN0cmluZywgcmlnaHRCcmFja2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBmb3JtYXR0ZWQgb3IgdW5mb3JtYXR0ZWQgbnVtZXJpYyBzdHJpbmcgcmVwcmVzZW50IHRoZSB2YWx1ZSAwIChpZS4gJzAsMDAg4oKsJyksIG9yIGlzIGVtcHR5ICgnIOKCrCcpLlxuICAgICAqIFRoaXMgd29ya3Mgc2luY2Ugd2UgdGVzdCBpZiB0aGVyZSBhcmUgYW55IG51bWJlcnMgZnJvbSAxIHRvIDkgaW4gdGhlIHN0cmluZy4gSWYgdGhlcmUgaXMgbm9uZSwgdGhlbiB0aGUgbnVtYmVyIGlzIHplcm8gKG9yIHRoZSBzdHJpbmcgaXMgZW1wdHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNaZXJvT3JIYXNOb1ZhbHVlKG51bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICEoL1sxLTldL2cpLnRlc3QobnVtZXJpY1N0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpIGdpdmVuIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHNldFJhd05lZ2F0aXZlU2lnbih2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgLSR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHBvc2l0aW9uIGBpbmRleGAgaW4gdGhlIHN0cmluZyBgc3RyaW5nYCBieSB0aGUgY2hhcmFjdGVyKHMpIGBuZXdDaGFyYWN0ZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlQ2hhckF0KHN0cmluZywgaW5kZXgsIG5ld0NoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gYCR7c3RyaW5nLnN1YnN0cigwLCBpbmRleCl9JHtuZXdDaGFyYWN0ZXJ9JHtzdHJpbmcuc3Vic3RyKGluZGV4ICsgbmV3Q2hhcmFjdGVyLmxlbmd0aCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIGNsYW1wZWQgdG8gdGhlIG5lYXJlc3QgbWluaW11bS9tYXhpbXVtIHZhbHVlLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcFRvUmFuZ2VMaW1pdHModmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vWFhYIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGFzc3VtZSBgc2V0dGluZ3MubWluaW11bVZhbHVlYCBpcyBsb3dlciB0aGFuIGBzZXR0aW5ncy5tYXhpbXVtVmFsdWVgXG4gICAgICAgIHJldHVybiBNYXRoLm1heChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIE1hdGgubWluKHNldHRpbmdzLm1heGltdW1WYWx1ZSwgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBudW1iZXIgb3IgZG90IGNoYXJhY3RlcnMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2FyZXQsIGluIGEgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbiBUaGlzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIEhlcmUgd2UgY291bnQgdGhlIGRvdCBhbmQgcmVwb3J0IGl0IGFzIGEgbnVtYmVyIGNoYXJhY3RlciB0b28sIHNpbmNlIGl0IHdpbGwgJ3N0YXknIGluIHRoZSBKYXZhc2NyaXB0IG51bWJlciB3aGVuIHVuZm9ybWF0dGVkXG4gICAgICAgIGNvbnN0IG51bWJlckRvdE9yTmVnYXRpdmVTaWduID0gbmV3IFJlZ0V4cChgWzAtOSR7ZGVjaW1hbENoYXJhY3Rlcn0tXWApOyAvLyBObyBuZWVkIHRvIGVzY2FwZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaGVyZSwgc2luY2UgaXQncyBpbiBgW11gXG5cbiAgICAgICAgbGV0IG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJldFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIGNoYXJhY3RlciBpcyBhIG51bWJlciwgYSBkb3Qgb3IgYW4gaHlwaGVuLiBJZiBpdCBpcywgY291bnQgaXQsIG90aGVyd2lzZSBpZ25vcmUgaXRcbiAgICAgICAgICAgIGlmIChudW1iZXJEb3RPck5lZ2F0aXZlU2lnbi50ZXN0KGZvcm1hdHRlZE51bWJlclN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGsgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdgIGZyb20gbGVmdCB0byByaWdodCwgb25lIGNoYXIgYnkgb25lLCBjb3VudGluZyB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YC5cbiAgICAgKiBJZiB0aGUgY2hhciBpcyBpbiB0aGUgYHJhd051bWJlclN0cmluZ2AgKHN0YXJ0aW5nIGF0IGluZGV4IDApLCB0aGVuIGByYXdOdW1iZXJTdHJpbmdJbmRleCsrYCwgYW5kIGNvbnRpbnVlIHVudGlsXG4gICAgICogdGhlcmUgaXMgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIGByYXdOdW1iZXJTdHJpbmdgKSBvciB0aGF0IGByYXdOdW1iZXJTdHJpbmdJbmRleCA9PT0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVgLlxuICAgICAqIFdoZW4geW91IHN0b3AsIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgIGlzIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHNldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogMTIzNDU2N3w4OS4wMSAgIDogcG9zaXRpb24gNyAocmF3TnVtYmVyU3RyaW5nKVxuICAgICAqIDEyMy40NTYuN3w4OSwwMSA6IHBvc2l0aW9uIDkgKGZvcm1hdHRlZE51bWJlclN0cmluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdOdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyYXdOdW1iZXJTdHJpbmcsIGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlLCBmb3JtYXR0ZWROdW1iZXJTdHJpbmcsIGRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSA9IGZvcm1hdHRlZE51bWJlclN0cmluZy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJhd051bWJlclN0cmluZ1NpemUgPSByYXdOdW1iZXJTdHJpbmcubGVuZ3RoO1xuXG4gICAgICAgIGxldCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleDtcbiAgICAgICAgbGV0IHJhd051bWJlclN0cmluZ0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplICYmXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCByYXdOdW1iZXJTdHJpbmdTaXplICYmXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZTtcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSB8fFxuICAgICAgICAgICAgICAgIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSAnLicgJiYgZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSA9PT0gZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGNvdW50Q2hhckluVGV4dChjaGFyYWN0ZXIsIHRleHQpIHtcbiAgICAgICAgbGV0IGNoYXJDb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFyQ291bnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBwb3NpdGlvbiBpcyBzdGFydGluZyBhdCAnMCcsIG5vdCAxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IGNoYXJhY3RlckNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjaGFyYWN0ZXJDb3VudCwgY2hhcmFjdGVyQ291bnQgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqIE5vdGU6IHRoaXMgYWxzbyB3b3JrcyB3aXRoIGVkZ2UgY2FzZXMgbGlrZSBjb250ZW50ZWRpdGFibGUtZW5hYmxlZCBlbGVtZW50cywgYW5kIGhpZGRlbiBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gICAgc3RhdGljIGdldEVsZW1lbnRTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIGxldCBpc1NlbGVjdGlvblN0YXJ0VW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNTZWxlY3Rpb25TdGFydFVuZGVmaW5lZCA9IHRoaXMuaXNVbmRlZmluZWQoZWxlbWVudC5zZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1NlbGVjdGlvblN0YXJ0VW5kZWZpbmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0aW9uU3RhcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uSW5mbyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gc2VsZWN0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3Rpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBlbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IGVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTWFuYWdlcyB0aGUgY2FzZXMgd2hlcmUgOlxuICAgICAgICAgICAgLy8gLSB0aGUgJ2NvbnRlbnRlZGl0YWJsZScgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIC8vIC0gdGhlIDxpbnB1dD4gZWxlbWVudCBpcyBvZiB0eXBlICdoaWRkZW4nXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IDA7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSAwO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge2ludHxudWxsfSBlbmRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0RWxlbWVudFNlbGVjdGlvbihlbGVtZW50LCBzdGFydCwgZW5kID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZW5kKSkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0lucHV0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGVsZW1lbnQuZmlyc3RDaGlsZCwgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQuZmlyc3RDaGlsZCwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBzdGF0aWMgdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dXYXJuaW5nIElmIEZBTFNFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuaW5nKG1lc3NhZ2UsIHNob3dXYXJuaW5nID0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2hvd1dhcm5pbmcpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgd2hlZWx1cCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtXaGVlbEV2ZW50fSB3aGVlbEV2ZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzV2hlZWxVcEV2ZW50KHdoZWVsRXZlbnQpIHtcbiAgICAgICAgaWYgKCF3aGVlbEV2ZW50LmRlbHRhWSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBUaGUgZXZlbnQgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIG5vdCBhIHdoZWVsIGV2ZW50LCAke3doZWVsRXZlbnQudHlwZX0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2hlZWxFdmVudC5kZWx0YVkgPCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgd2hlZWxkb3duIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1doZWVsRXZlbnR9IHdoZWVsRXZlbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNXaGVlbERvd25FdmVudCh3aGVlbEV2ZW50KSB7XG4gICAgICAgIGlmICghd2hlZWxFdmVudC5kZWx0YVkpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihgVGhlIGV2ZW50IHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBub3QgYSB3aGVlbCBldmVudCwgJHt3aGVlbEV2ZW50LnR5cGV9IGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdoZWVsRXZlbnQuZGVsdGFZID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlICduZWFyZXN0IHJvdW5kZWQnIHZhbHVlLCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHN0ZXAgc2l6ZS5cbiAgICAgKiBAZXhhbXBsZSByb3VuZFRvTmVhcmVzdCgyNjQ3ODksIDEwMDAwKSkgPT4gMjYwMDAwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcFBsYWNlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHJvdW5kVG9OZWFyZXN0KHZhbHVlLCBzdGVwUGxhY2UgPSAxMDAwKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8PSAxMCAmJiB2YWx1ZSA+PSAtMTApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgwID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHN0ZXBQbGFjZSkgKiBzdGVwUGxhY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSAnbmVhcmVzdCByb3VuZGVkJyB2YWx1ZSBhdXRvbWF0aWNhbGx5IGJ5IGFkZGluZyBvciBzdWJ0cmFjdGluZyB0aGUgY2FsY3VsYXRlZCBvZmZzZXQgdG8gdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogVGhpcyBpcyBkb25lIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgYSBzdGVwIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGUgICAgICAgICAgICAgICAgICAgIENhbGN1bGF0ZWQgb2Zmc2V0XG4gICAgICogICAgICAgICAgIDEgLT4gICAgICAgICAgIDEgKDEwKVxuICAgICAqICAgICAgICAgIDE0IC0+ICAgICAgICAgIDEwICgxMClcbiAgICAgKiAgICAgICAgIDE0MyAtPiAgICAgICAgIDE0MCAoMTApXG4gICAgICogICAgICAgMS4yNzggLT4gICAgICAgMS4zMDAgKDEwMClcbiAgICAgKiAgICAgIDI4LjQ1NiAtPiAgICAgIDI4LjUwMCAoMTAwKVxuICAgICAqICAgICAyNzYuMzQ1IC0+ICAgICAyNzYuMDAwICgxMDAwKVxuICAgICAqICAgNC41MzQuMDYxIC0+ICAgNC41MzAuMDAwICgxMDAwMClcbiAgICAgKiAgNjYuNzIzLjg0NCAtPiAgNjYuNzAwLjAwMCAoMTAwMDAwKVxuICAgICAqIDI1Ny44MzMuNDExIC0+IDI1OC4wMDAuMDAwICgxMDAwMDAwKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0FkZGl0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIG1vZGlmeUFuZFJvdW5kVG9OZWFyZXN0QXV0byh2YWx1ZSwgaXNBZGRpdGlvbikge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aFZhbHVlID0gTWF0aC5hYnModmFsdWUpLnRvU3RyaW5nKCkubGVuZ3RoOyAvLyBNYXRoLmFicyBpcyBuZWVkZWQgaGVyZSB0byBvbWl0IHRoZSBuZWdhdGl2ZSBzaWduICctJyBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgdmFsdWVcblxuICAgICAgICBsZXQgcG93O1xuICAgICAgICBzd2l0Y2ggKGxlbmd0aFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2VzIGZvciBzbWFsbCBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcG93ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBwb3cgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwb3cgPSBsZW5ndGhWYWx1ZSAtIDM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5wb3coMTAsIHBvdyk7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGlzQWRkaXRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlICsgb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgLSBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZFRvTmVhcmVzdChyZXN1bHQsIE1hdGgucG93KDEwLCBwb3cpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlICduZWFyZXN0IHJvdW5kZWQnIHZhbHVlIGF1dG9tYXRpY2FsbHkgYnkgYWRkaW5nIHRoZSBjYWxjdWxhdGVkIG9mZnNldCB0byB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRBbmRSb3VuZFRvTmVhcmVzdEF1dG8odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5QW5kUm91bmRUb05lYXJlc3RBdXRvKHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlICduZWFyZXN0IHJvdW5kZWQnIHZhbHVlIGF1dG9tYXRpY2FsbHkgYnkgc3VidHJhY3RpbmcgdGhlIGNhbGN1bGF0ZWQgb2Zmc2V0IHRvIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHN1YnRyYWN0QW5kUm91bmRUb05lYXJlc3RBdXRvKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmeUFuZFJvdW5kVG9OZWFyZXN0QXV0byh2YWx1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2UgYW4gYXJhYmljIG51bWJlciBhcyBhIHN0cmluZyBhbmQgcmV0dXJuIGEgamF2YXNjcmlwdCBudW1iZXIuXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0cnkgdG8gY29udmVydCB0aGUgYXJhYmljIGRlY2ltYWwgYW5kIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzLlxuICAgICAqIFRoaXMgcmV0dXJucyBgTmFOYCBpcyB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICAgICogQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTcwMjUzOTIvMjgzNDg5OFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyYWJpY051bWJlcnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkFOdW1iZXIgSWYgYHRydWVgLCByZXR1cm4gYSBOdW1iZXIsIG90aGVyd2lzZSByZXR1cm4gYSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlRGVjaW1hbENoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2VUaG91c2FuZFNlcGFyYXRvclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfE5hTn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJhYmljVG9MYXRpbk51bWJlcnMoYXJhYmljTnVtYmVycywgcmV0dXJuQU51bWJlciA9IHRydWUsIHBhcnNlRGVjaW1hbENoYXJhY3RlciA9IGZhbHNlLCBwYXJzZVRob3VzYW5kU2VwYXJhdG9yID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsKGFyYWJpY051bWJlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJhYmljTnVtYmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQgPSBhcmFiaWNOdW1iZXJzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJhYmljTnVtYmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubWF0Y2goL1vZoNmh2aLZo9mk2aXZptmn2ajZqdu027Xbtl0vZykgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIEFyYWJpYy9QZXJzaWFuIG51bWJlcnMgYXJlIGZvdW5kLCByZXR1cm4gdGhlIG51bWVyaWMgc3RyaW5nIG9yIG51bWJlciBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKHJldHVybkFOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOdW1iZXIocmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZURlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/Zqy8sICcuJyk7IC8vIERlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VUaG91c2FuZFNlcGFyYXRvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9msL2csICcnKTsgLy8gVGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBudW1iZXJzIG9ubHlcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1vZoNmh2aLZo9mk2aXZptmn2ajZqV0vZywgZCA9PiBkLmNoYXJDb2RlQXQoMCkgLSAxNjMyKSAvLyBBcmFiaWMgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW9uw27Hbstuz27Tbtdu227fbuNu5XS9nLCBkID0+IGQuY2hhckNvZGVBdCgwKSAtIDE3NzYpOyAvLyBQZXJzaWFuIG51bWJlcnNcblxuICAgICAgICAvLyBgTmFOYCBoYXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBzdHJpbmcgYCdOYU4nYFxuICAgICAgICBjb25zdCByZXN1bHRBc051bWJlciA9IE51bWJlcihyZXN1bHQpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0QXNOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0QXNOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuQU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0QXNOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTERvY3VtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gcGFyc2UgbWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUgJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlLlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogbWluaW11bVZhbHVlOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuIEEgbnVtZXJpYyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlU3RyKG4pIHtcbiAgICAgICAgY29uc3QgeCA9IHt9OyAvLyBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IG5MO1xuICAgICAgICBsZXQgajtcblxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xuICAgICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgICAgIG4gPSAnLTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uIDEgcG9zaXRpdmUsIC0xIG5lZ2F0aXZlXG4gICAgICAgIG4gPSBuLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmVTdHJpY3QobikpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5ncy5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIHBhcnNlZCBzdHJpbmdzIGZvciB0aGUgYWJvdmUgcGFyc2VTdHIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzLy4gTWFueSB0aGFua3MgdG8gTWlrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5IEJpZyBudW1iZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geCBCaWcgbnVtYmVyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgcmFuZG9tIHN0cmluZy5cbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OC8yODM0ODk4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RyTGVuZ3RoIExlbmd0aCBvZiB0aGUgZ2VuZXJhdGVkIHN0cmluZyAoaW4gY2hhcmFjdGVyIGNvdW50KVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHJhbmRvbVN0cmluZyhzdHJMZW5ndGggPSA1KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAgICAgICAuc3Vic3RyKDIsIHN0ckxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZWxlbWVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudHxFdmVudFRhcmdldH0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgc3RhdGljIGdldEVsZW1lbnRWYWx1ZShlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgZWxlbWVudCB2YWx1ZSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRFbGVtZW50VmFsdWUoZWxlbWVudCwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjbG9uZSB0aGUgZ2l2ZW4gb2JqZWN0LCBhbmQgcmV0dXJuIGl0LlxuICAgICAqIFdBUk5JTkc6IFRoaXMgZG9lcyBub3QgZG8gYSBkZWVwIGNsb25pbmcuXG4gICAgICogY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24jRXhhbXBsZXNcbiAgICAgKiAvL1RPRE8gQWRkIGEgYGRlZXBgIG9wdGlvbiB0byBjbG9uZSBvYmplY3Qgd2l0aCBtb3JlIHRoYW4gb25lIGRlcHRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvbmVPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhICdjYW1lbGl6ZWQnIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGFzc3VtZSB0aGF0IDpcbiAgICAgKiAtIHRoZSBzZXBhcmF0b3JzIGFyZSBoeXBoZW5zICctJyxcbiAgICAgKiAtIHRoZSAnZGF0YS0nIHN0cmluZyBzaG91bGQgYmUgcmVtb3ZlZCwgYW5kXG4gICAgICogLSB0aGF0IHRoZSB2ZXJ5IGZpcnN0IHdvcmQgc2hvdWxkIG5vdCBiZSBjYXBpdGFsaXplZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGNhbWVsaXplKCdkYXRhLWN1cnJlbmN5LXN5bWJvbCcpID0+ICdjdXJyZW5jeVN5bWJvbCdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGV4dCB0byBjYW1lbGl6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXBhcmF0b3IgQ2hhcmFjdGVyIHRoYXQgc2VwYXJhdGUgZWFjaCB3b3JkXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZW1vdmVEYXRhIElmIHNldCB0byBgdHJ1ZWAsIHJlbW92ZSB0aGUgYGRhdGEtYCBwYXJ0IHRoYXQgeW91IGNhbiBmaW5kIG9uIHNvbWUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwRmlyc3RXb3JkIElmIHNldCB0byBgdHJ1ZWAsIGRvIG5vdCBjYXBpdGFsaXplIHRoZSB2ZXJ5IGZpcnN0IHdvcmRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgc3RhdGljIGNhbWVsaXplKHN0ciwgc2VwYXJhdG9yID0gJy0nLCByZW1vdmVEYXRhID0gdHJ1ZSwgc2tpcEZpcnN0V29yZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsKHN0cikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZURhdGEpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eZGF0YS0vLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXQgdGhlIHN0cmluZyBpbnRvIHdvcmRzXG4gICAgICAgIGNvbnN0IHdvcmRzID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgICAgLy8gQ2FwaXRhbGl6ZSBlYWNoIHdvcmRcbiAgICAgICAgbGV0IHJlc3VsdCA9IHdvcmRzLm1hcCh3b3JkID0+IGAke3dvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt3b3JkLnNsaWNlKDEpfWApO1xuXG4gICAgICAgIC8vIFRoZW4gY29uY2F0ZW5hdGUgdGhlbSBiYWNrXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5qb2luKCcnKTtcblxuICAgICAgICBpZiAoc2tpcEZpcnN0V29yZCkge1xuICAgICAgICAgICAgLy8gU2tpcCB0aGUgdmVyeSBmaXJzdCBsZXR0ZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKX0ke3Jlc3VsdC5zbGljZSgxKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRleHQgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHRleHQoZG9tRWxlbWVudCkge1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGRvbUVsZW1lbnQubm9kZVR5cGU7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlXG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRvbUVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkb21FbGVtZW50Lm5vZGVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VGV4dChkb21FbGVtZW50LCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZG9tRWxlbWVudC5ub2RlVHlwZTtcbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPIERpc3BsYXkgYSB3YXJuaW5nIGlmIHRoYXQgZnVuY3Rpb24gZG9lcyBub3QgZG8gYW55dGhpbmc/XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG91dCB0aGUgZ2l2ZW4gYGFycmAgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgZm91bmQgaW4gYGV4Y2x1ZGVkRWxlbWVudHNgLlxuICAgICAqIFRoaXMgcmV0dXJucyBhIG5ldyBhcnJheSBhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBzb3VyY2UuXG4gICAgICogY2YuIHZlcmlmaWNhdGlvbiBoZXJlIDogaHR0cDovL2NvZGVwZW4uaW8vQW5vdGhlckxpbnV4VXNlci9wZW4vWHB2ck1nP2VkaXRvcnM9MDAxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZWRFbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LjxUPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZmlsdGVyT3V0KGFyciwgZXhjbHVkZWRFbGVtZW50cykge1xuICAgICAgICByZXR1cm4gYXJyLmZpbHRlcihlbGVtZW50ID0+ICF0aGlzLmlzSW5BcnJheShlbGVtZW50LCBleGNsdWRlZEVsZW1lbnRzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMobnVtZXJpY1N0cmluZykge1xuICAgICAgICBudW1lcmljU3RyaW5nID0gU3RyaW5nKG51bWVyaWNTdHJpbmcpO1xuICAgICAgICBpZiAobnVtZXJpY1N0cmluZyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gbnVtZXJpY1N0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmltbWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5yZXBsYWNlKC8wKyQvZywgJycpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh0cmltbWVkRGVjaW1hbFBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke2ludGVnZXJQYXJ0fS4ke3RyaW1tZWREZWNpbWFsUGFydH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRvcC1tb3N0IGhvdmVyZWQgaXRlbSBieSB0aGUgbW91c2UgY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIGdldEhvdmVyZWRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBob3ZlcmVkRWxlbWVudHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOmhvdmVyJyldO1xuICAgICAgICByZXR1cm4gaG92ZXJlZEVsZW1lbnRzW2hvdmVyZWRFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdpdmVuIGFycmF5IHRyaW1tZWQgdG8gdGhlIGdpdmVuIGxlbmd0aC5cbiAgICAgKiBAZXhhbXBsZSBhcnJheVRyaW0oWzEsIDIsIDMsIDRdLCAyKSAtPiBbMSwgMl1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheVRyaW0oYXJyYXksIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJMZW5ndGggPT09IDAgfHwgbGVuZ3RoID4gYXJyTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBbHNvIG1hbmFnZSB0aGUgY2FzZSB3aGVyZSBgbGVuZ3RoYCBpcyBoaWdoZXIgdGhhbiB0aGUgY3VycmVudCBsZW5ndGhcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheS5sZW5ndGggPSBwYXJzZUludChsZW5ndGgsIDEwKTtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIHRoZSBnaXZlbiBhcnJheXMgYnkga2VlcGluZyBvbmx5IHVuaXF1ZSBlbGVtZW50cywgYW5kIHJldHVybiBhbiBhcnJheSB3aXRoIGRlLWR1cGxpY2F0ZWQgdmFsdWVzLlxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzY2NDk3MS8yODM0ODk4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLmFycmF5fSBhcnJheXNcbiAgICAgKiBAcmV0dXJucyB7WypdfVxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheVVuaXF1ZSguLi5hcnJheXMpIHsgLy9GSVhNRSDDoCB0ZXN0ZXJcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KFtdLmNvbmNhdCguLi5hcnJheXMpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIHRoZSBnaXZlbiBNYXBzIGJ5IGtlZXBpbmcgb25seSB1bmlxdWUgZWxlbWVudHMsIGFuZCByZXR1cm4gYSBuZXcgTWFwIHdpdGggZGUtZHVwbGljYXRlZCBrZXlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5NYXB9IG1hcE9iamVjdHNcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZU1hcHMoLi4ubWFwT2JqZWN0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChtYXBPYmplY3RzLnJlZHVjZSgoYXMsIGIpID0+IGFzLmNvbmNhdChbLi4uYl0pLCBbXSkpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BdXRvTnVtZXJpY0hlbHBlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Options values enumeration\n */\n_AutoNumeric2.default.options = {\n    /* Allow padding the decimal places with zeros\n     * `true`   : always pad decimals with zeros\n     * `false`  : never pad with zeros\n     * `'floats'` : pad with zeros only when there are decimals\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     */\n    allowDecimalPadding: {\n        always: true,\n        never: false,\n        floats: 'floats'\n    },\n\n    /* Defines where should be positioned the caret on focus\n     * null : Do not enforce any caret positioning on focus (this is needed when using `selectOnFocus`)\n     * `'start'` : put the caret of the far left side of the value (excluding the positive/negative sign and currency symbol, if any)\n     * `'end'` : put the caret of the far right side of the value (excluding the positive/negative sign and currency symbol, if any)\n     * `'decimalLeft'` : put the caret of the left of the decimal character if any\n     * `'decimalRight'` : put the caret of the right of the decimal character if any\n     */\n    caretPositionOnFocus: {\n        start: 'start',\n        end: 'end',\n        decimalLeft: 'decimalLeft',\n        decimalRight: 'decimalRight',\n        doNoForceCaretPosition: null\n    },\n\n    /* Defines if a local list of AutoNumeric objects should be kept when initializing this object.\n     * This list is used by the `global.*` functions.\n     */\n    createLocalList: {\n        createList: true,\n        doNotCreateList: false\n    },\n\n    /* Defines the currency symbol string.\n     * It can be a string of more than one character (allowing for instance to use a space on either side of it, example: '$ ' or ' $')\n     * cf. https://en.wikipedia.org/wiki/Currency_symbol\n     */\n    currencySymbol: {\n        none: '',\n        currencySign: '¤',\n        austral: '₳', // ARA\n        australCentavo: '¢',\n        baht: '฿', // THB\n        cedi: '₵', // GHS\n        cent: '¢',\n        colon: '₡', // CRC\n        cruzeiro: '₢', // BRB - Not used anymore since 1993\n        dollar: '$',\n        dong: '₫', // VND\n        drachma: '₯', // GRD (or 'Δρχ.' or 'Δρ.')\n        dram: '​֏', // AMD\n        european: '₠', // XEU (old currency before the Euro)\n        euro: '€', // EUR\n        florin: 'ƒ',\n        franc: '₣', // FRF\n        guarani: '₲', // PYG\n        hryvnia: '₴', // грн\n        kip: '₭', // LAK\n        att: 'ອັດ', // cents of the Kip\n        lepton: 'Λ.', // cents of the Drachma\n        lira: '₺', // TRY\n        liraOld: '₤',\n        lari: '₾', // GEL\n        mark: 'ℳ',\n        mill: '₥',\n        naira: '₦', // NGN\n        peseta: '₧',\n        peso: '₱', // PHP\n        pfennig: '₰', // cents of the Mark\n        pound: '£',\n        real: 'R$', // Brazilian real\n        riel: '៛', // KHR\n        ruble: '₽', // RUB\n        rupee: '₹', // INR\n        rupeeOld: '₨',\n        shekel: '₪',\n        shekelAlt: 'ש״ח‎‎',\n        taka: '৳', // BDT\n        tenge: '₸', // KZT\n        togrog: '₮', // MNT\n        won: '₩',\n        yen: '¥'\n    },\n\n    /* Defines where the currency symbol should be placed (before of after the numbers)\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     */\n    currencySymbolPlacement: {\n        prefix: 'p',\n        suffix: 's'\n    },\n\n    /* Defines what decimal separator character is used\n     */\n    decimalCharacter: {\n        comma: ',',\n        dot: '.',\n        middleDot: '·',\n        arabicDecimalSeparator: '٫',\n        decimalSeparatorKeySymbol: '⎖'\n    },\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\n     * a period 'full stop' as the decimal character (France or Spain for instance).\n     */\n    decimalCharacterAlternative: {\n        none: null,\n        comma: ',',\n        dot: '.'\n    },\n\n    /* Defines the maximum number of decimal places to show and keep as the precision.\n     * This is used to override the decimal places number set by the minimumValue & maximumValue values.\n     */\n    decimalPlacesOverride: {\n        doNotOverride: null\n    },\n\n    /* Defines how many decimal places should be visible when the element has the focus\n     * Example:\n     * Fon instance if `decimalPlacesShownOnFocus` is set to `5` and the default number of decimal places is `2`, then on focus `1,000.12345` will be shown, while without focus `1,000.12` will be set back.\n     * Note 1: the results depends on the rounding method used.\n     * Note 2: the `getNumericString()` method returns the extended decimal places\n     */\n    decimalPlacesShownOnFocus: {\n        useDefault: null\n    },\n\n    /* Helper option for ASP.NET postback\n     * This should be set as the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     */\n    defaultValueOverride: {\n        doNotOverride: null\n    },\n\n    /* Defines how many numbers should be grouped together (usually for the thousand separator)\n     * - \"2\",  results in 99,99,99,999 India's lakhs\n     * - \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * - \"3\",  results in 999,999,999 (default)\n     * - \"4\",  results in 9999,9999,9999 used in some Asian countries\n     */\n    digitalGroupSpacing: {\n        two: '2',\n        twoScaled: '2s',\n        three: '3',\n        four: '4'\n    },\n\n    /* Defines the thousand grouping separator character\n     * Example : If `'.'` is set, then you'll get `'1.234.567'`\n     */\n    digitGroupSeparator: {\n        comma: ',',\n        dot: '.',\n        normalSpace: ' ',\n        thinSpace: '\\u2009',\n        narrowNoBreakSpace: '\\u202F',\n        noBreakSpace: '\\xA0',\n        noSeparator: '',\n        apostrophe: '\\'',\n        arabicThousandsSeparator: '٬',\n        dotAbove: '˙'\n    },\n\n    /* Defines what should be displayed in the element if the raw value is an empty string ('').\n     * - 'focus'  : The currency sign is displayed when the input receives focus (default)\n     * - 'press'  : The currency sign is displayed whenever a key is being pressed\n     * - 'always' : The currency sign is always displayed\n     * - 'zero'   : A zero is displayed ('rounded' with or without a currency sign) if the input has no value on focus out\n     */\n    emptyInputBehavior: {\n        focus: 'focus',\n        press: 'press',\n        always: 'always',\n        zero: 'zero'\n    },\n\n    /* This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to `true` if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets polluted by another program (which usually happens when using frameworks).\n     */\n    failOnUnknownOption: {\n        fail: true,\n        ignore: false\n    },\n\n    /* Determine if the default value will be formatted on initialization.\n     */\n    formatOnPageLoad: {\n        format: true, // automatically formats the default value on initialization\n        doNotFormat: false },\n\n    /* Set the undo/redo history table size.\n     * Each record keeps the raw value as well and the last known caret/selection positions.\n     */\n    historySize: {\n        verySmall: 5,\n        small: 10,\n        medium: 20,\n        large: 50,\n        veryLarge: 100,\n        insane: Number.MAX_SAFE_INTEGER\n    },\n\n    /* Allow the user to 'cancel' and undo the changes he made to the given autonumeric-managed element, by pressing the 'Escape' key.\n     * Whenever the user 'validate' the input (either by hitting 'Enter', or blurring the element), the new value is saved for subsequent 'cancellation'.\n     *\n     * The process :\n     *   - save the input value on focus\n     *   - if the user change the input value, and hit `Escape`, then the initial value saved on focus is set back\n     *   - on the other hand if the user either have used `Enter` to validate (`Enter` throws a change event) his entries, or if the input value has been changed by another script in the mean time, then we save the new input value\n     *   - on a successful 'cancel', select the whole value (while respecting the `selectNumberOnly` option)\n     *   - bonus; if the value has not changed, hitting 'Esc' just select all the input value (while respecting the `selectNumberOnly` option)\n     */\n    isCancellable: {\n        cancellable: true,\n        notCancellable: false\n    },\n\n    /* Controls the leading zero behavior\n     * - 'allow' : allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted\n     * - 'deny'  : allows only one leading zero on values that are between 1 and -1\n     * - 'keep'  : allows leading zeros to be entered. on focusout zeros will be retained\n     */\n    leadingZero: {\n        allow: 'allow',\n        deny: 'deny',\n        keep: 'keep'\n    },\n\n    /* Defines the maximum possible value a user can enter.\n     * Notes:\n     * - this value must a string and use the period for the decimal point\n     * - this value needs to be larger than `minimumValue`\n     */\n    maximumValue: {\n        tenTrillions: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n        tenTrillionsNoDecimals: '9999999999999',\n        oneBillion: '999999999.99',\n        zero: '0'\n    },\n\n    /* Defines the minimum possible value a user can enter.\n     * Notes:\n     * - this value must a string and use the period for the decimal point\n     * - this value needs to be smaller than `maximumValue`\n     * - if this is superior to 0, then you'll effectively prevent your user to entirely delete the content of your element\n     */\n    minimumValue: {\n        tenTrillions: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n        tenTrillionsNoDecimals: '-9999999999999',\n        oneBillion: '-999999999.99',\n        zero: '0'\n    },\n\n    /* Allow the user to increment or decrement the element value with the mouse wheel.\n     * The wheel behavior can by modified by the `wheelStep` option.\n     * This `wheelStep` options can be used in two ways, either by setting :\n     * - a 'fixed' step value (`wheelStep : 1000`), or\n     * - the 'progressive' string (`wheelStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.\n     *\n     * Note :\n     * A special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\n     * You can use the 'Shift' modifier key while using the mouse wheel in order to temporarily disable the increment/decrement feature (useful on small screen where some badly configured inputs could use all the available space).\n     */\n    modifyValueOnWheel: {\n        modifyValue: true,\n        doNothing: false\n    },\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma.\n     */\n    negativeBracketsTypeOnBlur: {\n        parentheses: '(,)',\n        brackets: '[,]',\n        chevrons: '<,>',\n        curlyBraces: '{,}',\n        angleBrackets: '〈,〉',\n        japaneseQuotationMarks: '｢,｣',\n        halfBrackets: '⸤,⸥',\n        whiteSquareBrackets: '⟦,⟧',\n        quotationMarks: '‹,›',\n        guillemets: '«,»',\n        none: null },\n\n    /* Placement of the negative/positive sign relative to the `currencySymbol` option.\n     *\n     * Example:\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     */\n    negativePositiveSignPlacement: {\n        prefix: 'p',\n        suffix: 's',\n        left: 'l',\n        right: 'r',\n        none: null\n    },\n\n    /* Defines if the element should have event listeners activated on it.\n     * By default, those event listeners are only added to <input> elements and html element with the `contenteditable` attribute set to `true`, but not on the other html tags.\n     * This allows to initialize elements without any event listeners.\n     * Warning: Since AutoNumeric will not check the input content after its initialization, using some autoNumeric methods will probably leads to formatting problems.\n     */\n    noEventListeners: {\n        noEvents: true,\n        addEvents: false\n    },\n\n    /* Defines if the element value should be converted to the raw value on focus (and back to the formatted on blur).\n     * If set to `true`, then autoNumeric remove the thousand separator, currency symbol and suffix on focus.\n     * Example:\n     * If the input value is '$ 1,999.88 suffix', on focus it becomes '1999.88' and back to '$ 1,999.88 suffix' on focus out.\n     */\n    //TODO Rename this option to `rawValueOnFocus`\n    noSeparatorOnFocus: {\n        noSeparator: true,\n        withSeparator: false\n    },\n\n    /* Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    onInvalidPaste: {\n        error: 'error',\n        ignore: 'ignore',\n        clamp: 'clamp',\n        truncate: 'truncate',\n        replace: 'replace'\n    },\n\n    /* Defines how the value should be formatted when wanting a 'localized' version of it.\n     * - null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * - 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * - ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * - '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * - ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     */\n    outputFormat: {\n        string: 'string',\n        number: 'number',\n        dot: '.',\n        negativeDot: '-.',\n        comma: ',',\n        negativeComma: '-,',\n        dotNegative: '.-',\n        commaNegative: ',-',\n        none: null\n    },\n\n    /* Override the minimum and maximum limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     */\n    overrideMinMaxLimits: {\n        ceiling: 'ceiling',\n        floor: 'floor',\n        ignore: 'ignore',\n        doNotOverride: null\n    },\n\n    /* Defines if the <input> element should be set as read only on initialization.\n     * When set to `true`, then the `readonly` html property is added to the <input> element on initialization.\n     */\n    readOnly: {\n        readOnly: true,\n        readWrite: false\n    },\n\n    /* Defines the rounding method to use.\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     */\n    roundingMethod: {\n        halfUpSymmetric: 'S',\n        halfUpAsymmetric: 'A',\n        halfDownSymmetric: 's',\n        halfDownAsymmetric: 'a',\n        halfEvenBankersRounding: 'B',\n        upRoundAwayFromZero: 'U',\n        downRoundTowardZero: 'D',\n        toCeilingTowardPositiveInfinity: 'C',\n        toFloorTowardNegativeInfinity: 'F',\n        toNearest05: 'N05',\n        toNearest05Alt: 'CHF',\n        upToNext05: 'U05',\n        downToNext05: 'D05'\n    },\n\n    /* Set to `true` to allow the `decimalPlacesShownOnFocus` value to be saved with sessionStorage\n     * If IE 6 or 7 is detected, the value will be saved as a session cookie.\n     */\n    saveValueToSessionStorage: {\n        save: true,\n        doNotSave: false\n    },\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     */\n    scaleDecimalPlaces: {\n        doNotChangeDecimalPlaces: null\n    },\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: {\n        doNotActivateTheScalingOption: null,\n        percentage: 100,\n        permille: 1000,\n        basisPoint: 10000\n    },\n\n    /* The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: {\n        none: null,\n        percentage: '%',\n        permille: '‰',\n        basisPoint: '‱'\n    },\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will be selected\n     */\n    selectNumberOnly: {\n        selectNumbersOnly: true,\n        selectAll: false\n    },\n\n    /* Defines if the element value should be selected on focus.\n     * Note: The selection is done using the `selectNumberOnly` option.\n     */\n    selectOnFocus: {\n        select: true,\n        doNotSelect: false\n    },\n\n    /* Defines how the serialize functions should treat the spaces.\n     * Those spaces ' ' can either be converted to the plus sign '+', which is the default, or to '%20'.\n     * Both values being valid per the spec (http://www.w3.org/Addressing/URL/uri-spec.html).\n     * Also see the summed up answer on http://stackoverflow.com/a/33939287.\n     *\n     * tl;dr : Spaces should be converted to '%20' before the '?' sign, then converted to '+' after.\n     * In our case since we serialize the query, we use '+' as the default (but allow the user to get back the old *wrong* behavior).\n     */\n    serializeSpaces: {\n        plus: '+',\n        percent: '%20'\n    },\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\n     * By default, this positive sign is not shown.\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\n     */\n    showPositiveSign: {\n        show: true,\n        hide: false\n    },\n\n    /* Defines if warnings should be shown in the console\n     * Those warnings can be ignored, but are usually printed when something could be improved by the user (ie. option conflicts).\n     */\n    showWarnings: {\n        show: true, // All warning are shown\n        hide: false },\n\n    /* Defines the rules that calculate the CSS class(es) to apply on the element, based on the raw unformatted value.\n     * This can also be used to call callbacks whenever the `rawValue` is updated.\n     * Important: all callbacks must return `null` if no ranges/userDefined classes are selected\n     * @example\n     * {\n     *     positive   : 'autoNumeric-positive', // Or `null` to not use it\n     *     negative   : 'autoNumeric-negative',\n     *     ranges     : [\n     *         { min: 0, max: 25, class: 'autoNumeric-red' },\n     *         { min: 25, max: 50, class: 'autoNumeric-orange' },\n     *         { min: 50, max: 75, class: 'autoNumeric-yellow' },\n     *         { min: 75, max: Number.MAX_SAFE_INTEGER, class: 'autoNumeric-green' },\n     *     ],\n     *     userDefined: [\n     *         // If 'classes' is a string, set it if `true`, remove it if `false`\n     *         { callback: rawValue => { return true; }, classes: 'thisIsTrue' },\n     *         // If 'classes' is an array with only 2 elements, set the first class if `true`, the second if `false`\n     *         { callback: rawValue => rawValue % 2 === 0, classes: ['autoNumeric-even', 'autoNumeric-odd'] },\n     *         // Return only one index to use on the `classes` array (here, 'class3')\n     *         { callback: rawValue => { return 2; }, classes: ['class1', 'class2', 'class3'] },\n     *         // Return an array of indexes to use on the `classes` array (here, 'class1' and 'class3')\n     *         { callback: rawValue => { return [0, 2]; }, classes: ['class1', 'class2', 'class3'] },\n     *         // If 'classes' is `undefined` or `null`, then the callback is called with the AutoNumeric object passed as a parameter\n     *         { callback: anElement => { return anElement.getFormatted(); } },\n     *     ],\n     * }\n     */\n    styleRules: {\n        none: null,\n        positiveNegative: {\n            positive: 'autoNumeric-positive',\n            negative: 'autoNumeric-negative'\n        },\n        range0To100With4Steps: {\n            ranges: [{ min: 0, max: 25, class: 'autoNumeric-red' }, { min: 25, max: 50, class: 'autoNumeric-orange' }, { min: 50, max: 75, class: 'autoNumeric-yellow' }, { min: 75, max: 100, class: 'autoNumeric-green' }]\n        },\n        evenOdd: {\n            userDefined: [{ callback: function callback(rawValue) {\n                    return rawValue % 2 === 0;\n                }, classes: ['autoNumeric-even', 'autoNumeric-odd'] }]\n        },\n        rangeSmallAndZero: {\n            userDefined: [{\n                callback: function callback(rawValue) {\n                    if (rawValue >= -1 && rawValue < 0) {\n                        return 0;\n                    }\n                    if (Number(rawValue) === 0) {\n                        return 1;\n                    }\n                    if (rawValue > 0 && rawValue <= 1) {\n                        return 2;\n                    }\n\n                    return null; // In case the rawValue is outside those ranges\n                }, classes: ['autoNumeric-small-negative', 'autoNumeric-zero', 'autoNumeric-small-positive']\n            }]\n        }\n    },\n\n    /* Add a text on the right hand side of the element value.\n     * This suffix text can have any characters in its string, except numeric characters and the negative/positive sign.\n     * Example: ' dollars'\n     */\n    suffixText: {\n        none: '',\n        percentage: '%',\n        permille: '‰',\n        basisPoint: '‱'\n    },\n\n    /* Defines if the element value should be unformatted when the user hover his mouse over it while holding the `Alt` key.\n     * We reformat back before anything else if :\n     * - the user focus on the element by tabbing or clicking into it,\n     * - the user releases the `Alt` key, and\n     * - if we detect a mouseleave event.\n     *\n     * We unformat again if :\n     * - while the mouse is over the element, the user hit ctrl again\n     */\n    unformatOnHover: {\n        unformat: true,\n        doNotUnformat: false\n    },\n\n    /* Removes the formatting and use the raw value in each autoNumeric elements of the parent form element, on the form `submit` event.\n     * The output format is a numeric string (nnnn.nn or -nnnn.nn).\n     */\n    unformatOnSubmit: {\n        unformat: true,\n        keepCurrentValue: false\n    },\n\n    /* That option is linked to the `modifyValueOnWheel` one and will only be used if the latter is set to `true`.\n     * This option will modify the wheel behavior and can be used in two ways, either by setting :\n     * - a 'fixed' step value (a positive float or integer number `1000`), or\n     * - the `'progressive'` string.\n     *\n     * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.\n     * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.\n     */\n    wheelStep: {\n        progressive: 'progressive'\n    }\n}; /**\n    * Options for autoNumeric.js\n    * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n    * @copyright © 2016 Alexandre Bonneau\n    *\n    * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n    *\n    * Permission is hereby granted, free of charge, to any person\n    * obtaining a copy of this software and associated documentation\n    * files (the \"Software\"), to deal in the Software without\n    * restriction, including without limitation the rights to use,\n    * copy, modify, merge, publish, distribute, sub license, and/or sell\n    * copies of the Software, and to permit persons to whom the\n    * Software is furnished to do so, subject to the following\n    * conditions:\n    *\n    * The above copyright notice and this permission notice shall be\n    * included in all copies or substantial portions of the Software.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    * OTHER DEALINGS IN THE SOFTWARE.\n    */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNPcHRpb25zLmpzP2NlNWQiXSwibmFtZXMiOlsib3B0aW9ucyIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJhbHdheXMiLCJuZXZlciIsImZsb2F0cyIsImNhcmV0UG9zaXRpb25PbkZvY3VzIiwic3RhcnQiLCJlbmQiLCJkZWNpbWFsTGVmdCIsImRlY2ltYWxSaWdodCIsImRvTm9Gb3JjZUNhcmV0UG9zaXRpb24iLCJjcmVhdGVMb2NhbExpc3QiLCJjcmVhdGVMaXN0IiwiZG9Ob3RDcmVhdGVMaXN0IiwiY3VycmVuY3lTeW1ib2wiLCJub25lIiwiY3VycmVuY3lTaWduIiwiYXVzdHJhbCIsImF1c3RyYWxDZW50YXZvIiwiYmFodCIsImNlZGkiLCJjZW50IiwiY29sb24iLCJjcnV6ZWlybyIsImRvbGxhciIsImRvbmciLCJkcmFjaG1hIiwiZHJhbSIsImV1cm9wZWFuIiwiZXVybyIsImZsb3JpbiIsImZyYW5jIiwiZ3VhcmFuaSIsImhyeXZuaWEiLCJraXAiLCJhdHQiLCJsZXB0b24iLCJsaXJhIiwibGlyYU9sZCIsImxhcmkiLCJtYXJrIiwibWlsbCIsIm5haXJhIiwicGVzZXRhIiwicGVzbyIsInBmZW5uaWciLCJwb3VuZCIsInJlYWwiLCJyaWVsIiwicnVibGUiLCJydXBlZSIsInJ1cGVlT2xkIiwic2hla2VsIiwic2hla2VsQWx0IiwidGFrYSIsInRlbmdlIiwidG9ncm9nIiwid29uIiwieWVuIiwiY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQiLCJwcmVmaXgiLCJzdWZmaXgiLCJkZWNpbWFsQ2hhcmFjdGVyIiwiY29tbWEiLCJkb3QiLCJtaWRkbGVEb3QiLCJhcmFiaWNEZWNpbWFsU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvcktleVN5bWJvbCIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRvTm90T3ZlcnJpZGUiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIiwidXNlRGVmYXVsdCIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwiZGlnaXRhbEdyb3VwU3BhY2luZyIsInR3byIsInR3b1NjYWxlZCIsInRocmVlIiwiZm91ciIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJub3JtYWxTcGFjZSIsInRoaW5TcGFjZSIsIm5hcnJvd05vQnJlYWtTcGFjZSIsIm5vQnJlYWtTcGFjZSIsIm5vU2VwYXJhdG9yIiwiYXBvc3Ryb3BoZSIsImFyYWJpY1Rob3VzYW5kc1NlcGFyYXRvciIsImRvdEFib3ZlIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwiZm9jdXMiLCJwcmVzcyIsInplcm8iLCJmYWlsT25Vbmtub3duT3B0aW9uIiwiZmFpbCIsImlnbm9yZSIsImZvcm1hdE9uUGFnZUxvYWQiLCJmb3JtYXQiLCJkb05vdEZvcm1hdCIsImhpc3RvcnlTaXplIiwidmVyeVNtYWxsIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsInZlcnlMYXJnZSIsImluc2FuZSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0NhbmNlbGxhYmxlIiwiY2FuY2VsbGFibGUiLCJub3RDYW5jZWxsYWJsZSIsImxlYWRpbmdaZXJvIiwiYWxsb3ciLCJkZW55Iiwia2VlcCIsIm1heGltdW1WYWx1ZSIsInRlblRyaWxsaW9ucyIsInRlblRyaWxsaW9uc05vRGVjaW1hbHMiLCJvbmVCaWxsaW9uIiwibWluaW11bVZhbHVlIiwibW9kaWZ5VmFsdWVPbldoZWVsIiwibW9kaWZ5VmFsdWUiLCJkb05vdGhpbmciLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsInBhcmVudGhlc2VzIiwiYnJhY2tldHMiLCJjaGV2cm9ucyIsImN1cmx5QnJhY2VzIiwiYW5nbGVCcmFja2V0cyIsImphcGFuZXNlUXVvdGF0aW9uTWFya3MiLCJoYWxmQnJhY2tldHMiLCJ3aGl0ZVNxdWFyZUJyYWNrZXRzIiwicXVvdGF0aW9uTWFya3MiLCJndWlsbGVtZXRzIiwibmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQiLCJsZWZ0IiwicmlnaHQiLCJub0V2ZW50TGlzdGVuZXJzIiwibm9FdmVudHMiLCJhZGRFdmVudHMiLCJub1NlcGFyYXRvck9uRm9jdXMiLCJ3aXRoU2VwYXJhdG9yIiwib25JbnZhbGlkUGFzdGUiLCJlcnJvciIsImNsYW1wIiwidHJ1bmNhdGUiLCJyZXBsYWNlIiwib3V0cHV0Rm9ybWF0Iiwic3RyaW5nIiwibnVtYmVyIiwibmVnYXRpdmVEb3QiLCJuZWdhdGl2ZUNvbW1hIiwiZG90TmVnYXRpdmUiLCJjb21tYU5lZ2F0aXZlIiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJjZWlsaW5nIiwiZmxvb3IiLCJyZWFkT25seSIsInJlYWRXcml0ZSIsInJvdW5kaW5nTWV0aG9kIiwiaGFsZlVwU3ltbWV0cmljIiwiaGFsZlVwQXN5bW1ldHJpYyIsImhhbGZEb3duU3ltbWV0cmljIiwiaGFsZkRvd25Bc3ltbWV0cmljIiwiaGFsZkV2ZW5CYW5rZXJzUm91bmRpbmciLCJ1cFJvdW5kQXdheUZyb21aZXJvIiwiZG93blJvdW5kVG93YXJkWmVybyIsInRvQ2VpbGluZ1Rvd2FyZFBvc2l0aXZlSW5maW5pdHkiLCJ0b0Zsb29yVG93YXJkTmVnYXRpdmVJbmZpbml0eSIsInRvTmVhcmVzdDA1IiwidG9OZWFyZXN0MDVBbHQiLCJ1cFRvTmV4dDA1IiwiZG93blRvTmV4dDA1Iiwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSIsInNhdmUiLCJkb05vdFNhdmUiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJkb05vdENoYW5nZURlY2ltYWxQbGFjZXMiLCJzY2FsZURpdmlzb3IiLCJkb05vdEFjdGl2YXRlVGhlU2NhbGluZ09wdGlvbiIsInBlcmNlbnRhZ2UiLCJwZXJtaWxsZSIsImJhc2lzUG9pbnQiLCJzY2FsZVN5bWJvbCIsInNlbGVjdE51bWJlck9ubHkiLCJzZWxlY3ROdW1iZXJzT25seSIsInNlbGVjdEFsbCIsInNlbGVjdE9uRm9jdXMiLCJzZWxlY3QiLCJkb05vdFNlbGVjdCIsInNlcmlhbGl6ZVNwYWNlcyIsInBsdXMiLCJwZXJjZW50Iiwic2hvd1Bvc2l0aXZlU2lnbiIsInNob3ciLCJoaWRlIiwic2hvd1dhcm5pbmdzIiwic3R5bGVSdWxlcyIsInBvc2l0aXZlTmVnYXRpdmUiLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwicmFuZ2UwVG8xMDBXaXRoNFN0ZXBzIiwicmFuZ2VzIiwibWluIiwibWF4IiwiY2xhc3MiLCJldmVuT2RkIiwidXNlckRlZmluZWQiLCJjYWxsYmFjayIsInJhd1ZhbHVlIiwiY2xhc3NlcyIsInJhbmdlU21hbGxBbmRaZXJvIiwic3VmZml4VGV4dCIsInVuZm9ybWF0T25Ib3ZlciIsInVuZm9ybWF0IiwiZG9Ob3RVbmZvcm1hdCIsInVuZm9ybWF0T25TdWJtaXQiLCJrZWVwQ3VycmVudFZhbHVlIiwid2hlZWxTdGVwIiwicHJvZ3Jlc3NpdmUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBNkJBOzs7Ozs7QUFFQTs7O0FBR0Esc0JBQVlBLE9BQVosR0FBc0I7QUFDbEI7Ozs7OztBQU1BQyx5QkFBK0I7QUFDM0JDLGdCQUFRLElBRG1CO0FBRTNCQyxlQUFRLEtBRm1CO0FBRzNCQyxnQkFBUTtBQUhtQixLQVBiOztBQWFsQjs7Ozs7OztBQU9BQywwQkFBZ0M7QUFDNUJDLGVBQXdCLE9BREk7QUFFNUJDLGFBQXdCLEtBRkk7QUFHNUJDLHFCQUF3QixhQUhJO0FBSTVCQyxzQkFBd0IsY0FKSTtBQUs1QkMsZ0NBQXdCO0FBTEksS0FwQmQ7O0FBNEJsQjs7O0FBR0FDLHFCQUErQjtBQUMzQkMsb0JBQWlCLElBRFU7QUFFM0JDLHlCQUFpQjtBQUZVLEtBL0JiOztBQW9DbEI7Ozs7QUFJQUMsb0JBQStCO0FBQzNCQyxjQUFnQixFQURXO0FBRTNCQyxzQkFBZ0IsR0FGVztBQUczQkMsaUJBQWdCLEdBSFcsRUFHTjtBQUNyQkMsd0JBQWdCLEdBSlc7QUFLM0JDLGNBQWdCLEdBTFcsRUFLTjtBQUNyQkMsY0FBZ0IsR0FOVyxFQU1OO0FBQ3JCQyxjQUFnQixHQVBXO0FBUTNCQyxlQUFnQixHQVJXLEVBUU47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WSxHQUZlO0FBRzNCQyxrQkFBWSxHQUhlO0FBSTNCQyxvQkFBYTtBQUpjLEtBbGxCYjs7QUF5bEJsQjs7Ozs7Ozs7O0FBU0ErQixxQkFBK0I7QUFDM0JDLGtCQUFlLElBRFk7QUFFM0JDLHVCQUFlO0FBRlksS0FsbUJiOztBQXVtQmxCOzs7QUFHQUMsc0JBQStCO0FBQzNCRixrQkFBa0IsSUFEUztBQUUzQkcsMEJBQWtCO0FBRlMsS0ExbUJiOztBQSttQmxCOzs7Ozs7OztBQVFBQyxlQUErQjtBQUMzQkMscUJBQWE7QUFEYztBQXZuQmIsQ0FBdEIsQyxDQWxDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcHRpb25zIGZvciBhdXRvTnVtZXJpYy5qc1xuICogQGF1dGhvciBBbGV4YW5kcmUgQm9ubmVhdSA8YWxleGFuZHJlLmJvbm5lYXVAbGludXhmci5ldT5cbiAqIEBjb3B5cmlnaHQgwqkgMjAxNiBBbGV4YW5kcmUgQm9ubmVhdVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEF1dG9OdW1lcmljIGZyb20gJy4vQXV0b051bWVyaWMnO1xuXG4vKipcbiAqIE9wdGlvbnMgdmFsdWVzIGVudW1lcmF0aW9uXG4gKi9cbkF1dG9OdW1lcmljLm9wdGlvbnMgPSB7XG4gICAgLyogQWxsb3cgcGFkZGluZyB0aGUgZGVjaW1hbCBwbGFjZXMgd2l0aCB6ZXJvc1xuICAgICAqIGB0cnVlYCAgIDogYWx3YXlzIHBhZCBkZWNpbWFscyB3aXRoIHplcm9zXG4gICAgICogYGZhbHNlYCAgOiBuZXZlciBwYWQgd2l0aCB6ZXJvc1xuICAgICAqIGAnZmxvYXRzJ2AgOiBwYWQgd2l0aCB6ZXJvcyBvbmx5IHdoZW4gdGhlcmUgYXJlIGRlY2ltYWxzXG4gICAgICogTm90ZTogc2V0dGluZyBhbGxvd0RlY2ltYWxQYWRkaW5nIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZy5cbiAgICAgKi9cbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDoge1xuICAgICAgICBhbHdheXM6IHRydWUsXG4gICAgICAgIG5ldmVyIDogZmFsc2UsXG4gICAgICAgIGZsb2F0czogJ2Zsb2F0cycsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgd2hlcmUgc2hvdWxkIGJlIHBvc2l0aW9uZWQgdGhlIGNhcmV0IG9uIGZvY3VzXG4gICAgICogbnVsbCA6IERvIG5vdCBlbmZvcmNlIGFueSBjYXJldCBwb3NpdGlvbmluZyBvbiBmb2N1cyAodGhpcyBpcyBuZWVkZWQgd2hlbiB1c2luZyBgc2VsZWN0T25Gb2N1c2ApXG4gICAgICogYCdzdGFydCdgIDogcHV0IHRoZSBjYXJldCBvZiB0aGUgZmFyIGxlZnQgc2lkZSBvZiB0aGUgdmFsdWUgKGV4Y2x1ZGluZyB0aGUgcG9zaXRpdmUvbmVnYXRpdmUgc2lnbiBhbmQgY3VycmVuY3kgc3ltYm9sLCBpZiBhbnkpXG4gICAgICogYCdlbmQnYCA6IHB1dCB0aGUgY2FyZXQgb2YgdGhlIGZhciByaWdodCBzaWRlIG9mIHRoZSB2YWx1ZSAoZXhjbHVkaW5nIHRoZSBwb3NpdGl2ZS9uZWdhdGl2ZSBzaWduIGFuZCBjdXJyZW5jeSBzeW1ib2wsIGlmIGFueSlcbiAgICAgKiBgJ2RlY2ltYWxMZWZ0J2AgOiBwdXQgdGhlIGNhcmV0IG9mIHRoZSBsZWZ0IG9mIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpZiBhbnlcbiAgICAgKiBgJ2RlY2ltYWxSaWdodCdgIDogcHV0IHRoZSBjYXJldCBvZiB0aGUgcmlnaHQgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlmIGFueVxuICAgICAqL1xuICAgIGNhcmV0UG9zaXRpb25PbkZvY3VzICAgICAgICAgIDoge1xuICAgICAgICBzdGFydCAgICAgICAgICAgICAgICAgOiAnc3RhcnQnLFxuICAgICAgICBlbmQgICAgICAgICAgICAgICAgICAgOiAnZW5kJyxcbiAgICAgICAgZGVjaW1hbExlZnQgICAgICAgICAgIDogJ2RlY2ltYWxMZWZ0JyxcbiAgICAgICAgZGVjaW1hbFJpZ2h0ICAgICAgICAgIDogJ2RlY2ltYWxSaWdodCcsXG4gICAgICAgIGRvTm9Gb3JjZUNhcmV0UG9zaXRpb246IG51bGwsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgaWYgYSBsb2NhbCBsaXN0IG9mIEF1dG9OdW1lcmljIG9iamVjdHMgc2hvdWxkIGJlIGtlcHQgd2hlbiBpbml0aWFsaXppbmcgdGhpcyBvYmplY3QuXG4gICAgICogVGhpcyBsaXN0IGlzIHVzZWQgYnkgdGhlIGBnbG9iYWwuKmAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGNyZWF0ZUxvY2FsTGlzdCAgICAgICAgICAgICAgOiB7XG4gICAgICAgIGNyZWF0ZUxpc3QgICAgIDogdHJ1ZSxcbiAgICAgICAgZG9Ob3RDcmVhdGVMaXN0OiBmYWxzZSxcbiAgICB9LFxuXG4gICAgLyogRGVmaW5lcyB0aGUgY3VycmVuY3kgc3ltYm9sIHN0cmluZy5cbiAgICAgKiBJdCBjYW4gYmUgYSBzdHJpbmcgb2YgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXIgKGFsbG93aW5nIGZvciBpbnN0YW5jZSB0byB1c2UgYSBzcGFjZSBvbiBlaXRoZXIgc2lkZSBvZiBpdCwgZXhhbXBsZTogJyQgJyBvciAnICQnKVxuICAgICAqIGNmLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdXJyZW5jeV9zeW1ib2xcbiAgICAgKi9cbiAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDoge1xuICAgICAgICBub25lICAgICAgICAgIDogJycsXG4gICAgICAgIGN1cnJlbmN5U2lnbiAgOiAnwqQnLFxuICAgICAgICBhdXN0cmFsICAgICAgIDogJ+KCsycsIC8vIEFSQVxuICAgICAgICBhdXN0cmFsQ2VudGF2bzogJ8KiJyxcbiAgICAgICAgYmFodCAgICAgICAgICA6ICfguL8nLCAvLyBUSEJcbiAgICAgICAgY2VkaSAgICAgICAgICA6ICfigrUnLCAvLyBHSFNcbiAgICAgICAgY2VudCAgICAgICAgICA6ICfCoicsXG4gICAgICAgIGNvbG9uICAgICAgICAgOiAn4oKhJywgLy8gQ1JDXG4gICAgICAgIGNydXplaXJvICAgICAgOiAn4oKiJywgLy8gQlJCIC0gTm90IHVzZWQgYW55bW9yZSBzaW5jZSAxOTkzXG4gICAgICAgIGRvbGxhciAgICAgICAgOiAnJCcsXG4gICAgICAgIGRvbmcgICAgICAgICAgOiAn4oKrJywgLy8gVk5EXG4gICAgICAgIGRyYWNobWEgICAgICAgOiAn4oKvJywgLy8gR1JEIChvciAnzpTPgc+HLicgb3IgJ86Uz4EuJylcbiAgICAgICAgZHJhbSAgICAgICAgICA6ICfigIvWjycsIC8vIEFNRFxuICAgICAgICBldXJvcGVhbiAgICAgIDogJ+KCoCcsIC8vIFhFVSAob2xkIGN1cnJlbmN5IGJlZm9yZSB0aGUgRXVybylcbiAgICAgICAgZXVybyAgICAgICAgICA6ICfigqwnLCAvLyBFVVJcbiAgICAgICAgZmxvcmluICAgICAgICA6ICfGkicsXG4gICAgICAgIGZyYW5jICAgICAgICAgOiAn4oKjJywgLy8gRlJGXG4gICAgICAgIGd1YXJhbmkgICAgICAgOiAn4oKyJywgLy8gUFlHXG4gICAgICAgIGhyeXZuaWEgICAgICAgOiAn4oK0JywgLy8g0LPRgNC9XG4gICAgICAgIGtpcCAgICAgICAgICAgOiAn4oKtJywgLy8gTEFLXG4gICAgICAgIGF0dCAgICAgICAgICAgOiAn4Lqt4Lqx4LqUJywgLy8gY2VudHMgb2YgdGhlIEtpcFxuICAgICAgICBsZXB0b24gICAgICAgIDogJ86bLicsIC8vIGNlbnRzIG9mIHRoZSBEcmFjaG1hXG4gICAgICAgIGxpcmEgICAgICAgICAgOiAn4oK6JywgLy8gVFJZXG4gICAgICAgIGxpcmFPbGQgICAgICAgOiAn4oKkJyxcbiAgICAgICAgbGFyaSAgICAgICAgICA6ICfigr4nLCAvLyBHRUxcbiAgICAgICAgbWFyayAgICAgICAgICA6ICfihLMnLFxuICAgICAgICBtaWxsICAgICAgICAgIDogJ+KCpScsXG4gICAgICAgIG5haXJhICAgICAgICAgOiAn4oKmJywgLy8gTkdOXG4gICAgICAgIHBlc2V0YSAgICAgICAgOiAn4oKnJyxcbiAgICAgICAgcGVzbyAgICAgICAgICA6ICfigrEnLCAvLyBQSFBcbiAgICAgICAgcGZlbm5pZyAgICAgICA6ICfigrAnLCAvLyBjZW50cyBvZiB0aGUgTWFya1xuICAgICAgICBwb3VuZCAgICAgICAgIDogJ8KjJyxcbiAgICAgICAgcmVhbCAgICAgICAgICA6ICdSJCcsIC8vIEJyYXppbGlhbiByZWFsXG4gICAgICAgIHJpZWwgICAgICAgICAgOiAn4Z+bJywgLy8gS0hSXG4gICAgICAgIHJ1YmxlICAgICAgICAgOiAn4oK9JywgLy8gUlVCXG4gICAgICAgIHJ1cGVlICAgICAgICAgOiAn4oK5JywgLy8gSU5SXG4gICAgICAgIHJ1cGVlT2xkICAgICAgOiAn4oKoJyxcbiAgICAgICAgc2hla2VsICAgICAgICA6ICfigqonLFxuICAgICAgICBzaGVrZWxBbHQgICAgIDogJ9ep17TXl+KAjuKAjicsXG4gICAgICAgIHRha2EgICAgICAgICAgOiAn4KezJywgLy8gQkRUXG4gICAgICAgIHRlbmdlICAgICAgICAgOiAn4oK4JywgLy8gS1pUXG4gICAgICAgIHRvZ3JvZyAgICAgICAgOiAn4oKuJywgLy8gTU5UXG4gICAgICAgIHdvbiAgICAgICAgICAgOiAn4oKpJyxcbiAgICAgICAgeWVuICAgICAgICAgICA6ICfCpScsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgd2hlcmUgdGhlIGN1cnJlbmN5IHN5bWJvbCBzaG91bGQgYmUgcGxhY2VkIChiZWZvcmUgb2YgYWZ0ZXIgdGhlIG51bWJlcnMpXG4gICAgICogZm9yIHByZWZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJwXCIgKGRlZmF1bHQpXG4gICAgICogZm9yIHN1ZmZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJcbiAgICAgKi9cbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDoge1xuICAgICAgICBwcmVmaXg6ICdwJyxcbiAgICAgICAgc3VmZml4OiAncycsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgd2hhdCBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgaXMgdXNlZFxuICAgICAqL1xuICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgOiB7XG4gICAgICAgIGNvbW1hICAgICAgICAgICAgICAgICAgICA6ICcsJyxcbiAgICAgICAgZG90ICAgICAgICAgICAgICAgICAgICAgIDogJy4nLFxuICAgICAgICBtaWRkbGVEb3QgICAgICAgICAgICAgICAgOiAnwrcnLFxuICAgICAgICBhcmFiaWNEZWNpbWFsU2VwYXJhdG9yICAgOiAn2asnLFxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yS2V5U3ltYm9sOiAn4o6WJyxcbiAgICB9LFxuXG4gICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbiBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGBkZWNpbWFsQ2hhcmFjdGVyYCB3aGVuIHR5cGVkLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBjb3VudHJpZXMgdGhhdCB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlXG4gICAgICogYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIChGcmFuY2Ugb3IgU3BhaW4gZm9yIGluc3RhbmNlKS5cbiAgICAgKi9cbiAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgIDoge1xuICAgICAgICBub25lIDogbnVsbCxcbiAgICAgICAgY29tbWE6ICcsJyxcbiAgICAgICAgZG90ICA6ICcuJyxcbiAgICB9LFxuXG4gICAgLyogRGVmaW5lcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gc2hvdyBhbmQga2VlcCBhcyB0aGUgcHJlY2lzaW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBvdmVycmlkZSB0aGUgZGVjaW1hbCBwbGFjZXMgbnVtYmVyIHNldCBieSB0aGUgbWluaW11bVZhbHVlICYgbWF4aW11bVZhbHVlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgICAgICAgIDoge1xuICAgICAgICBkb05vdE92ZXJyaWRlOiBudWxsLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHNob3VsZCBiZSB2aXNpYmxlIHdoZW4gdGhlIGVsZW1lbnQgaGFzIHRoZSBmb2N1c1xuICAgICAqIEV4YW1wbGU6XG4gICAgICogRm9uIGluc3RhbmNlIGlmIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBpcyBzZXQgdG8gYDVgIGFuZCB0aGUgZGVmYXVsdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaXMgYDJgLCB0aGVuIG9uIGZvY3VzIGAxLDAwMC4xMjM0NWAgd2lsbCBiZSBzaG93biwgd2hpbGUgd2l0aG91dCBmb2N1cyBgMSwwMDAuMTJgIHdpbGwgYmUgc2V0IGJhY2suXG4gICAgICogTm90ZSAxOiB0aGUgcmVzdWx0cyBkZXBlbmRzIG9uIHRoZSByb3VuZGluZyBtZXRob2QgdXNlZC5cbiAgICAgKiBOb3RlIDI6IHRoZSBgZ2V0TnVtZXJpY1N0cmluZygpYCBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKi9cbiAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDoge1xuICAgICAgICB1c2VEZWZhdWx0OiBudWxsLFxuICAgIH0sXG5cbiAgICAvKiBIZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICogVGhpcyBzaG91bGQgYmUgc2V0IGFzIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGV4YW1wbGVzOlxuICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IFwiXCJ9XG4gICAgICogdmFsdWU9MTIzNC41NiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6ICcxMjM0LjU2J31cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDoge1xuICAgICAgICBkb05vdE92ZXJyaWRlOiBudWxsLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGhvdyBtYW55IG51bWJlcnMgc2hvdWxkIGJlIGdyb3VwZWQgdG9nZXRoZXIgKHVzdWFsbHkgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IpXG4gICAgICogLSBcIjJcIiwgIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgKiAtIFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXG4gICAgICogLSBcIjNcIiwgIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgKGRlZmF1bHQpXG4gICAgICogLSBcIjRcIiwgIHJlc3VsdHMgaW4gOTk5OSw5OTk5LDk5OTkgdXNlZCBpbiBzb21lIEFzaWFuIGNvdW50cmllc1xuICAgICAqL1xuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmcgICAgICAgICAgOiB7XG4gICAgICAgIHR3byAgICAgIDogJzInLFxuICAgICAgICB0d29TY2FsZWQ6ICcycycsXG4gICAgICAgIHRocmVlICAgIDogJzMnLFxuICAgICAgICBmb3VyICAgICA6ICc0JyxcbiAgICB9LFxuXG4gICAgLyogRGVmaW5lcyB0aGUgdGhvdXNhbmQgZ3JvdXBpbmcgc2VwYXJhdG9yIGNoYXJhY3RlclxuICAgICAqIEV4YW1wbGUgOiBJZiBgJy4nYCBpcyBzZXQsIHRoZW4geW91J2xsIGdldCBgJzEuMjM0LjU2NydgXG4gICAgICovXG4gICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IHtcbiAgICAgICAgY29tbWEgICAgICAgICAgICAgICAgICAgOiAnLCcsXG4gICAgICAgIGRvdCAgICAgICAgICAgICAgICAgICAgIDogJy4nLFxuICAgICAgICBub3JtYWxTcGFjZSAgICAgICAgICAgICA6ICcgJyxcbiAgICAgICAgdGhpblNwYWNlICAgICAgICAgICAgICAgOiAnXFx1MjAwOScsXG4gICAgICAgIG5hcnJvd05vQnJlYWtTcGFjZSAgICAgIDogJ1xcdTIwMmYnLFxuICAgICAgICBub0JyZWFrU3BhY2UgICAgICAgICAgICA6ICdcXHUwMGEwJyxcbiAgICAgICAgbm9TZXBhcmF0b3IgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgYXBvc3Ryb3BoZSAgICAgICAgICAgICAgOiBgJ2AsXG4gICAgICAgIGFyYWJpY1Rob3VzYW5kc1NlcGFyYXRvcjogJ9msJyxcbiAgICAgICAgZG90QWJvdmUgICAgICAgICAgICAgICAgOiAny5knLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIHdoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiB0aGUgZWxlbWVudCBpZiB0aGUgcmF3IHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZyAoJycpLlxuICAgICAqIC0gJ2ZvY3VzJyAgOiBUaGUgY3VycmVuY3kgc2lnbiBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXMgKGRlZmF1bHQpXG4gICAgICogLSAncHJlc3MnICA6IFRoZSBjdXJyZW5jeSBzaWduIGlzIGRpc3BsYXllZCB3aGVuZXZlciBhIGtleSBpcyBiZWluZyBwcmVzc2VkXG4gICAgICogLSAnYWx3YXlzJyA6IFRoZSBjdXJyZW5jeSBzaWduIGlzIGFsd2F5cyBkaXNwbGF5ZWRcbiAgICAgKiAtICd6ZXJvJyAgIDogQSB6ZXJvIGlzIGRpc3BsYXllZCAoJ3JvdW5kZWQnIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ24pIGlmIHRoZSBpbnB1dCBoYXMgbm8gdmFsdWUgb24gZm9jdXMgb3V0XG4gICAgICovXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yICAgICAgICAgICA6IHtcbiAgICAgICAgZm9jdXMgOiAnZm9jdXMnLFxuICAgICAgICBwcmVzcyA6ICdwcmVzcycsXG4gICAgICAgIGFsd2F5czogJ2Fsd2F5cycsXG4gICAgICAgIHplcm8gIDogJ3plcm8nLFxuICAgIH0sXG5cbiAgICAvKiBUaGlzIG9wdGlvbiBpcyB0aGUgJ3N0cmljdCBtb2RlJyAoYWthICdkZWJ1ZycgbW9kZSksIHdoaWNoIGFsbG93cyBhdXRvTnVtZXJpYyB0byBzdHJpY3RseSBhbmFseXNlIHRoZSBvcHRpb25zIHBhc3NlZCwgYW5kIGZhaWxzIGlmIGFuIHVua25vd24gb3B0aW9ucyBpcyB1c2VkIGluIHRoZSBzZXR0aW5ncyBvYmplY3QuXG4gICAgICogWW91IHNob3VsZCBzZXQgdGhhdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gbWFrZSBzdXJlIHlvdSBhcmUgb25seSB1c2luZyAncHVyZScgYXV0b051bWVyaWMgc2V0dGluZ3Mgb2JqZWN0cyBpbiB5b3VyIGNvZGUuXG4gICAgICogSWYgeW91IHNlZSB1bmNhdWdodCBlcnJvcnMgaW4gdGhlIGNvbnNvbGUgYW5kIHlvdXIgY29kZSBzdGFydHMgdG8gZmFpbCwgdGhpcyBtZWFucyBzb21laG93IHRob3NlIG9wdGlvbnMgZ2V0cyBwb2xsdXRlZCBieSBhbm90aGVyIHByb2dyYW0gKHdoaWNoIHVzdWFsbHkgaGFwcGVucyB3aGVuIHVzaW5nIGZyYW1ld29ya3MpLlxuICAgICAqL1xuICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiB7XG4gICAgICAgIGZhaWwgIDogdHJ1ZSxcbiAgICAgICAgaWdub3JlOiBmYWxzZSxcbiAgICB9LFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgOiB7XG4gICAgICAgIGZvcm1hdCAgICAgOiB0cnVlLCAvLyBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgZG9Ob3RGb3JtYXQ6IGZhbHNlLCAvLyB3aWxsIG5vdCBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICB9LFxuXG4gICAgLyogU2V0IHRoZSB1bmRvL3JlZG8gaGlzdG9yeSB0YWJsZSBzaXplLlxuICAgICAqIEVhY2ggcmVjb3JkIGtlZXBzIHRoZSByYXcgdmFsdWUgYXMgd2VsbCBhbmQgdGhlIGxhc3Qga25vd24gY2FyZXQvc2VsZWN0aW9uIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICBoaXN0b3J5U2l6ZSAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICB2ZXJ5U21hbGw6IDUsXG4gICAgICAgIHNtYWxsICAgIDogMTAsXG4gICAgICAgIG1lZGl1bSAgIDogMjAsXG4gICAgICAgIGxhcmdlICAgIDogNTAsXG4gICAgICAgIHZlcnlMYXJnZTogMTAwLFxuICAgICAgICBpbnNhbmUgICA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIH0sXG5cbiAgICAvKiBBbGxvdyB0aGUgdXNlciB0byAnY2FuY2VsJyBhbmQgdW5kbyB0aGUgY2hhbmdlcyBoZSBtYWRlIHRvIHRoZSBnaXZlbiBhdXRvbnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnQsIGJ5IHByZXNzaW5nIHRoZSAnRXNjYXBlJyBrZXkuXG4gICAgICogV2hlbmV2ZXIgdGhlIHVzZXIgJ3ZhbGlkYXRlJyB0aGUgaW5wdXQgKGVpdGhlciBieSBoaXR0aW5nICdFbnRlcicsIG9yIGJsdXJyaW5nIHRoZSBlbGVtZW50KSwgdGhlIG5ldyB2YWx1ZSBpcyBzYXZlZCBmb3Igc3Vic2VxdWVudCAnY2FuY2VsbGF0aW9uJy5cbiAgICAgKlxuICAgICAqIFRoZSBwcm9jZXNzIDpcbiAgICAgKiAgIC0gc2F2ZSB0aGUgaW5wdXQgdmFsdWUgb24gZm9jdXNcbiAgICAgKiAgIC0gaWYgdGhlIHVzZXIgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIGhpdCBgRXNjYXBlYCwgdGhlbiB0aGUgaW5pdGlhbCB2YWx1ZSBzYXZlZCBvbiBmb2N1cyBpcyBzZXQgYmFja1xuICAgICAqICAgLSBvbiB0aGUgb3RoZXIgaGFuZCBpZiB0aGUgdXNlciBlaXRoZXIgaGF2ZSB1c2VkIGBFbnRlcmAgdG8gdmFsaWRhdGUgKGBFbnRlcmAgdGhyb3dzIGEgY2hhbmdlIGV2ZW50KSBoaXMgZW50cmllcywgb3IgaWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQgYnkgYW5vdGhlciBzY3JpcHQgaW4gdGhlIG1lYW4gdGltZSwgdGhlbiB3ZSBzYXZlIHRoZSBuZXcgaW5wdXQgdmFsdWVcbiAgICAgKiAgIC0gb24gYSBzdWNjZXNzZnVsICdjYW5jZWwnLCBzZWxlY3QgdGhlIHdob2xlIHZhbHVlICh3aGlsZSByZXNwZWN0aW5nIHRoZSBgc2VsZWN0TnVtYmVyT25seWAgb3B0aW9uKVxuICAgICAqICAgLSBib251czsgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgaGl0dGluZyAnRXNjJyBqdXN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHZhbHVlICh3aGlsZSByZXNwZWN0aW5nIHRoZSBgc2VsZWN0TnVtYmVyT25seWAgb3B0aW9uKVxuICAgICAqL1xuICAgIGlzQ2FuY2VsbGFibGUgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIGNhbmNlbGxhYmxlICAgOiB0cnVlLFxuICAgICAgICBub3RDYW5jZWxsYWJsZTogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIENvbnRyb2xzIHRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3JcbiAgICAgKiAtICdhbGxvdycgOiBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWRcbiAgICAgKiAtICdkZW55JyAgOiBhbGxvd3Mgb25seSBvbmUgbGVhZGluZyB6ZXJvIG9uIHZhbHVlcyB0aGF0IGFyZSBiZXR3ZWVuIDEgYW5kIC0xXG4gICAgICogLSAna2VlcCcgIDogYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZFxuICAgICAqL1xuICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIGFsbG93OiAnYWxsb3cnLFxuICAgICAgICBkZW55IDogJ2RlbnknLFxuICAgICAgICBrZWVwIDogJ2tlZXAnLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIGEgdXNlciBjYW4gZW50ZXIuXG4gICAgICogTm90ZXM6XG4gICAgICogLSB0aGlzIHZhbHVlIG11c3QgYSBzdHJpbmcgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIC0gdGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBsYXJnZXIgdGhhbiBgbWluaW11bVZhbHVlYFxuICAgICAqL1xuICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIHRlblRyaWxsaW9ucyAgICAgICAgICA6ICc5OTk5OTk5OTk5OTk5Ljk5JywgLy8gOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcbiAgICAgICAgdGVuVHJpbGxpb25zTm9EZWNpbWFsczogJzk5OTk5OTk5OTk5OTknLFxuICAgICAgICBvbmVCaWxsaW9uICAgICAgICAgICAgOiAnOTk5OTk5OTk5Ljk5JyxcbiAgICAgICAgemVybyAgICAgICAgICAgICAgICAgIDogJzAnLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIHRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIGEgdXNlciBjYW4gZW50ZXIuXG4gICAgICogTm90ZXM6XG4gICAgICogLSB0aGlzIHZhbHVlIG11c3QgYSBzdHJpbmcgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIC0gdGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzbWFsbGVyIHRoYW4gYG1heGltdW1WYWx1ZWBcbiAgICAgKiAtIGlmIHRoaXMgaXMgc3VwZXJpb3IgdG8gMCwgdGhlbiB5b3UnbGwgZWZmZWN0aXZlbHkgcHJldmVudCB5b3VyIHVzZXIgdG8gZW50aXJlbHkgZGVsZXRlIHRoZSBjb250ZW50IG9mIHlvdXIgZWxlbWVudFxuICAgICAqL1xuICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIHRlblRyaWxsaW9ucyAgICAgICAgICA6ICctOTk5OTk5OTk5OTk5OS45OScsIC8vIC05Ljk5OS45OTkuOTk5Ljk5OSw5OSB+PSAxMDAwMCBiaWxsaW9uc1xuICAgICAgICB0ZW5UcmlsbGlvbnNOb0RlY2ltYWxzOiAnLTk5OTk5OTk5OTk5OTknLFxuICAgICAgICBvbmVCaWxsaW9uICAgICAgICAgICAgOiAnLTk5OTk5OTk5OS45OScsXG4gICAgICAgIHplcm8gICAgICAgICAgICAgICAgICA6ICcwJyxcbiAgICB9LFxuXG4gICAgLyogQWxsb3cgdGhlIHVzZXIgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCB0aGUgZWxlbWVudCB2YWx1ZSB3aXRoIHRoZSBtb3VzZSB3aGVlbC5cbiAgICAgKiBUaGUgd2hlZWwgYmVoYXZpb3IgY2FuIGJ5IG1vZGlmaWVkIGJ5IHRoZSBgd2hlZWxTdGVwYCBvcHRpb24uXG4gICAgICogVGhpcyBgd2hlZWxTdGVwYCBvcHRpb25zIGNhbiBiZSB1c2VkIGluIHR3byB3YXlzLCBlaXRoZXIgYnkgc2V0dGluZyA6XG4gICAgICogLSBhICdmaXhlZCcgc3RlcCB2YWx1ZSAoYHdoZWVsU3RlcCA6IDEwMDBgKSwgb3JcbiAgICAgKiAtIHRoZSAncHJvZ3Jlc3NpdmUnIHN0cmluZyAoYHdoZWVsU3RlcCA6ICdwcm9ncmVzc2l2ZSdgKSwgd2hpY2ggd2lsbCB0aGVuIGFjdGl2YXRlIGEgc3BlY2lhbCBtb2RlIHdoZXJlIHRoZSBzdGVwIGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZWxlbWVudCB2YWx1ZSBzaXplLlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQSBzcGVjaWFsIGJlaGF2aW9yIGlzIGFwcGxpZWQgaW4gb3JkZXIgdG8gYXZvaWQgcHJldmVudGluZyB0aGUgdXNlciB0byBzY3JvbGwgdGhlIHBhZ2UgaWYgdGhlIGlucHV0cyBhcmUgY292ZXJpbmcgdGhlIHdob2xlIGF2YWlsYWJsZSBzcGFjZS5cbiAgICAgKiBZb3UgY2FuIHVzZSB0aGUgJ1NoaWZ0JyBtb2RpZmllciBrZXkgd2hpbGUgdXNpbmcgdGhlIG1vdXNlIHdoZWVsIGluIG9yZGVyIHRvIHRlbXBvcmFyaWx5IGRpc2FibGUgdGhlIGluY3JlbWVudC9kZWNyZW1lbnQgZmVhdHVyZSAodXNlZnVsIG9uIHNtYWxsIHNjcmVlbiB3aGVyZSBzb21lIGJhZGx5IGNvbmZpZ3VyZWQgaW5wdXRzIGNvdWxkIHVzZSBhbGwgdGhlIGF2YWlsYWJsZSBzcGFjZSkuXG4gICAgICovXG4gICAgbW9kaWZ5VmFsdWVPbldoZWVsICAgICAgICAgICA6IHtcbiAgICAgICAgbW9kaWZ5VmFsdWU6IHRydWUsXG4gICAgICAgIGRvTm90aGluZyAgOiBmYWxzZSxcbiAgICB9LFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYS5cbiAgICAgKi9cbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjoge1xuICAgICAgICBwYXJlbnRoZXNlcyAgICAgICAgICAgOiAnKCwpJyxcbiAgICAgICAgYnJhY2tldHMgICAgICAgICAgICAgIDogJ1ssXScsXG4gICAgICAgIGNoZXZyb25zICAgICAgICAgICAgICA6ICc8LD4nLFxuICAgICAgICBjdXJseUJyYWNlcyAgICAgICAgICAgOiAneyx9JyxcbiAgICAgICAgYW5nbGVCcmFja2V0cyAgICAgICAgIDogJ+OAiCzjgIknLFxuICAgICAgICBqYXBhbmVzZVF1b3RhdGlvbk1hcmtzOiAn772iLO+9oycsXG4gICAgICAgIGhhbGZCcmFja2V0cyAgICAgICAgICA6ICfiuKQs4rilJyxcbiAgICAgICAgd2hpdGVTcXVhcmVCcmFja2V0cyAgIDogJ+Kfpizin6cnLFxuICAgICAgICBxdW90YXRpb25NYXJrcyAgICAgICAgOiAn4oC5LOKAuicsXG4gICAgICAgIGd1aWxsZW1ldHMgICAgICAgICAgICA6ICfCqyzCuycsXG4gICAgICAgIG5vbmUgICAgICAgICAgICAgICAgICA6IG51bGwsIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUsIHdoaWNoIGRlYWN0aXZhdGUgdGhpcyBmZWF0dXJlXG4gICAgfSxcblxuICAgIC8qIFBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUvcG9zaXRpdmUgc2lnbiByZWxhdGl2ZSB0byB0aGUgYGN1cnJlbmN5U3ltYm9sYCBvcHRpb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXG4gICAgICogLSQxLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwifSBvciB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJsXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9IC8vIERlZmF1bHQgaWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgJ251bGwnIGFuZCBjdXJyZW5jeVN5bWJvbCBpcyBub3QgZW1wdHlcbiAgICAgKiAtMSwyMzQuNTYkID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSAvLyBEZWZhdWx0IGlmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzICdudWxsJyBhbmQgY3VycmVuY3lTeW1ib2wgaXMgbm90IGVtcHR5XG4gICAgICogMSwyMzQuNTYtICA9PiB7bmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxuICAgICAqICQxLDIzNC41Ni0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxuICAgICAqIDEsMjM0LjU2LSQgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wifVxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XG4gICAgICovXG4gICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IHtcbiAgICAgICAgcHJlZml4OiAncCcsXG4gICAgICAgIHN1ZmZpeDogJ3MnLFxuICAgICAgICBsZWZ0ICA6ICdsJyxcbiAgICAgICAgcmlnaHQgOiAncicsXG4gICAgICAgIG5vbmUgIDogbnVsbCxcbiAgICB9LFxuXG4gICAgLyogRGVmaW5lcyBpZiB0aGUgZWxlbWVudCBzaG91bGQgaGF2ZSBldmVudCBsaXN0ZW5lcnMgYWN0aXZhdGVkIG9uIGl0LlxuICAgICAqIEJ5IGRlZmF1bHQsIHRob3NlIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhZGRlZCB0byA8aW5wdXQ+IGVsZW1lbnRzIGFuZCBodG1sIGVsZW1lbnQgd2l0aCB0aGUgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldCB0byBgdHJ1ZWAsIGJ1dCBub3Qgb24gdGhlIG90aGVyIGh0bWwgdGFncy5cbiAgICAgKiBUaGlzIGFsbG93cyB0byBpbml0aWFsaXplIGVsZW1lbnRzIHdpdGhvdXQgYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBXYXJuaW5nOiBTaW5jZSBBdXRvTnVtZXJpYyB3aWxsIG5vdCBjaGVjayB0aGUgaW5wdXQgY29udGVudCBhZnRlciBpdHMgaW5pdGlhbGl6YXRpb24sIHVzaW5nIHNvbWUgYXV0b051bWVyaWMgbWV0aG9kcyB3aWxsIHByb2JhYmx5IGxlYWRzIHRvIGZvcm1hdHRpbmcgcHJvYmxlbXMuXG4gICAgICovXG4gICAgbm9FdmVudExpc3RlbmVycyAgICAgICAgICAgICA6IHtcbiAgICAgICAgbm9FdmVudHMgOiB0cnVlLFxuICAgICAgICBhZGRFdmVudHM6IGZhbHNlLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGlmIHRoZSBlbGVtZW50IHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHJhdyB2YWx1ZSBvbiBmb2N1cyAoYW5kIGJhY2sgdG8gdGhlIGZvcm1hdHRlZCBvbiBibHVyKS5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGVuIGF1dG9OdW1lcmljIHJlbW92ZSB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yLCBjdXJyZW5jeSBzeW1ib2wgYW5kIHN1ZmZpeCBvbiBmb2N1cy5cbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBpcyAnJCAxLDk5OS44OCBzdWZmaXgnLCBvbiBmb2N1cyBpdCBiZWNvbWVzICcxOTk5Ljg4JyBhbmQgYmFjayB0byAnJCAxLDk5OS44OCBzdWZmaXgnIG9uIGZvY3VzIG91dC5cbiAgICAgKi9cbiAgICAvL1RPRE8gUmVuYW1lIHRoaXMgb3B0aW9uIHRvIGByYXdWYWx1ZU9uRm9jdXNgXG4gICAgbm9TZXBhcmF0b3JPbkZvY3VzICAgICAgICAgICA6IHtcbiAgICAgICAgbm9TZXBhcmF0b3IgIDogdHJ1ZSxcbiAgICAgICAgd2l0aFNlcGFyYXRvcjogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIE1hbmFnZSBob3cgYXV0b051bWVyaWMgcmVhY3Qgd2hlbiB0aGUgdXNlciB0cmllcyB0byBwYXN0ZSBhbiBpbnZhbGlkIG51bWJlci5cbiAgICAgKiAtICdlcnJvcicgICAgOiAoVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvcikgVGhlIGlucHV0IHZhbHVlIGlzIG5vdCBjaGFuZ2VkIGFuZCBhbiBlcnJvciBpcyBvdXRwdXQgaW4gdGhlIGNvbnNvbGUuXG4gICAgICogLSAnaWdub3JlJyAgIDogaWRlbSB0aGFuICdlcnJvcicsIGJ1dCBmYWlsIHNpbGVudGx5IHdpdGhvdXQgb3V0cHV0dGluZyBhbnkgZXJyb3Ivd2FybmluZyBpbiB0aGUgY29uc29sZS5cbiAgICAgKiAtICdjbGFtcCcgICAgOiBpZiB0aGUgcGFzdGVkIHZhbHVlIGlzIGVpdGhlciB0b28gc21hbGwgb3IgdG9vIGJpZyByZWdhcmRpbmcgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHJhbmdlLCB0aGVuIHRoZSByZXN1bHQgaXMgY2xhbXBlZCB0byB0aG9zZSBsaW1pdHMuXG4gICAgICogLSAndHJ1bmNhdGUnIDogYXV0b051bWVyaWMgd2lsbCBpbnNlcnQgYXMgbWFueSBwYXN0ZWQgbnVtYmVycyBpdCBjYW4gYXQgdGhlIGluaXRpYWwgY2FyZXQvc2VsZWN0aW9uLCB1bnRpbCBldmVyeXRoaW5nIGlzIHBhc3RlZCwgb3IgdGhlIHJhbmdlIGxpbWl0IGlzIGhpdC5cbiAgICAgKiAgICAgICAgICAgICAgICBUaGUgbm9uLXBhc3RlZCBudW1iZXJzIGFyZSBkcm9wcGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWQgYXQgYWxsLlxuICAgICAqIC0gJ3JlcGxhY2UnICA6IGF1dG9OdW1lcmljIHdpbGwgZmlyc3QgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdGhlbiBpZiB0aGUgcmFuZ2UgbGltaXQgaXMgaGl0LCBpdCB3aWxsIHRyeVxuICAgICAqICAgICAgICAgICAgICAgIHRvIHJlcGxhY2Ugb25lIGJ5IG9uZSB0aGUgcmVtYWluaW5nIGluaXRpYWwgbnVtYmVycyAob24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0KSB3aXRoIHRoZSByZXN0IG9mIHRoZSBwYXN0ZWQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIE5vdGUgMSA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbmVnYXRpdmUgc2lnbiAnLScgd2lsbCBiZSBhY2NlcHRlZCBhbnl3aGVyZSBpbiB0aGUgaW5wdXQsIGFuZCB3aWxsIHNldCB0aGUgcmVzdWx0aW5nIHZhbHVlIGFzIGEgbmVnYXRpdmUgbnVtYmVyXG4gICAgICogTm90ZSAyIDogQSBwYXN0ZSBjb250ZW50IHN0YXJ0aW5nIHdpdGggYSBudW1iZXIgd2lsbCBiZSBhY2NlcHRlZCwgZXZlbiBpZiB0aGUgcmVzdCBpcyBnaWJiZXJpc2ggKGllLiAnMTIzZm9vYmFyNDU2JykuXG4gICAgICogICAgICAgICAgT25seSB0aGUgZmlyc3QgbnVtYmVyIHdpbGwgYmUgdXNlZCAoaGVyZSAnMTIzJykuXG4gICAgICogTm90ZSAzIDogVGhlIHBhc3RlIGV2ZW50IHdvcmtzIHdpdGggdGhlIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBvcHRpb24gdG9vLlxuICAgICAqL1xuICAgIG9uSW52YWxpZFBhc3RlICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIGVycm9yICAgOiAnZXJyb3InLFxuICAgICAgICBpZ25vcmUgIDogJ2lnbm9yZScsXG4gICAgICAgIGNsYW1wICAgOiAnY2xhbXAnLFxuICAgICAgICB0cnVuY2F0ZTogJ3RydW5jYXRlJyxcbiAgICAgICAgcmVwbGFjZSA6ICdyZXBsYWNlJyxcbiAgICB9LFxuXG4gICAgLyogRGVmaW5lcyBob3cgdGhlIHZhbHVlIHNob3VsZCBiZSBmb3JtYXR0ZWQgd2hlbiB3YW50aW5nIGEgJ2xvY2FsaXplZCcgdmVyc2lvbiBvZiBpdC5cbiAgICAgKiAtIG51bGwgb3IgJ3N0cmluZycgPT4gJ25ubm4ubm4nIG9yICctbm5ubi5ubicgYXMgdGV4dCB0eXBlLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqIC0gJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAqIC0gJywnIG9yICctLCcgICAgICA9PiAnbm5ubixubicgb3IgJy1ubm5uLG5uJ1xuICAgICAqIC0gJy4tJyAgICAgICAgICAgICA9PiAnbm5ubi5ubicgb3IgJ25ubm4ubm4tJ1xuICAgICAqIC0gJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAqL1xuICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIHN0cmluZyAgICAgICA6ICdzdHJpbmcnLFxuICAgICAgICBudW1iZXIgICAgICAgOiAnbnVtYmVyJyxcbiAgICAgICAgZG90ICAgICAgICAgIDogJy4nLFxuICAgICAgICBuZWdhdGl2ZURvdCAgOiAnLS4nLFxuICAgICAgICBjb21tYSAgICAgICAgOiAnLCcsXG4gICAgICAgIG5lZ2F0aXZlQ29tbWE6ICctLCcsXG4gICAgICAgIGRvdE5lZ2F0aXZlICA6ICcuLScsXG4gICAgICAgIGNvbW1hTmVnYXRpdmU6ICcsLScsXG4gICAgICAgIG5vbmUgICAgICAgICA6IG51bGwsXG4gICAgfSxcblxuICAgIC8qIE92ZXJyaWRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxpbWl0c1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gbWluaW11bVZhbHVlIGFuZCBpZ25vcmVzIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgKi9cbiAgICBvdmVycmlkZU1pbk1heExpbWl0cyAgICAgICAgIDoge1xuICAgICAgICBjZWlsaW5nICAgICAgOiAnY2VpbGluZycsXG4gICAgICAgIGZsb29yICAgICAgICA6ICdmbG9vcicsXG4gICAgICAgIGlnbm9yZSAgICAgICA6ICdpZ25vcmUnLFxuICAgICAgICBkb05vdE92ZXJyaWRlOiBudWxsLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGlmIHRoZSA8aW5wdXQ+IGVsZW1lbnQgc2hvdWxkIGJlIHNldCBhcyByZWFkIG9ubHkgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGVuIHRoZSBgcmVhZG9ubHlgIGh0bWwgcHJvcGVydHkgaXMgYWRkZWQgdG8gdGhlIDxpbnB1dD4gZWxlbWVudCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICByZWFkT25seSAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICByZWFkT25seSA6IHRydWUsXG4gICAgICAgIHJlYWRXcml0ZTogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgdGhlIHJvdW5kaW5nIG1ldGhvZCB0byB1c2UuXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqL1xuICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIGhhbGZVcFN5bW1ldHJpYyAgICAgICAgICAgICAgICA6ICdTJyxcbiAgICAgICAgaGFsZlVwQXN5bW1ldHJpYyAgICAgICAgICAgICAgIDogJ0EnLFxuICAgICAgICBoYWxmRG93blN5bW1ldHJpYyAgICAgICAgICAgICAgOiAncycsXG4gICAgICAgIGhhbGZEb3duQXN5bW1ldHJpYyAgICAgICAgICAgICA6ICdhJyxcbiAgICAgICAgaGFsZkV2ZW5CYW5rZXJzUm91bmRpbmcgICAgICAgIDogJ0InLFxuICAgICAgICB1cFJvdW5kQXdheUZyb21aZXJvICAgICAgICAgICAgOiAnVScsXG4gICAgICAgIGRvd25Sb3VuZFRvd2FyZFplcm8gICAgICAgICAgICA6ICdEJyxcbiAgICAgICAgdG9DZWlsaW5nVG93YXJkUG9zaXRpdmVJbmZpbml0eTogJ0MnLFxuICAgICAgICB0b0Zsb29yVG93YXJkTmVnYXRpdmVJbmZpbml0eSAgOiAnRicsXG4gICAgICAgIHRvTmVhcmVzdDA1ICAgICAgICAgICAgICAgICAgICA6ICdOMDUnLFxuICAgICAgICB0b05lYXJlc3QwNUFsdCAgICAgICAgICAgICAgICAgOiAnQ0hGJyxcbiAgICAgICAgdXBUb05leHQwNSAgICAgICAgICAgICAgICAgICAgIDogJ1UwNScsXG4gICAgICAgIGRvd25Ub05leHQwNSAgICAgICAgICAgICAgICAgICA6ICdEMDUnLFxuICAgIH0sXG5cbiAgICAvKiBTZXQgdG8gYHRydWVgIHRvIGFsbG93IHRoZSBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxuICAgICAqIElmIElFIDYgb3IgNyBpcyBkZXRlY3RlZCwgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZS5cbiAgICAgKi9cbiAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICAgIDoge1xuICAgICAgICBzYXZlICAgICA6IHRydWUsXG4gICAgICAgIGRvTm90U2F2ZTogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsUGxhY2VzICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBcInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2VcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWVcbiAgICAgKiBbXCJkaXZpc29yXCIsIFwiZGVjaW1hbCBwbGFjZXNcIiwgXCJzeW1ib2xcIl1cbiAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWxQbGFjZXM6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XG4gICAgICogRXhhbXBsZTogZm9jdXNpbiB2YWx1ZSBcIjEsMTExLjExXCIgZm9jdXNvdXQgdmFsdWUgXCIxLjEgS1wiXG4gICAgICovXG5cbiAgICAvKiBUaGUgYHNjYWxlRGVjaW1hbFBsYWNlc2Agb3B0aW9uIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZSB3aGVuIG5vdCBpbiBmb2N1cyAtIGZvciB0aGlzIHRvIHdvcmssIGBzY2FsZWREaXZpc29yYCBtdXN0IG5vdCBiZSBgbnVsbGAuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCA7IGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIHRoZSBmb2N1cy5cbiAgICAgKi9cbiAgICBzY2FsZURlY2ltYWxQbGFjZXMgICAgICAgICAgIDoge1xuICAgICAgICBkb05vdENoYW5nZURlY2ltYWxQbGFjZXM6IG51bGwsXG4gICAgfSxcblxuICAgIC8qIFRoZSBgc2NhbGVEaXZpc29yYCBkZWNpZGVzIHRoZSBvbiBmb2N1cyB2YWx1ZSBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IG9uIGZvY3Vzb3V0XG4gICAgICogRXhhbXBsZSB7c2NhbGVEaXZpc29yOiAnMTAwMCd9IG9yIDxpbnB1dCBkYXRhLXNjYWxlLWRpdmlzb3I9XCIxMDAwXCI+XG4gICAgICogVGhlIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciBidXQgcGxlYXNlIHVuZGVyc3RhbmQgdGhhdCBKYXZhc2NyaXB0IGhhcyBsaW1pdGVkIGFjY3VyYWN5IGluIG1hdGhcbiAgICAgKiBUaGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSAnaGlkZGVuJyBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBzY2FsZURpdmlzb3IgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICBkb05vdEFjdGl2YXRlVGhlU2NhbGluZ09wdGlvbjogbnVsbCxcbiAgICAgICAgcGVyY2VudGFnZSAgICAgICAgICAgICAgICAgICA6IDEwMCxcbiAgICAgICAgcGVybWlsbGUgICAgICAgICAgICAgICAgICAgICA6IDEwMDAsXG4gICAgICAgIGJhc2lzUG9pbnQgICAgICAgICAgICAgICAgICAgOiAxMDAwMCxcbiAgICB9LFxuXG4gICAgLyogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbCAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICBub25lICAgICAgOiBudWxsLFxuICAgICAgICBwZXJjZW50YWdlOiAnJScsXG4gICAgICAgIHBlcm1pbGxlICA6ICfigLAnLFxuICAgICAgICBiYXNpc1BvaW50IDogJ+KAsScsXG4gICAgfSxcblxuICAgIC8qIERldGVybWluZSBpZiB0aGUgc2VsZWN0IGFsbCBrZXlib2FyZCBjb21tYW5kIHdpbGwgc2VsZWN0IHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0LCBvciBvbmx5IHRoZSBpbnB1dCBudW1lcmljIHZhbHVlXG4gICAgICogTm90ZSA6IElmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24sIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgICAgICAgOiB7XG4gICAgICAgIHNlbGVjdE51bWJlcnNPbmx5OiB0cnVlLFxuICAgICAgICBzZWxlY3RBbGwgICAgICAgIDogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgaWYgdGhlIGVsZW1lbnQgdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkIG9uIGZvY3VzLlxuICAgICAqIE5vdGU6IFRoZSBzZWxlY3Rpb24gaXMgZG9uZSB1c2luZyB0aGUgYHNlbGVjdE51bWJlck9ubHlgIG9wdGlvbi5cbiAgICAgKi9cbiAgICBzZWxlY3RPbkZvY3VzICAgICAgICAgICAgICAgIDoge1xuICAgICAgICBzZWxlY3QgICAgIDogdHJ1ZSxcbiAgICAgICAgZG9Ob3RTZWxlY3Q6IGZhbHNlLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGhvdyB0aGUgc2VyaWFsaXplIGZ1bmN0aW9ucyBzaG91bGQgdHJlYXQgdGhlIHNwYWNlcy5cbiAgICAgKiBUaG9zZSBzcGFjZXMgJyAnIGNhbiBlaXRoZXIgYmUgY29udmVydGVkIHRvIHRoZSBwbHVzIHNpZ24gJysnLCB3aGljaCBpcyB0aGUgZGVmYXVsdCwgb3IgdG8gJyUyMCcuXG4gICAgICogQm90aCB2YWx1ZXMgYmVpbmcgdmFsaWQgcGVyIHRoZSBzcGVjIChodHRwOi8vd3d3LnczLm9yZy9BZGRyZXNzaW5nL1VSTC91cmktc3BlYy5odG1sKS5cbiAgICAgKiBBbHNvIHNlZSB0aGUgc3VtbWVkIHVwIGFuc3dlciBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzkzOTI4Ny5cbiAgICAgKlxuICAgICAqIHRsO2RyIDogU3BhY2VzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gJyUyMCcgYmVmb3JlIHRoZSAnPycgc2lnbiwgdGhlbiBjb252ZXJ0ZWQgdG8gJysnIGFmdGVyLlxuICAgICAqIEluIG91ciBjYXNlIHNpbmNlIHdlIHNlcmlhbGl6ZSB0aGUgcXVlcnksIHdlIHVzZSAnKycgYXMgdGhlIGRlZmF1bHQgKGJ1dCBhbGxvdyB0aGUgdXNlciB0byBnZXQgYmFjayB0aGUgb2xkICp3cm9uZyogYmVoYXZpb3IpLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZVNwYWNlcyAgICAgICAgICAgICAgOiB7XG4gICAgICAgIHBsdXMgICA6ICcrJyxcbiAgICAgICAgcGVyY2VudDogJyUyMCcsXG4gICAgfSxcblxuICAgIC8qIEFsbG93IHRoZSBwb3NpdGl2ZSBzaWduIHN5bWJvbCBgK2AgdG8gYmUgZGlzcGxheWVkIGZvciBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcG9zaXRpdmUgc2lnbiBpcyBub3Qgc2hvd24uXG4gICAgICogVGhlIHNpZ24gcGxhY2VtZW50IGlzIGNvbnRyb2xsZWQgYnkgdGhlICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcgb3B0aW9uLCBtaW1pY2tpbmcgdGhlIG5lZ2F0aXZlIHNpZ24gcGxhY2VtZW50IHJ1bGVzLlxuICAgICAqL1xuICAgIHNob3dQb3NpdGl2ZVNpZ24gICAgICAgICAgICAgOiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGhpZGU6IGZhbHNlLFxuICAgIH0sXG5cbiAgICAvKiBEZWZpbmVzIGlmIHdhcm5pbmdzIHNob3VsZCBiZSBzaG93biBpbiB0aGUgY29uc29sZVxuICAgICAqIFRob3NlIHdhcm5pbmdzIGNhbiBiZSBpZ25vcmVkLCBidXQgYXJlIHVzdWFsbHkgcHJpbnRlZCB3aGVuIHNvbWV0aGluZyBjb3VsZCBiZSBpbXByb3ZlZCBieSB0aGUgdXNlciAoaWUuIG9wdGlvbiBjb25mbGljdHMpLlxuICAgICAqL1xuICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIHNob3c6IHRydWUsIC8vIEFsbCB3YXJuaW5nIGFyZSBzaG93blxuICAgICAgICBoaWRlOiBmYWxzZSwgLy8gTm8gd2FybmluZ3MgYXJlIHNob3duLCBvbmx5IHRoZSB0aHJvd24gZXJyb3JzXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgdGhlIHJ1bGVzIHRoYXQgY2FsY3VsYXRlIHRoZSBDU1MgY2xhc3MoZXMpIHRvIGFwcGx5IG9uIHRoZSBlbGVtZW50LCBiYXNlZCBvbiB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlLlxuICAgICAqIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjYWxsIGNhbGxiYWNrcyB3aGVuZXZlciB0aGUgYHJhd1ZhbHVlYCBpcyB1cGRhdGVkLlxuICAgICAqIEltcG9ydGFudDogYWxsIGNhbGxiYWNrcyBtdXN0IHJldHVybiBgbnVsbGAgaWYgbm8gcmFuZ2VzL3VzZXJEZWZpbmVkIGNsYXNzZXMgYXJlIHNlbGVjdGVkXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB7XG4gICAgICogICAgIHBvc2l0aXZlICAgOiAnYXV0b051bWVyaWMtcG9zaXRpdmUnLCAvLyBPciBgbnVsbGAgdG8gbm90IHVzZSBpdFxuICAgICAqICAgICBuZWdhdGl2ZSAgIDogJ2F1dG9OdW1lcmljLW5lZ2F0aXZlJyxcbiAgICAgKiAgICAgcmFuZ2VzICAgICA6IFtcbiAgICAgKiAgICAgICAgIHsgbWluOiAwLCBtYXg6IDI1LCBjbGFzczogJ2F1dG9OdW1lcmljLXJlZCcgfSxcbiAgICAgKiAgICAgICAgIHsgbWluOiAyNSwgbWF4OiA1MCwgY2xhc3M6ICdhdXRvTnVtZXJpYy1vcmFuZ2UnIH0sXG4gICAgICogICAgICAgICB7IG1pbjogNTAsIG1heDogNzUsIGNsYXNzOiAnYXV0b051bWVyaWMteWVsbG93JyB9LFxuICAgICAqICAgICAgICAgeyBtaW46IDc1LCBtYXg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBjbGFzczogJ2F1dG9OdW1lcmljLWdyZWVuJyB9LFxuICAgICAqICAgICBdLFxuICAgICAqICAgICB1c2VyRGVmaW5lZDogW1xuICAgICAqICAgICAgICAgLy8gSWYgJ2NsYXNzZXMnIGlzIGEgc3RyaW5nLCBzZXQgaXQgaWYgYHRydWVgLCByZW1vdmUgaXQgaWYgYGZhbHNlYFxuICAgICAqICAgICAgICAgeyBjYWxsYmFjazogcmF3VmFsdWUgPT4geyByZXR1cm4gdHJ1ZTsgfSwgY2xhc3NlczogJ3RoaXNJc1RydWUnIH0sXG4gICAgICogICAgICAgICAvLyBJZiAnY2xhc3NlcycgaXMgYW4gYXJyYXkgd2l0aCBvbmx5IDIgZWxlbWVudHMsIHNldCB0aGUgZmlyc3QgY2xhc3MgaWYgYHRydWVgLCB0aGUgc2Vjb25kIGlmIGBmYWxzZWBcbiAgICAgKiAgICAgICAgIHsgY2FsbGJhY2s6IHJhd1ZhbHVlID0+IHJhd1ZhbHVlICUgMiA9PT0gMCwgY2xhc3NlczogWydhdXRvTnVtZXJpYy1ldmVuJywgJ2F1dG9OdW1lcmljLW9kZCddIH0sXG4gICAgICogICAgICAgICAvLyBSZXR1cm4gb25seSBvbmUgaW5kZXggdG8gdXNlIG9uIHRoZSBgY2xhc3Nlc2AgYXJyYXkgKGhlcmUsICdjbGFzczMnKVxuICAgICAqICAgICAgICAgeyBjYWxsYmFjazogcmF3VmFsdWUgPT4geyByZXR1cm4gMjsgfSwgY2xhc3NlczogWydjbGFzczEnLCAnY2xhc3MyJywgJ2NsYXNzMyddIH0sXG4gICAgICogICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgaW5kZXhlcyB0byB1c2Ugb24gdGhlIGBjbGFzc2VzYCBhcnJheSAoaGVyZSwgJ2NsYXNzMScgYW5kICdjbGFzczMnKVxuICAgICAqICAgICAgICAgeyBjYWxsYmFjazogcmF3VmFsdWUgPT4geyByZXR1cm4gWzAsIDJdOyB9LCBjbGFzc2VzOiBbJ2NsYXNzMScsICdjbGFzczInLCAnY2xhc3MzJ10gfSxcbiAgICAgKiAgICAgICAgIC8vIElmICdjbGFzc2VzJyBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoZW4gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICogICAgICAgICB7IGNhbGxiYWNrOiBhbkVsZW1lbnQgPT4geyByZXR1cm4gYW5FbGVtZW50LmdldEZvcm1hdHRlZCgpOyB9IH0sXG4gICAgICogICAgIF0sXG4gICAgICogfVxuICAgICAqL1xuICAgIHN0eWxlUnVsZXMgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIG5vbmU6IG51bGwsXG4gICAgICAgIHBvc2l0aXZlTmVnYXRpdmUgOiB7XG4gICAgICAgICAgICBwb3NpdGl2ZTogJ2F1dG9OdW1lcmljLXBvc2l0aXZlJyxcbiAgICAgICAgICAgIG5lZ2F0aXZlOiAnYXV0b051bWVyaWMtbmVnYXRpdmUnLFxuICAgICAgICB9LFxuICAgICAgICByYW5nZTBUbzEwMFdpdGg0U3RlcHMgOiB7XG4gICAgICAgICAgICByYW5nZXMgICAgIDogW1xuICAgICAgICAgICAgICAgIHsgbWluOiAwLCAgbWF4OiAyNSwgIGNsYXNzOiAnYXV0b051bWVyaWMtcmVkJyB9LFxuICAgICAgICAgICAgICAgIHsgbWluOiAyNSwgbWF4OiA1MCwgIGNsYXNzOiAnYXV0b051bWVyaWMtb3JhbmdlJyB9LFxuICAgICAgICAgICAgICAgIHsgbWluOiA1MCwgbWF4OiA3NSwgIGNsYXNzOiAnYXV0b051bWVyaWMteWVsbG93JyB9LFxuICAgICAgICAgICAgICAgIHsgbWluOiA3NSwgbWF4OiAxMDAsIGNsYXNzOiAnYXV0b051bWVyaWMtZ3JlZW4nIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBldmVuT2RkIDoge1xuICAgICAgICAgICAgdXNlckRlZmluZWQ6IFtcbiAgICAgICAgICAgICAgICB7IGNhbGxiYWNrOiByYXdWYWx1ZSA9PiByYXdWYWx1ZSAlIDIgPT09IDAsIGNsYXNzZXM6IFsnYXV0b051bWVyaWMtZXZlbicsICdhdXRvTnVtZXJpYy1vZGQnXSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2VTbWFsbEFuZFplcm8gOiB7XG4gICAgICAgICAgICB1c2VyRGVmaW5lZDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHJhd1ZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZSA+PSAtMSAmJiByYXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIocmF3VmFsdWUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWUgPiAwICYmIHJhd1ZhbHVlIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAvLyBJbiBjYXNlIHRoZSByYXdWYWx1ZSBpcyBvdXRzaWRlIHRob3NlIHJhbmdlc1xuICAgICAgICAgICAgICAgICAgICB9LCBjbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0b051bWVyaWMtc21hbGwtbmVnYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG9OdW1lcmljLXplcm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG9OdW1lcmljLXNtYWxsLXBvc2l0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgLyogQWRkIGEgdGV4dCBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBlbGVtZW50IHZhbHVlLlxuICAgICAqIFRoaXMgc3VmZml4IHRleHQgY2FuIGhhdmUgYW55IGNoYXJhY3RlcnMgaW4gaXRzIHN0cmluZywgZXhjZXB0IG51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIG5lZ2F0aXZlL3Bvc2l0aXZlIHNpZ24uXG4gICAgICogRXhhbXBsZTogJyBkb2xsYXJzJ1xuICAgICAqL1xuICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgIG5vbmU6ICcnLFxuICAgICAgICBwZXJjZW50YWdlOiAnJScsXG4gICAgICAgIHBlcm1pbGxlICA6ICfigLAnLFxuICAgICAgICBiYXNpc1BvaW50IDogJ+KAsScsXG4gICAgfSxcblxuICAgIC8qIERlZmluZXMgaWYgdGhlIGVsZW1lbnQgdmFsdWUgc2hvdWxkIGJlIHVuZm9ybWF0dGVkIHdoZW4gdGhlIHVzZXIgaG92ZXIgaGlzIG1vdXNlIG92ZXIgaXQgd2hpbGUgaG9sZGluZyB0aGUgYEFsdGAga2V5LlxuICAgICAqIFdlIHJlZm9ybWF0IGJhY2sgYmVmb3JlIGFueXRoaW5nIGVsc2UgaWYgOlxuICAgICAqIC0gdGhlIHVzZXIgZm9jdXMgb24gdGhlIGVsZW1lbnQgYnkgdGFiYmluZyBvciBjbGlja2luZyBpbnRvIGl0LFxuICAgICAqIC0gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIGBBbHRgIGtleSwgYW5kXG4gICAgICogLSBpZiB3ZSBkZXRlY3QgYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgICAqXG4gICAgICogV2UgdW5mb3JtYXQgYWdhaW4gaWYgOlxuICAgICAqIC0gd2hpbGUgdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGVsZW1lbnQsIHRoZSB1c2VyIGhpdCBjdHJsIGFnYWluXG4gICAgICovXG4gICAgdW5mb3JtYXRPbkhvdmVyICAgICAgICAgICAgICA6IHtcbiAgICAgICAgdW5mb3JtYXQgICAgIDogdHJ1ZSxcbiAgICAgICAgZG9Ob3RVbmZvcm1hdDogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qIFJlbW92ZXMgdGhlIGZvcm1hdHRpbmcgYW5kIHVzZSB0aGUgcmF3IHZhbHVlIGluIGVhY2ggYXV0b051bWVyaWMgZWxlbWVudHMgb2YgdGhlIHBhcmVudCBmb3JtIGVsZW1lbnQsIG9uIHRoZSBmb3JtIGBzdWJtaXRgIGV2ZW50LlxuICAgICAqIFRoZSBvdXRwdXQgZm9ybWF0IGlzIGEgbnVtZXJpYyBzdHJpbmcgKG5ubm4ubm4gb3IgLW5ubm4ubm4pLlxuICAgICAqL1xuICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB7XG4gICAgICAgIHVuZm9ybWF0ICAgICAgICA6IHRydWUsXG4gICAgICAgIGtlZXBDdXJyZW50VmFsdWU6IGZhbHNlLFxuICAgIH0sXG5cbiAgICAvKiBUaGF0IG9wdGlvbiBpcyBsaW5rZWQgdG8gdGhlIGBtb2RpZnlWYWx1ZU9uV2hlZWxgIG9uZSBhbmQgd2lsbCBvbmx5IGJlIHVzZWQgaWYgdGhlIGxhdHRlciBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIFRoaXMgb3B0aW9uIHdpbGwgbW9kaWZ5IHRoZSB3aGVlbCBiZWhhdmlvciBhbmQgY2FuIGJlIHVzZWQgaW4gdHdvIHdheXMsIGVpdGhlciBieSBzZXR0aW5nIDpcbiAgICAgKiAtIGEgJ2ZpeGVkJyBzdGVwIHZhbHVlIChhIHBvc2l0aXZlIGZsb2F0IG9yIGludGVnZXIgbnVtYmVyIGAxMDAwYCksIG9yXG4gICAgICogLSB0aGUgYCdwcm9ncmVzc2l2ZSdgIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoZSAnZml4ZWQnIG1vZGUgYWx3YXlzIGluY3JlbWVudC9kZWNyZW1lbnQgdGhlIGVsZW1lbnQgdmFsdWUgYnkgdGhhdCBhbW91bnQsIHdoaWxlIHJlc3BlY3RpbmcgdGhlIGBtaW5pbXVtVmFsdWVgIGFuZCBgbWF4aW11bVZhbHVlYCBzZXR0aW5ncy5cbiAgICAgKiBUaGUgJ3Byb2dyZXNzaXZlJyBtb2RlIHdpbGwgaW5jcmVtZW50L2RlY3JlbWVudCB0aGUgZWxlbWVudCB2YWx1ZSBiYXNlZCBvbiBpdHMgY3VycmVudCB2YWx1ZS4gVGhlIGJpZ2dlciB0aGUgbnVtYmVyLCB0aGUgYmlnZ2VyIHRoZSBzdGVwLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKi9cbiAgICB3aGVlbFN0ZXAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICBwcm9ncmVzc2l2ZTogJ3Byb2dyZXNzaXZlJyxcbiAgICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BdXRvTnVtZXJpY09wdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericOptions = __webpack_require__(4);\n\nvar _AutoNumericOptions2 = _interopRequireDefault(_AutoNumericOptions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\n/**\n * The defaults options.\n * These can be overridden by the following methods:\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\n * - Options passed to the `update` method (ie. `anElement.update({ currencySymbol: ' €' });`), or simply during the initialization (ie. `new AutoNumeric(domElement, {options});`)\n */\n/**\n * Default settings for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n_AutoNumeric2.default.defaultSettings = {\n  allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.always,\n  caretPositionOnFocus: _AutoNumeric2.default.options.caretPositionOnFocus.doNoForceCaretPosition,\n  createLocalList: _AutoNumeric2.default.options.createLocalList.createList,\n  currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n  currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n  decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n  decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.none,\n  decimalPlacesOverride: _AutoNumeric2.default.options.decimalPlacesOverride.doNotOverride,\n  decimalPlacesShownOnFocus: _AutoNumeric2.default.options.decimalPlacesShownOnFocus.useDefault,\n  defaultValueOverride: _AutoNumeric2.default.options.defaultValueOverride.doNotOverride,\n  digitalGroupSpacing: _AutoNumeric2.default.options.digitalGroupSpacing.three,\n  digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n  emptyInputBehavior: _AutoNumeric2.default.options.emptyInputBehavior.focus,\n  failOnUnknownOption: _AutoNumeric2.default.options.failOnUnknownOption.ignore,\n  formatOnPageLoad: _AutoNumeric2.default.options.formatOnPageLoad.format,\n  historySize: _AutoNumeric2.default.options.historySize.medium,\n  isCancellable: _AutoNumeric2.default.options.isCancellable.cancellable,\n  leadingZero: _AutoNumeric2.default.options.leadingZero.deny,\n  maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions,\n  minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions,\n  modifyValueOnWheel: _AutoNumeric2.default.options.modifyValueOnWheel.modifyValue,\n  negativeBracketsTypeOnBlur: _AutoNumeric2.default.options.negativeBracketsTypeOnBlur.none,\n  negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.none,\n  noEventListeners: _AutoNumeric2.default.options.noEventListeners.addEvents,\n  noSeparatorOnFocus: _AutoNumeric2.default.options.noSeparatorOnFocus.withSeparator,\n  //TODO Shouldn't we use `truncate` as the default value?\n  onInvalidPaste: _AutoNumeric2.default.options.onInvalidPaste.error,\n  outputFormat: _AutoNumeric2.default.options.outputFormat.none,\n  overrideMinMaxLimits: _AutoNumeric2.default.options.overrideMinMaxLimits.doNotOverride,\n  readOnly: _AutoNumeric2.default.options.readOnly.readWrite,\n  roundingMethod: _AutoNumeric2.default.options.roundingMethod.halfUpSymmetric,\n  saveValueToSessionStorage: _AutoNumeric2.default.options.saveValueToSessionStorage.doNotSave,\n  scaleDecimalPlaces: _AutoNumeric2.default.options.scaleDecimalPlaces.doNotChangeDecimalPlaces,\n  scaleDivisor: _AutoNumeric2.default.options.scaleDivisor.doNotActivateTheScalingOption,\n  scaleSymbol: _AutoNumeric2.default.options.scaleSymbol.none,\n  selectNumberOnly: _AutoNumeric2.default.options.selectNumberOnly.selectNumbersOnly,\n  selectOnFocus: _AutoNumeric2.default.options.selectOnFocus.select,\n  serializeSpaces: _AutoNumeric2.default.options.serializeSpaces.plus,\n  showPositiveSign: _AutoNumeric2.default.options.showPositiveSign.hide,\n  showWarnings: _AutoNumeric2.default.options.showWarnings.show,\n  styleRules: _AutoNumeric2.default.options.styleRules.none,\n  suffixText: _AutoNumeric2.default.options.suffixText.none,\n  unformatOnHover: _AutoNumeric2.default.options.unformatOnHover.unformat,\n  unformatOnSubmit: _AutoNumeric2.default.options.unformatOnSubmit.keepCurrentValue,\n  wheelStep: _AutoNumeric2.default.options.wheelStep.progressive\n};\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNEZWZhdWx0U2V0dGluZ3MuanM/ZTg2YiJdLCJuYW1lcyI6WyJkZWZhdWx0U2V0dGluZ3MiLCJhbGxvd0RlY2ltYWxQYWRkaW5nIiwib3B0aW9ucyIsImFsd2F5cyIsImNhcmV0UG9zaXRpb25PbkZvY3VzIiwiZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbiIsImNyZWF0ZUxvY2FsTGlzdCIsImNyZWF0ZUxpc3QiLCJjdXJyZW5jeVN5bWJvbCIsIm5vbmUiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsInByZWZpeCIsImRlY2ltYWxDaGFyYWN0ZXIiLCJkb3QiLCJkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUiLCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJkb05vdE92ZXJyaWRlIiwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyIsInVzZURlZmF1bHQiLCJkZWZhdWx0VmFsdWVPdmVycmlkZSIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJ0aHJlZSIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJjb21tYSIsImVtcHR5SW5wdXRCZWhhdmlvciIsImZvY3VzIiwiZmFpbE9uVW5rbm93bk9wdGlvbiIsImlnbm9yZSIsImZvcm1hdE9uUGFnZUxvYWQiLCJmb3JtYXQiLCJoaXN0b3J5U2l6ZSIsIm1lZGl1bSIsImlzQ2FuY2VsbGFibGUiLCJjYW5jZWxsYWJsZSIsImxlYWRpbmdaZXJvIiwiZGVueSIsIm1heGltdW1WYWx1ZSIsInRlblRyaWxsaW9ucyIsIm1pbmltdW1WYWx1ZSIsIm1vZGlmeVZhbHVlT25XaGVlbCIsIm1vZGlmeVZhbHVlIiwibmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIiLCJuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCIsIm5vRXZlbnRMaXN0ZW5lcnMiLCJhZGRFdmVudHMiLCJub1NlcGFyYXRvck9uRm9jdXMiLCJ3aXRoU2VwYXJhdG9yIiwib25JbnZhbGlkUGFzdGUiLCJlcnJvciIsIm91dHB1dEZvcm1hdCIsIm92ZXJyaWRlTWluTWF4TGltaXRzIiwicmVhZE9ubHkiLCJyZWFkV3JpdGUiLCJyb3VuZGluZ01ldGhvZCIsImhhbGZVcFN5bW1ldHJpYyIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJkb05vdFNhdmUiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJkb05vdENoYW5nZURlY2ltYWxQbGFjZXMiLCJzY2FsZURpdmlzb3IiLCJkb05vdEFjdGl2YXRlVGhlU2NhbGluZ09wdGlvbiIsInNjYWxlU3ltYm9sIiwic2VsZWN0TnVtYmVyT25seSIsInNlbGVjdE51bWJlcnNPbmx5Iiwic2VsZWN0T25Gb2N1cyIsInNlbGVjdCIsInNlcmlhbGl6ZVNwYWNlcyIsInBsdXMiLCJzaG93UG9zaXRpdmVTaWduIiwiaGlkZSIsInNob3dXYXJuaW5ncyIsInNob3ciLCJzdHlsZVJ1bGVzIiwic3VmZml4VGV4dCIsInVuZm9ybWF0T25Ib3ZlciIsInVuZm9ybWF0IiwidW5mb3JtYXRPblN1Ym1pdCIsImtlZXBDdXJyZW50VmFsdWUiLCJ3aGVlbFN0ZXAiLCJwcm9ncmVzc2l2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUE2QkE7Ozs7QUFDQTs7Ozs7O0FBRUE7O0FBRUE7Ozs7OztBQWxDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0Esc0JBQVlBLGVBQVosR0FBOEI7QUFDMUJDLHVCQUErQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDRSxNQUQ3QztBQUUxQkMsd0JBQStCLHNCQUFZRixPQUFaLENBQW9CRSxvQkFBcEIsQ0FBeUNDLHNCQUY5QztBQUcxQkMsbUJBQStCLHNCQUFZSixPQUFaLENBQW9CSSxlQUFwQixDQUFvQ0MsVUFIekM7QUFJMUJDLGtCQUErQixzQkFBWU4sT0FBWixDQUFvQk0sY0FBcEIsQ0FBbUNDLElBSnhDO0FBSzFCQywyQkFBK0Isc0JBQVlSLE9BQVosQ0FBb0JRLHVCQUFwQixDQUE0Q0MsTUFMakQ7QUFNMUJDLG9CQUErQixzQkFBWVYsT0FB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LENBQW9Ca0UsZ0JBQXBCLENBQXFDQyxJQXZDMUM7QUF3QzFCQyxnQkFBK0Isc0JBQVlwRSxPQUFaLENBQW9Cb0UsWUFBcEIsQ0FBaUNDLElBeEN0QztBQXlDMUJDLGNBQStCLHNCQUFZdEUsT0FBWixDQUFvQnNFLFVBQXBCLENBQStCL0QsSUF6Q3BDO0FBMEMxQmdFLGNBQStCLHNCQUFZdkUsT0FBWixDQUFvQnVFLFVBQXBCLENBQStCaEUsSUExQ3BDO0FBMkMxQmlFLG1CQUErQixzQkFBWXhFLE9BQVosQ0FBb0J3RSxlQUFwQixDQUFvQ0MsUUEzQ3pDO0FBNEMxQkMsb0JBQStCLHNCQUFZMUUsT0FBWixDQUFvQjBFLGdCQUFwQixDQUFxQ0MsZ0JBNUMxQztBQTZDMUJDLGFBQStCLHNCQUFZNUUsT0FBWixDQUFvQjRFLFNBQXBCLENBQThCQztBQTdDbkMsQ0FBOUIsQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBhdXRvTnVtZXJpYy5qc1xuICogQGF1dGhvciBBbGV4YW5kcmUgQm9ubmVhdSA8YWxleGFuZHJlLmJvbm5lYXVAbGludXhmci5ldT5cbiAqIEBjb3B5cmlnaHQgwqkgMjAxNiBBbGV4YW5kcmUgQm9ubmVhdVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IEF1dG9OdW1lcmljIGZyb20gJy4vQXV0b051bWVyaWMnO1xuaW1wb3J0IEF1dG9OdW1lcmljT3B0aW9ucyBmcm9tICcuL0F1dG9OdW1lcmljT3B0aW9ucyc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogMCAqL1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0cyBvcHRpb25zLlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgKGllLiBgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1jdXJyZW5jeS1zeW1ib2w9XCIg4oKsXCI+YClcbiAqIC0gT3B0aW9ucyBwYXNzZWQgdG8gdGhlIGB1cGRhdGVgIG1ldGhvZCAoaWUuIGBhbkVsZW1lbnQudXBkYXRlKHsgY3VycmVuY3lTeW1ib2w6ICcg4oKsJyB9KTtgKSwgb3Igc2ltcGx5IGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb24gKGllLiBgbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIHtvcHRpb25zfSk7YClcbiAqL1xuQXV0b051bWVyaWMuZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIGFsbG93RGVjaW1hbFBhZGRpbmcgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcuYWx3YXlzLFxuICAgIGNhcmV0UG9zaXRpb25PbkZvY3VzICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRvTm9Gb3JjZUNhcmV0UG9zaXRpb24sXG4gICAgY3JlYXRlTG9jYWxMaXN0ICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3JlYXRlTG9jYWxMaXN0LmNyZWF0ZUxpc3QsXG4gICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wubm9uZSxcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlLm5vbmUsXG4gICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlLmRvTm90T3ZlcnJpZGUsXG4gICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cy51c2VEZWZhdWx0LFxuICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlLmRvTm90T3ZlcnJpZGUsXG4gICAgZGlnaXRhbEdyb3VwU3BhY2luZyAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZy50aHJlZSxcbiAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5mb2N1cyxcbiAgICBmYWlsT25Vbmtub3duT3B0aW9uICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uLmlnbm9yZSxcbiAgICBmb3JtYXRPblBhZ2VMb2FkICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkLmZvcm1hdCxcbiAgICBoaXN0b3J5U2l6ZSAgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5oaXN0b3J5U2l6ZS5tZWRpdW0sXG4gICAgaXNDYW5jZWxsYWJsZSAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuaXNDYW5jZWxsYWJsZS5jYW5jZWxsYWJsZSxcbiAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5kZW55LFxuICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnMsXG4gICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnRlblRyaWxsaW9ucyxcbiAgICBtb2RpZnlWYWx1ZU9uV2hlZWwgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5tb2RpZnlWYWx1ZU9uV2hlZWwubW9kaWZ5VmFsdWUsXG4gICAgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIubm9uZSxcbiAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lLFxuICAgIG5vRXZlbnRMaXN0ZW5lcnMgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm5vRXZlbnRMaXN0ZW5lcnMuYWRkRXZlbnRzLFxuICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cy53aXRoU2VwYXJhdG9yLFxuICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgdXNlIGB0cnVuY2F0ZWAgYXMgdGhlIGRlZmF1bHQgdmFsdWU/XG4gICAgb25JbnZhbGlkUGFzdGUgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuZXJyb3IsXG4gICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm5vbmUsXG4gICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMuZG9Ob3RPdmVycmlkZSxcbiAgICByZWFkT25seSAgICAgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5yZWFkT25seS5yZWFkV3JpdGUsXG4gICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZlVwU3ltbWV0cmljLFxuICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UuZG9Ob3RTYXZlLFxuICAgIHNjYWxlRGVjaW1hbFBsYWNlcyAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcy5kb05vdENoYW5nZURlY2ltYWxQbGFjZXMsXG4gICAgc2NhbGVEaXZpc29yICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc2NhbGVEaXZpc29yLmRvTm90QWN0aXZhdGVUaGVTY2FsaW5nT3B0aW9uLFxuICAgIHNjYWxlU3ltYm9sICAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNjYWxlU3ltYm9sLm5vbmUsXG4gICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc2VsZWN0TnVtYmVyT25seS5zZWxlY3ROdW1iZXJzT25seSxcbiAgICBzZWxlY3RPbkZvY3VzICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5zZWxlY3RPbkZvY3VzLnNlbGVjdCxcbiAgICBzZXJpYWxpemVTcGFjZXMgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5zZXJpYWxpemVTcGFjZXMucGx1cyxcbiAgICBzaG93UG9zaXRpdmVTaWduICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5zaG93UG9zaXRpdmVTaWduLmhpZGUsXG4gICAgc2hvd1dhcm5pbmdzICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc2hvd1dhcm5pbmdzLnNob3csXG4gICAgc3R5bGVSdWxlcyAgICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc3R5bGVSdWxlcy5ub25lLFxuICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnN1ZmZpeFRleHQubm9uZSxcbiAgICB1bmZvcm1hdE9uSG92ZXIgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy51bmZvcm1hdE9uSG92ZXIudW5mb3JtYXQsXG4gICAgdW5mb3JtYXRPblN1Ym1pdCAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdC5rZWVwQ3VycmVudFZhbHVlLFxuICAgIHdoZWVsU3RlcCAgICAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLndoZWVsU3RlcC5wcm9ncmVzc2l2ZSxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNEZWZhdWx0U2V0dGluZ3MuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Event list managed by AutoNumeric\n *\n * @type {{formatted: string, minRangeExceeded: string, maxRangeExceeded: string, native: {input: string, change: string}}}\n */\n_AutoNumeric2.default.events = {\n  formatted: 'autoNumeric:formatted',\n  minRangeExceeded: 'autoNumeric:minExceeded',\n  maxRangeExceeded: 'autoNumeric:maxExceeded',\n  native: {\n    input: 'input',\n    change: 'change'\n  }\n}; /**\n    * Options for autoNumeric.js\n    * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n    * @copyright © 2016 Alexandre Bonneau\n    *\n    * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n    *\n    * Permission is hereby granted, free of charge, to any person\n    * obtaining a copy of this software and associated documentation\n    * files (the \"Software\"), to deal in the Software without\n    * restriction, including without limitation the rights to use,\n    * copy, modify, merge, publish, distribute, sub license, and/or sell\n    * copies of the Software, and to permit persons to whom the\n    * Software is furnished to do so, subject to the following\n    * conditions:\n    *\n    * The above copyright notice and this permission notice shall be\n    * included in all copies or substantial portions of the Software.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    * OTHER DEALINGS IN THE SOFTWARE.\n    */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNFdmVudHMuanM/N2JkMyJdLCJuYW1lcyI6WyJldmVudHMiLCJmb3JtYXR0ZWQiLCJtaW5SYW5nZUV4Y2VlZGVkIiwibWF4UmFuZ2VFeGNlZWRlZCIsIm5hdGl2ZSIsImlucHV0IiwiY2hhbmdlIl0sIm1hcHBpbmdzIjoiOzs7OztBQTZCQTs7Ozs7O0FBRUE7Ozs7O0FBS0Esc0JBQVlBLE1BQVosR0FBcUI7QUFDakJDLGFBQWtCLHVCQUREO0FBRWpCQyxvQkFBa0IseUJBRkQ7QUFHakJDLG9CQUFrQix5QkFIRDtBQUlqQkMsVUFBa0I7QUFDZEMsV0FBUSxPQURNO0FBRWRDLFlBQVE7QUFGTTtBQUpELENBQXJCLEMsQ0FwQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT3B0aW9ucyBmb3IgYXV0b051bWVyaWMuanNcbiAqIEBhdXRob3IgQWxleGFuZHJlIEJvbm5lYXUgPGFsZXhhbmRyZS5ib25uZWF1QGxpbnV4ZnIuZXU+XG4gKiBAY29weXJpZ2h0IMKpIDIwMTYgQWxleGFuZHJlIEJvbm5lYXVcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBBdXRvTnVtZXJpYyBmcm9tICcuL0F1dG9OdW1lcmljJztcblxuLyoqXG4gKiBFdmVudCBsaXN0IG1hbmFnZWQgYnkgQXV0b051bWVyaWNcbiAqXG4gKiBAdHlwZSB7e2Zvcm1hdHRlZDogc3RyaW5nLCBtaW5SYW5nZUV4Y2VlZGVkOiBzdHJpbmcsIG1heFJhbmdlRXhjZWVkZWQ6IHN0cmluZywgbmF0aXZlOiB7aW5wdXQ6IHN0cmluZywgY2hhbmdlOiBzdHJpbmd9fX1cbiAqL1xuQXV0b051bWVyaWMuZXZlbnRzID0ge1xuICAgIGZvcm1hdHRlZCAgICAgICA6ICdhdXRvTnVtZXJpYzpmb3JtYXR0ZWQnLFxuICAgIG1pblJhbmdlRXhjZWVkZWQ6ICdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcsXG4gICAgbWF4UmFuZ2VFeGNlZWRlZDogJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyxcbiAgICBuYXRpdmUgICAgICAgICAgOiB7XG4gICAgICAgIGlucHV0IDogJ2lucHV0JyxcbiAgICAgICAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BdXRvTnVtZXJpY0V2ZW50cy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericHelper = __webpack_require__(3);\n\nvar _AutoNumericHelper2 = _interopRequireDefault(_AutoNumericHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Predefined options for the most common languages\n */\n/**\n * Pre-defined options for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n_AutoNumeric2.default.predefinedOptions = {\n    French: { // Français\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot, // or '\\u202f'\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n        decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.dot,\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.suffix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix\n    },\n    NorthAmerican: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.dollar,\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n    },\n    British: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.pound,\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.apostrophe,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.suffix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix\n    },\n    Japanese: { // 日本語\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.yen,\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n    },\n    Brazilian: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.real,\n        currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n        negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n    },\n    dotDecimalCharCommaSeparator: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot\n    },\n    commaDecimalCharDotSeparator: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n        decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.dot\n    },\n    integer: { minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillionsNoDecimals, maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillionsNoDecimals },\n    integerPos: { minimumValue: _AutoNumeric2.default.options.minimumValue.zero, maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillionsNoDecimals },\n    integerNeg: { minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillionsNoDecimals, maximumValue: _AutoNumeric2.default.options.maximumValue.zero },\n    float: { allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never },\n    floatPos: { allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never, minimumValue: _AutoNumeric2.default.options.minimumValue.zero, maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions },\n    floatNeg: { allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never, minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions, maximumValue: _AutoNumeric2.default.options.maximumValue.zero },\n    numeric: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.none\n    },\n    numericPos: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n        minimumValue: _AutoNumeric2.default.options.minimumValue.zero,\n        maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions\n    },\n    numericNeg: {\n        digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n        decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n        currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n        minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions,\n        maximumValue: _AutoNumeric2.default.options.maximumValue.zero\n    }\n};\n\n_AutoNumeric2.default.predefinedOptions.Spanish = _AutoNumeric2.default.predefinedOptions.French; // Español (idem French)\n_AutoNumeric2.default.predefinedOptions.Chinese = _AutoNumeric2.default.predefinedOptions.Japanese; // 中国語 (Chinese)\n\n_AutoNumeric2.default.predefinedOptions.euro = _AutoNumeric2.default.predefinedOptions.French;\n_AutoNumeric2.default.predefinedOptions.euroPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.French);\n_AutoNumeric2.default.predefinedOptions.euroPos.minimumValue = '0.00'; // Here we need to clone the initial object in order to be able to edit it without affecting the initial object\n_AutoNumeric2.default.predefinedOptions.euroNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.French);\n_AutoNumeric2.default.predefinedOptions.euroNeg.maximumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.euroNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\n_AutoNumeric2.default.predefinedOptions.euroSpace = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.French);\n_AutoNumeric2.default.predefinedOptions.euroSpace.digitGroupSeparator = _AutoNumeric2.default.options.digitGroupSeparator.normalSpace;\n_AutoNumeric2.default.predefinedOptions.euroSpacePos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.euroSpace);\n_AutoNumeric2.default.predefinedOptions.euroSpacePos.minimumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.euroSpaceNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.euroSpace);\n_AutoNumeric2.default.predefinedOptions.euroSpaceNeg.maximumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.euroSpaceNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\n_AutoNumeric2.default.predefinedOptions.percentageEU2dec = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.French);\n_AutoNumeric2.default.predefinedOptions.percentageEU2dec.currencySymbol = _AutoNumeric2.default.options.currencySymbol.none;\n_AutoNumeric2.default.predefinedOptions.percentageEU2dec.suffixText = '\\u202F' + _AutoNumeric2.default.options.suffixText.percentage;\n_AutoNumeric2.default.predefinedOptions.percentageEU2decPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageEU2dec);\n_AutoNumeric2.default.predefinedOptions.percentageEU2decPos.minimumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.percentageEU2decNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageEU2dec);\n_AutoNumeric2.default.predefinedOptions.percentageEU2decNeg.maximumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.percentageEU2decNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\n_AutoNumeric2.default.predefinedOptions.percentageEU3dec = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageEU2dec);\n_AutoNumeric2.default.predefinedOptions.percentageEU3dec.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageEU3dec.decimalPlacesOverride = 3;\n_AutoNumeric2.default.predefinedOptions.percentageEU3decPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageEU2decPos);\n_AutoNumeric2.default.predefinedOptions.percentageEU3decPos.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageEU3decPos.decimalPlacesOverride = 3;\n_AutoNumeric2.default.predefinedOptions.percentageEU3decNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageEU2decNeg);\n_AutoNumeric2.default.predefinedOptions.percentageEU3decNeg.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageEU3decNeg.decimalPlacesOverride = 3;\n\n_AutoNumeric2.default.predefinedOptions.dollar = _AutoNumeric2.default.predefinedOptions.NorthAmerican;\n_AutoNumeric2.default.predefinedOptions.dollarPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.NorthAmerican);\n_AutoNumeric2.default.predefinedOptions.dollarPos.minimumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.dollarNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.NorthAmerican);\n_AutoNumeric2.default.predefinedOptions.dollarNeg.maximumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.dollarNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n_AutoNumeric2.default.predefinedOptions.dollarNegBrackets = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.dollarNeg);\n_AutoNumeric2.default.predefinedOptions.dollarNegBrackets.negativeBracketsTypeOnBlur = _AutoNumeric2.default.options.negativeBracketsTypeOnBlur.parentheses;\n\n_AutoNumeric2.default.predefinedOptions.percentageUS2dec = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.NorthAmerican);\n_AutoNumeric2.default.predefinedOptions.percentageUS2dec.currencySymbol = _AutoNumeric2.default.options.currencySymbol.none;\n_AutoNumeric2.default.predefinedOptions.percentageUS2dec.suffixText = _AutoNumeric2.default.options.suffixText.percentage;\n_AutoNumeric2.default.predefinedOptions.percentageUS2decPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageUS2dec);\n_AutoNumeric2.default.predefinedOptions.percentageUS2decPos.minimumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.percentageUS2decNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageUS2dec);\n_AutoNumeric2.default.predefinedOptions.percentageUS2decNeg.maximumValue = '0.00';\n_AutoNumeric2.default.predefinedOptions.percentageUS2decNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\n_AutoNumeric2.default.predefinedOptions.percentageUS3dec = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageUS2dec);\n_AutoNumeric2.default.predefinedOptions.percentageUS3dec.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageUS3dec.decimalPlacesOverride = 3;\n_AutoNumeric2.default.predefinedOptions.percentageUS3decPos = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageUS2decPos);\n_AutoNumeric2.default.predefinedOptions.percentageUS3decPos.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageUS3decPos.decimalPlacesOverride = 3;\n_AutoNumeric2.default.predefinedOptions.percentageUS3decNeg = _AutoNumericHelper2.default.cloneObject(_AutoNumeric2.default.predefinedOptions.percentageUS2decNeg);\n_AutoNumeric2.default.predefinedOptions.percentageUS3decNeg.maximumValue = _AutoNumeric2.default.options.maximumValue.tenTrillions + '9';\n_AutoNumeric2.default.predefinedOptions.percentageUS3decNeg.decimalPlacesOverride = 3;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNQcmVkZWZpbmVkT3B0aW9ucy5qcz84ZWM5Il0sIm5hbWVzIjpbInByZWRlZmluZWRPcHRpb25zIiwiRnJlbmNoIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm9wdGlvbnMiLCJkb3QiLCJkZWNpbWFsQ2hhcmFjdGVyIiwiY29tbWEiLCJkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUiLCJjdXJyZW5jeVN5bWJvbCIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50Iiwic3VmZml4IiwibmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQiLCJwcmVmaXgiLCJOb3J0aEFtZXJpY2FuIiwiZG9sbGFyIiwicmlnaHQiLCJCcml0aXNoIiwicG91bmQiLCJTd2lzcyIsImFwb3N0cm9waGUiLCJKYXBhbmVzZSIsInllbiIsIkJyYXppbGlhbiIsInJlYWwiLCJkb3REZWNpbWFsQ2hhckNvbW1hU2VwYXJhdG9yIiwiY29tbWFEZWNpbWFsQ2hhckRvdFNlcGFyYXRvciIsImludGVnZXIiLCJtaW5pbXVtVmFsdWUiLCJ0ZW5UcmlsbGlvbnNOb0RlY2ltYWxzIiwibWF4aW11bVZhbHVlIiwiaW50ZWdlclBvcyIsInplcm8iLCJpbnRlZ2VyTmVnIiwiZmxvYXQiLCJhbGxvd0RlY2ltYWxQYWRkaW5nIiwibmV2ZXIiLCJmbG9hdFBvcyIsInRlblRyaWxsaW9ucyIsImZsb2F0TmVnIiwibnVtZXJpYyIsIm5vU2VwYXJhdG9yIiwibm9uZSIsIm51bWVyaWNQb3MiLCJudW1lcmljTmVnIiwiU3BhbmlzaCIsIkNoaW5lc2UiLCJldXJvIiwiZXVyb1BvcyIsImNsb25lT2JqZWN0IiwiZXVyb05lZyIsImV1cm9TcGFjZSIsIm5vcm1hbFNwYWNlIiwiZXVyb1NwYWNlUG9zIiwiZXVyb1NwYWNlTmVnIiwicGVyY2VudGFnZUVVMmRlYyIsInN1ZmZpeFRleHQiLCJwZXJjZW50YWdlIiwicGVyY2VudGFnZUVVMmRlY1BvcyIsInBlcmNlbnRhZ2VFVTJkZWNOZWciLCJwZXJjZW50YWdlRVUzZGVjIiwiZGVjaW1hbFBsYWNlc092ZXJyaWRlIiwicGVyY2VudGFnZUVVM2RlY1BvcyIsInBlcmNlbnRhZ2VFVTNkZWNOZWciLCJkb2xsYXJQb3MiLCJkb2xsYXJOZWciLCJkb2xsYXJOZWdCcmFja2V0cyIsIm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIiwicGFyZW50aGVzZXMiLCJwZXJjZW50YWdlVVMyZGVjIiwicGVyY2VudGFnZVVTMmRlY1BvcyIsInBlcmNlbnRhZ2VVUzJkZWNOZWciLCJwZXJjZW50YWdlVVMzZGVjIiwicGVyY2VudGFnZVVTM2RlY1BvcyIsInBlcmNlbnRhZ2VVUzNkZWNOZWciXSwibWFwcGluZ3MiOiI7Ozs7O0FBNkJBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7QUFoQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBLHNCQUFZQSxpQkFBWixHQUFnQztBQUM1QkMsWUFBZSxFQUFFO0FBQ2JDLDZCQUErQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDRSxHQUQ1RCxFQUNpRTtBQUM1RUMsMEJBQStCLHNCQUFZRixPQUFaLENBQW9CRSxnQkFBcEIsQ0FBcUNDLEtBRnpEO0FBR1hDLHFDQUErQixzQkFBWUosT0FBWixDQUFvQkksMkJBQXBCLENBQWdESCxHQUhwRTtBQUlYSSx3QkFBK0IsY0FKcEI7QUFLWEMsaUNBQStCLHNCQUFZTixPQUFaLENBQW9CTSx1QkFBcEIsQ0FBNENDLE1BTGhFO0FBTVhDLHVDQUErQixzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtEQztBQU50RSxLQURhO0FBUzVCQyxtQkFBZTtBQUNYWCw2QkFBK0Isc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q0ksS0FENUQ7QUFFWEQsMEJBQStCLHNCQUFZRixPQUFaLENBQW9CRSxnQkFBcEIsQ0FBcUNELEdBRnpEO0FBR1hJLHdCQUErQixzQkFBWUwsT0FBWixDQUFvQkssY0FBcEIsQ0FBbUNNLE1BSHZEO0FBSVhMLGlDQUErQixzQkFBWU4sT0FBWixDQUFvQk0sdUJBQXBCLENBQTRDRyxNQUpoRTtBQUtYRCx1Q0FBK0Isc0JBQVlSLE9BQVosQ0FBb0JRLDZCQUFwQixDQUFrREk7QUFMdEUsS0FUYTtBQWdCNUJDLGFBQWU7QUFDWGQsNkJBQStCLHNCQUFZQyxPQUFaLENBQW9CRCxtQkFBcEIsQ0FBd0NJLEtBRDVEO0FBRVhELDBCQUErQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZ6RDtBQUdYSSx3QkFBK0Isc0JBQVlMLE9BQVosQ0FBb0JLLGNBQXBCLENBQW1DUyxLQUh2RDtBQUlYUixpQ0FBK0Isc0JBQVlOLE9BQVosQ0FBb0JNLHVCQUFwQixDQUE0Q0csTUFKaEU7QUFLWEQsdUNBQStCLHNCQUFZUixPQUFaLENBQW9CUSw2QkFBcEIsQ0FBa0RJO0FBTHRFLEtBaEJhO0FBdUI1QkcsV0FBZSxFQUFFO0FBQ2JoQiw2QkFBK0Isc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q2lCLFVBRDVEO0FBRVhkLDBCQUErQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZ6RDtBQUdYSSx3QkFBK0IsV0FIcEI7QUFJWEMsaUNBQStCLHNCQUFZTixPQUFaLENBQW9CTSx1QkFBcEIsQ0FBNENDLE1BSmhFO0FBS1hDLHVDQUErQixzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtEQztBQUx0RSxLQXZCYTtBQThCNUJRLGNBQWUsRUFBRTtBQUNibEIsNkJBQStCLHNCQUFZQyxPQUFaLENBQW9CRCxtQkFBcEIsQ0FBd0NJLEtBRDVEO0FBRVhELDBCQUErQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZ6RDtBQUdYSSx3QkFBK0Isc0JBQVlMLE9BQVosQ0FBb0JLLGNBQXBCLENBQW1DYSxHQUh2RDtBQUlYWixpQ0FBK0Isc0JBQVlOLE9BQVosQ0FBb0JNLHVCQUFwQixDQUE0Q0csTUFKaEU7QUFLWEQsdUNBQStCLHNCQUFZUixPQUFaLENBQW9CUSw2QkFBcEIsQ0FBa0RJO0FBTHRFLEtBOUJhO0FBcUM1Qk8sZUFBaUI7QUFDYnBCLDZCQUErQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDRSxHQUQxRDtBQUViQywwQkFBK0Isc0JBQVlGLE9BQVosQ0FBb0JFLGdCQUFwQixDQUFxQ0MsS0FGdkQ7QUFHYkUsd0JBQStCLHNCQUFZTCxPQUFaLENBQW9CSyxjQUFwQixDQUFtQ2UsSUFIckQ7QUFJYmQsaUNBQStCLHNCQUFZTixPQUFaLENBQW9CTSx1QkFBcEIsQ0FBNENHLE1BSjlEO0FBS2JELHVDQUErQixzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtESTtBQUxwRSxLQXJDVztBQTRDNUJTLGtDQUE4QjtBQUMxQnRCLDZCQUErQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDSSxLQUQ3QztBQUUxQkQsMEJBQStCLHNCQUFZRixPQUFaLENBQW9CRSxnQkFBcEIsQ0FBcUNEO0FBRjFDLEtBNUNGO0FBZ0Q1QnFCLGtDQUE4QjtBQUMxQnZCLDZCQUErQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDRSxHQUQ3QztBQUUxQkMsMEJBQStCLHNCQUFZRixPQUFaLENBQW9CRSxnQkFBcEIsQ0FBcUNDLEtBRjFDO0FBRzFCQyxxQ0FBK0Isc0JBQVlKLE9BQVosQ0FBb0JJLDJCQUFwQixDQUFnREg7QUFIckQsS0FoREY7QUFxRDVCc0IsYUFBWSxFQUFFQyxjQUFjLHNCQUFZeEIsT0FBWixDQUFvQndCLFlBQXBCLENBQWlDQyxzQkFBakQsRUFBeUVDLGNBQWMsc0JBQVkxQixPQUFaLENBQW9CMEIsWUFBcEIsQ0FBaUNELHNCQUF4SCxFQXJEZ0I7QUFzRDVCRSxnQkFBWSxFQUFFSCxjQUFjLHNCQUFZeEIsT0FBWixDQUFvQndCLFlBQXBCLENBQWlDSSxJQUFqRCxFQUF5RUYsY0FBYyxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ0Qsc0JBQXhILEVBdERnQjtBQXVENUJJLGdCQUFZLEVBQUVMLGNBQWMsc0JBQVl4QixPQUFaLENBQW9Cd0IsWUFBcEIsQ0FBaUNDLHNCQUFqRCxFQUF5RUMsY0FBYyxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ0UsSUFBeEgsRUF2RGdCO0FBd0Q1QkUsV0FBWSxFQUFFQyxxQkFBcUIsc0JBQVkvQixPQUFaLENBQW9CK0IsbUJBQXBCLENBQXdDQyxLQUEvRCxFQXhEZ0I7QUF5RDVCQyxjQUFZLEVBQUVGLHFCQUFxQixzQkFBWS9CLE9BQVosQ0FBb0IrQixtQkFBcEIsQ0FBd0NDLEtBQS9ELEVBQXNFUixjQUFjLHNCQUFZeEIsT0FBWixDQUFvQndCLFlBQXBCLENBQWlDSSxJQUFySCxFQUFtSUYsY0FBYyxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ1EsWUFBbEwsRUF6RGdCO0FBMEQ1QkMsY0FBWSxFQUFFSixxQkFBcUIsc0JBQVkvQixPQUFaLENBQW9CK0IsbUJBQXBCLENBQXdDQyxLQUEvRCxFQUFzRVIsY0FBYyxzQkFBWXhCLE9BQVosQ0FBb0J3QixZQUFwQixDQUFpQ1UsWUFBckgsRUFBbUlSLGNBQWMsc0JBQVkxQixPQUFaLENBQW9CMEIsWUFBcEIsQ0FBaUNFLElBQWxMLEVBMURnQjtBQTJENUJRLGFBQVM7QUFDTHJDLDZCQUFxQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDc0MsV0FEeEQ7QUFFTG5DLDBCQUFxQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZyRDtBQUdMSSx3QkFBcUIsc0JBQVlMLE9BQVosQ0FBb0JLLGNBQXBCLENBQW1DaUM7QUFIbkQsS0EzRG1CO0FBZ0U1QkMsZ0JBQVk7QUFDUnhDLDZCQUFxQixzQkFBWUMsT0FBWixDQUFvQkQsbUJBQXBCLENBQXdDc0MsV0FEckQ7QUFFUm5DLDBCQUFxQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZsRDtBQUdSSSx3QkFBcUIsc0JBQVlMLE9BQVosQ0FBb0JLLGNBQXBCLENBQW1DaUMsSUFIaEQ7QUFJUmQsc0JBQXFCLHNCQUFZeEIsT0FBWixDQUFvQndCLFlBQXBCLENBQWlDSSxJQUo5QztBQUtSRixzQkFBcUIsc0JBQVkxQixPQUFaLENBQW9CMEIsWUFBcEIsQ0FBaUNRO0FBTDlDLEtBaEVnQjtBQXVFNUJNLGdCQUFZO0FBQ1J6Qyw2QkFBcUIsc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q3NDLFdBRHJEO0FBRVJuQywwQkFBcUIsc0JBQVlGLE9BQVosQ0FBb0JFLGdCQUFwQixDQUFxQ0QsR0FGbEQ7QUFHUkksd0JBQXFCLHNCQUFZTCxPQUFaLENBQW9CSyxjQUFwQixDQUFtQ2lDLElBSGhEO0FBSVJkLHNCQUFxQixzQkFBWXhCLE9BQVosQ0FBb0J3QixZQUFwQixDQUFpQ1UsWUFKOUM7QUFLUlIsc0JBQXFCLHNCQUFZMUIsT0FBWixDQUFvQjBCLFlBQXBCLENBQWlDRTtBQUw5QztBQXZFZ0IsQ0FBaEM7O0FBZ0ZBLHNCQUFZL0IsaUJBQVosQ0FBOEI0QyxPQUE5QixHQUF3QyxzQkFBWTVDLGlCQUFaLENBQThCQyxNQUF0RSxDLENBQThFO0FBQzlFLHNCQUFZRCxpQkFBWixDQUE4QjZDLE9BQTlCLEdBQXdDLHNCQUFZN0MsaUJBQVosQ0FBOEJvQixRQUF0RSxDLENBQWdGOztBQUVoRixzQkFBWXBCLGlCQUFaLENBQThCOEMsSUFBOUIsR0FBcUMsc0JBQVk5QyxpQkFBWixDQUE4QkMsTUFBbkU7QUFDQSxzQkFBWUQsaUJBQVosQ0FBOEIrQyxPQUE5QixHQUF3Qyw0QkFBa0JDLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJDLE1BQTVELENBQXhDO0FBQ0Esc0JBQVlELGlCQUFaLENBQThCK0MsT0FBOUIsQ0FBc0NwQixZQUF0QyxHQUFxRCxNQUFyRCxDLENBQTZEO0FBQzdELHNCQUFZM0IsaUJBQVosQ0FBOEJpRCxPQUE5QixHQUF3Qyw0QkFBa0JELFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJDLE1BQTVELENBQXhDO0FBQ0Esc0JBQVlELGlCQUFaLENBQThCaUQsT0FBOUIsQ0FBc0NwQixZQUF0QyxHQUFxRCxNQUFyRDtBQUNBLHNCQUFZN0IsaUJBQVosQ0FBOEJpRCxPQUE5QixDQUFzQ3RDLDZCQUF0QyxHQUFzRSxzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtEQyxNQUF4SDs7QUFFQSxzQkFBWVosaUJBQVosQ0FBOEJrRCxTQUE5QixHQUEwQyw0QkFBa0JGLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJDLE1BQTVELENBQTFDO0FBQ0Esc0JBQVlELGlCQUFaLENBQThCa0QsU0FBOUIsQ0FBd0NoRCxtQkFBeEMsR0FBOEQsc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q2lELFdBQXRHO0FBQ0Esc0JBQVluRCxpQkFBWixDQUE4Qm9ELFlBQTlCLEdBQTZDLDRCQUFrQkosV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QmtELFNBQTVELENBQTdDO0FBQ0Esc0JBQVlsRCxpQkFBWixDQUE4Qm9ELFlBQTlCLENBQTJDekIsWUFBM0MsR0FBMEQsTUFBMUQ7QUFDQSxzQkFBWTNCLGlCQUFaLENBQThCcUQsWUFBOUIsR0FBNkMsNEJBQWtCTCxXQUFsQixDQUE4QixzQkFBWWhELGlCQUFaLENBQThCa0QsU0FBNUQsQ0FBN0M7QUFDQSxzQkFBWWxELGlCQUFaLENBQThCcUQsWUFBOUIsQ0FBMkN4QixZQUEzQyxHQUEwRCxNQUExRDtBQUNBLHNCQUFZN0IsaUJBQVosQ0FBOEJxRCxZQUE5QixDQUEyQzFDLDZCQUEzQyxHQUEyRSxzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtEQyxNQUE3SDs7QUFFQSxzQkFBWVosaUJBQVosQ0FBOEJzRCxnQkFBOUIsR0FBaUQsNEJBQWtCTixXQUFsQixDQUE4QixzQkFBWWhELGlCQUFaLENBQThCQyxNQUE1RCxDQUFqRDtBQUNBLHNCQUFZRCxpQkFBWixDQUE4QnNELGdCQUE5QixDQUErQzlDLGNBQS9DLEdBQWdFLHNCQUFZTCxPQUFaLENBQW9CSyxjQUFwQixDQUFtQ2lDLElBQW5HO0FBQ0Esc0JBQVl6QyxpQkFBWixDQUE4QnNELGdCQUE5QixDQUErQ0MsVUFBL0MsY0FBcUUsc0JBQVlwRCxPQUFaLENBQW9Cb0QsVUFBcEIsQ0FBK0JDLFVBQXBHO0FBQ0Esc0JBQVl4RCxpQkFBWixDQUE4QnlELG1CQUE5QixHQUFvRCw0QkFBa0JULFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJzRCxnQkFBNUQsQ0FBcEQ7QUFDQSxzQkFBWXRELGlCQUFaLENBQThCeUQsbUJBQTlCLENBQWtEOUIsWUFBbEQsR0FBaUUsTUFBakU7QUFDQSxzQkFBWTNCLGlCQUFaLENBQThCMEQsbUJBQTlCLEdBQW9ELDRCQUFrQlYsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QnNELGdCQUE1RCxDQUFwRDtBQUNBLHNCQUFZdEQsaUJBQVosQ0FBOEIwRCxtQkFBOUIsQ0FBa0Q3QixZQUFsRCxHQUFpRSxNQUFqRTtBQUNBLHNCQUFZN0IsaUJBQVosQ0FBOEIwRCxtQkFBOUIsQ0FBa0QvQyw2QkFBbEQsR0FBa0Ysc0JBQVlSLE9BQVosQ0FBb0JRLDZCQUFwQixDQUFrREMsTUFBcEk7O0FBRUEsc0JBQVlaLGlCQUFaLENBQThCMkQsZ0JBQTlCLEdBQWlELDRCQUFrQlgsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QnNELGdCQUE1RCxDQUFqRDtBQUNBLHNCQUFZdEQsaUJBQVosQ0FBOEIyRCxnQkFBOUIsQ0FBK0M5QixZQUEvQyxHQUFpRSxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ1EsWUFBbEc7QUFDQSxzQkFBWXJDLGlCQUFaLENBQThCMkQsZ0JBQTlCLENBQStDQyxxQkFBL0MsR0FBdUUsQ0FBdkU7QUFDQSxzQkFBWTVELGlCQUFaLENBQThCNkQsbUJBQTlCLEdBQW9ELDRCQUFrQmIsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QnlELG1CQUE1RCxDQUFwRDtBQUNBLHNCQUFZekQsaUJBQVosQ0FBOEI2RCxtQkFBOUIsQ0FBa0RoQyxZQUFsRCxHQUFvRSxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ1EsWUFBckc7QUFDQSxzQkFBWXJDLGlCQUFaLENBQThCNkQsbUJBQTlCLENBQWtERCxxQkFBbEQsR0FBMEUsQ0FBMUU7QUFDQSxzQkFBWTVELGlCQUFaLENBQThCOEQsbUJBQTlCLEdBQW9ELDRCQUFrQmQsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QjBELG1CQUE1RCxDQUFwRDtBQUNBLHNCQUFZMUQsaUJBQVosQ0FBOEI4RCxtQkFBOUIsQ0FBa0RqQyxZQUFsRCxHQUFvRSxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ1EsWUFBckc7QUFDQSxzQkFBWXJDLGlCQUFaLENBQThCOEQsbUJBQTlCLENBQWtERixxQkFBbEQsR0FBMEUsQ0FBMUU7O0FBRUEsc0JBQVk1RCxpQkFBWixDQUE4QmMsTUFBOUIsR0FBdUMsc0JBQVlkLGlCQUFaLENBQThCYSxhQUFyRTtBQUNBLHNCQUFZYixpQkFBWixDQUE4QitELFNBQTlCLEdBQTBDLDRCQUFrQmYsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QmEsYUFBNUQsQ0FBMUM7QUFDQSxzQkFBWWIsaUJBQVosQ0FBOEIrRCxTQUE5QixDQUF3Q3BDLFlBQXhDLEdBQXVELE1BQXZEO0FBQ0Esc0JBQVkzQixpQkFBWixDQUE4QmdFLFNBQTlCLEdBQTBDLDRCQUFrQmhCLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJhLGFBQTVELENBQTFDO0FBQ0Esc0JBQVliLGlCQUFaLENBQThCZ0UsU0FBOUIsQ0FBd0NuQyxZQUF4QyxHQUF1RCxNQUF2RDtBQUNBLHNCQUFZN0IsaUJBQVosQ0FBOEJnRSxTQUE5QixDQUF3Q3JELDZCQUF4QyxHQUF3RSxzQkFBWVIsT0FBWixDQUFvQlEsNkJBQXBCLENBQWtEQyxNQUExSDtBQUNBLHNCQUFZWixpQkFBWixDQUE4QmlFLGlCQUE5QixHQUFrRCw0QkFBa0JqQixXQUFsQixDQUE4QixzQkFBWWhELGlCQUFaLENBQThCZ0UsU0FBNUQsQ0FBbEQ7QUFDQSxzQkFBWWhFLGlCQUFaLENBQThCaUUsaUJBQTlCLENBQWdEQywwQkFBaEQsR0FBNkUsc0JBQVkvRCxPQUFaLENBQW9CK0QsMEJBQXBCLENBQStDQyxXQUE1SDs7QUFFQSxzQkFBWW5FLGlCQUFaLENBQThCb0UsZ0JBQTlCLEdBQWlELDRCQUFrQnBCLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJhLGFBQTVELENBQWpEO0FBQ0Esc0JBQVliLGlCQUFaLENBQThCb0UsZ0JBQTlCLENBQStDNUQsY0FBL0MsR0FBZ0Usc0JBQVlMLE9BQVosQ0FBb0JLLGNBQXBCLENBQW1DaUMsSUFBbkc7QUFDQSxzQkFBWXpDLGlCQUFaLENBQThCb0UsZ0JBQTlCLENBQStDYixVQUEvQyxHQUE0RCxzQkFBWXBELE9BQVosQ0FBb0JvRCxVQUFwQixDQUErQkMsVUFBM0Y7QUFDQSxzQkFBWXhELGlCQUFaLENBQThCcUUsbUJBQTlCLEdBQW9ELDRCQUFrQnJCLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJvRSxnQkFBNUQsQ0FBcEQ7QUFDQSxzQkFBWXBFLGlCQUFaLENBQThCcUUsbUJBQTlCLENBQWtEMUMsWUFBbEQsR0FBaUUsTUFBakU7QUFDQSxzQkFBWTNCLGlCQUFaLENBQThCc0UsbUJBQTlCLEdBQW9ELDRCQUFrQnRCLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJvRSxnQkFBNUQsQ0FBcEQ7QUFDQSxzQkFBWXBFLGlCQUFaLENBQThCc0UsbUJBQTlCLENBQWtEekMsWUFBbEQsR0FBaUUsTUFBakU7QUFDQSxzQkFBWTdCLGlCQUFaLENBQThCc0UsbUJBQTlCLENBQWtEM0QsNkJBQWxELEdBQWtGLHNCQUFZUixPQUFaLENBQW9CUSw2QkFBcEIsQ0FBa0RDLE1BQXBJOztBQUVBLHNCQUFZWixpQkFBWixDQUE4QnVFLGdCQUE5QixHQUFpRCw0QkFBa0J2QixXQUFsQixDQUE4QixzQkFBWWhELGlCQUFaLENBQThCb0UsZ0JBQTVELENBQWpEO0FBQ0Esc0JBQVlwRSxpQkFBWixDQUE4QnVFLGdCQUE5QixDQUErQzFDLFlBQS9DLEdBQWlFLHNCQUFZMUIsT0FBWixDQUFvQjBCLFlBQXBCLENBQWlDUSxZQUFsRztBQUNBLHNCQUFZckMsaUJBQVosQ0FBOEJ1RSxnQkFBOUIsQ0FBK0NYLHFCQUEvQyxHQUF1RSxDQUF2RTtBQUNBLHNCQUFZNUQsaUJBQVosQ0FBOEJ3RSxtQkFBOUIsR0FBb0QsNEJBQWtCeEIsV0FBbEIsQ0FBOEIsc0JBQVloRCxpQkFBWixDQUE4QnFFLG1CQUE1RCxDQUFwRDtBQUNBLHNCQUFZckUsaUJBQVosQ0FBOEJ3RSxtQkFBOUIsQ0FBa0QzQyxZQUFsRCxHQUFvRSxzQkFBWTFCLE9BQVosQ0FBb0IwQixZQUFwQixDQUFpQ1EsWUFBckc7QUFDQSxzQkFBWXJDLGlCQUFaLENBQThCd0UsbUJBQTlCLENBQWtEWixxQkFBbEQsR0FBMEUsQ0FBMUU7QUFDQSxzQkFBWTVELGlCQUFaLENBQThCeUUsbUJBQTlCLEdBQW9ELDRCQUFrQnpCLFdBQWxCLENBQThCLHNCQUFZaEQsaUJBQVosQ0FBOEJzRSxtQkFBNUQsQ0FBcEQ7QUFDQSxzQkFBWXRFLGlCQUFaLENBQThCeUUsbUJBQTlCLENBQWtENUMsWUFBbEQsR0FBb0Usc0JBQVkxQixPQUFaLENBQW9CMEIsWUFBcEIsQ0FBaUNRLFlBQXJHO0FBQ0Esc0JBQVlyQyxpQkFBWixDQUE4QnlFLG1CQUE5QixDQUFrRGIscUJBQWxELEdBQTBFLENBQTFFLEMiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJlLWRlZmluZWQgb3B0aW9ucyBmb3IgYXV0b051bWVyaWMuanNcbiAqIEBhdXRob3IgQWxleGFuZHJlIEJvbm5lYXUgPGFsZXhhbmRyZS5ib25uZWF1QGxpbnV4ZnIuZXU+XG4gKiBAY29weXJpZ2h0IMKpIDIwMTYgQWxleGFuZHJlIEJvbm5lYXVcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBBdXRvTnVtZXJpYyBmcm9tICcuL0F1dG9OdW1lcmljJztcbmltcG9ydCBBdXRvTnVtZXJpY0hlbHBlciBmcm9tICcuL0F1dG9OdW1lcmljSGVscGVyJztcblxuLyoqXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcbiAqL1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMgPSB7XG4gICAgRnJlbmNoICAgICAgIDogeyAvLyBGcmFuw6dhaXNcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5kb3QsIC8vIG9yICdcXHUyMDJmJ1xuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmNvbW1hLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUuZG90LFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogJ1xcdTIwMmbigqwnLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgsXG4gICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeCxcbiAgICB9LFxuICAgIE5vcnRoQW1lcmljYW46IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5jb21tYSxcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLmRvbGxhcixcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4LFxuICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodCxcbiAgICB9LFxuICAgIEJyaXRpc2ggICAgICA6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5jb21tYSxcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLnBvdW5kLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0LFxuICAgIH0sXG4gICAgU3dpc3MgICAgICAgIDogeyAvLyBTdWlzc2VcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5hcG9zdHJvcGhlLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6ICdcXHUyMDJmQ0hGJyxcbiAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4LFxuICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXgsXG4gICAgfSxcbiAgICBKYXBhbmVzZSAgICAgOiB7IC8vIOaXpeacrOiqnlxuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wueWVuLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0LFxuICAgIH0sXG4gICAgQnJhemlsaWFuICAgICAgOiB7XG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuZG90LFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmNvbW1hLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbC5yZWFsLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0LFxuICAgIH0sXG4gICAgZG90RGVjaW1hbENoYXJDb21tYVNlcGFyYXRvcjoge1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICB9LFxuICAgIGNvbW1hRGVjaW1hbENoYXJEb3RTZXBhcmF0b3I6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5kb3QsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuY29tbWEsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZS5kb3QsXG4gICAgfSxcbiAgICBpbnRlZ2VyOiAgICB7IG1pbmltdW1WYWx1ZTogQXV0b051bWVyaWMub3B0aW9ucy5taW5pbXVtVmFsdWUudGVuVHJpbGxpb25zTm9EZWNpbWFscywgbWF4aW11bVZhbHVlOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnNOb0RlY2ltYWxzIH0sXG4gICAgaW50ZWdlclBvczogeyBtaW5pbXVtVmFsdWU6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnplcm8gICAgICAgICAgICAgICAgICAsIG1heGltdW1WYWx1ZTogQXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUudGVuVHJpbGxpb25zTm9EZWNpbWFscyB9LFxuICAgIGludGVnZXJOZWc6IHsgbWluaW11bVZhbHVlOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1pbmltdW1WYWx1ZS50ZW5UcmlsbGlvbnNOb0RlY2ltYWxzLCBtYXhpbXVtVmFsdWU6IEF1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnplcm8gICAgICAgICAgICAgICAgICAgfSxcbiAgICBmbG9hdDogICAgICB7IGFsbG93RGVjaW1hbFBhZGRpbmc6IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5uZXZlciB9LFxuICAgIGZsb2F0UG9zOiAgIHsgYWxsb3dEZWNpbWFsUGFkZGluZzogQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyLCBtaW5pbXVtVmFsdWU6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnplcm8gICAgICAgICwgbWF4aW11bVZhbHVlOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnMgfSxcbiAgICBmbG9hdE5lZzogICB7IGFsbG93RGVjaW1hbFBhZGRpbmc6IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5uZXZlciwgbWluaW11bVZhbHVlOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1pbmltdW1WYWx1ZS50ZW5UcmlsbGlvbnMsIG1heGltdW1WYWx1ZTogQXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUuemVybyAgICAgICAgIH0sXG4gICAgbnVtZXJpYzoge1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3Iubm9TZXBhcmF0b3IsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wubm9uZSxcbiAgICB9LFxuICAgIG51bWVyaWNQb3M6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vU2VwYXJhdG9yLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuZG90LFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLm5vbmUsXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnplcm8sXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnRlblRyaWxsaW9ucyxcbiAgICB9LFxuICAgIG51bWVyaWNOZWc6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vU2VwYXJhdG9yLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuZG90LFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLm5vbmUsXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnRlblRyaWxsaW9ucyxcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUuemVybyxcbiAgICB9LFxufTtcblxuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuU3BhbmlzaCA9IEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLkZyZW5jaDsgLy8gRXNwYcOxb2wgKGlkZW0gRnJlbmNoKVxuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuQ2hpbmVzZSA9IEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLkphcGFuZXNlOyAvLyDkuK3lm73oqp4gKENoaW5lc2UpXG5cbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm8gPSBBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5GcmVuY2g7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5ldXJvUG9zID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuRnJlbmNoKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9Qb3MubWluaW11bVZhbHVlID0gJzAuMDAnOyAvLyBIZXJlIHdlIG5lZWQgdG8gY2xvbmUgdGhlIGluaXRpYWwgb2JqZWN0IGluIG9yZGVyIHRvIGJlIGFibGUgdG8gZWRpdCBpdCB3aXRob3V0IGFmZmVjdGluZyB0aGUgaW5pdGlhbCBvYmplY3RcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9OZWcgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5GcmVuY2gpO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuZXVyb05lZy5tYXhpbXVtVmFsdWUgPSAnMC4wMCc7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5ldXJvTmVnLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg7XG5cbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9TcGFjZSA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLkZyZW5jaCk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5ldXJvU3BhY2UuZGlnaXRHcm91cFNlcGFyYXRvciA9IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5ub3JtYWxTcGFjZTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9TcGFjZVBvcyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9TcGFjZSk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5ldXJvU3BhY2VQb3MubWluaW11bVZhbHVlID0gJzAuMDAnO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuZXVyb1NwYWNlTmVnID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuZXVyb1NwYWNlKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmV1cm9TcGFjZU5lZy5tYXhpbXVtVmFsdWUgPSAnMC4wMCc7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5ldXJvU3BhY2VOZWcubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDtcblxuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVMmRlYyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLkZyZW5jaCk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUyZGVjLmN1cnJlbmN5U3ltYm9sID0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbC5ub25lO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVMmRlYy5zdWZmaXhUZXh0ID0gYFxcdTIwMmYke0F1dG9OdW1lcmljLm9wdGlvbnMuc3VmZml4VGV4dC5wZXJjZW50YWdlfWA7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUyZGVjUG9zID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVMmRlYyk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUyZGVjUG9zLm1pbmltdW1WYWx1ZSA9ICcwLjAwJztcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTJkZWNOZWcgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUyZGVjKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTJkZWNOZWcubWF4aW11bVZhbHVlID0gJzAuMDAnO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVMmRlY05lZy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4O1xuXG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUzZGVjID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVMmRlYyk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUzZGVjLm1heGltdW1WYWx1ZSA9IGAke0F1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnRlblRyaWxsaW9uc305YDtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTNkZWMuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gMztcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTNkZWNQb3MgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUyZGVjUG9zKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTNkZWNQb3MubWF4aW11bVZhbHVlID0gYCR7QXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUudGVuVHJpbGxpb25zfTlgO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVM2RlY1Bvcy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAzO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVM2RlY05lZyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VFVTJkZWNOZWcpO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZUVVM2RlY05lZy5tYXhpbXVtVmFsdWUgPSBgJHtBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnN9OWA7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlRVUzZGVjTmVnLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IDM7XG5cbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmRvbGxhciA9IEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLk5vcnRoQW1lcmljYW47XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5kb2xsYXJQb3MgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5Ob3J0aEFtZXJpY2FuKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmRvbGxhclBvcy5taW5pbXVtVmFsdWUgPSAnMC4wMCc7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5kb2xsYXJOZWcgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5Ob3J0aEFtZXJpY2FuKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmRvbGxhck5lZy5tYXhpbXVtVmFsdWUgPSAnMC4wMCc7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5kb2xsYXJOZWcubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmRvbGxhck5lZ0JyYWNrZXRzID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuZG9sbGFyTmVnKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLmRvbGxhck5lZ0JyYWNrZXRzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5wYXJlbnRoZXNlcztcblxuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlYyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLk5vcnRoQW1lcmljYW4pO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlYy5jdXJyZW5jeVN5bWJvbCA9IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wubm9uZTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzJkZWMuc3VmZml4VGV4dCA9IEF1dG9OdW1lcmljLm9wdGlvbnMuc3VmZml4VGV4dC5wZXJjZW50YWdlO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlY1BvcyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzJkZWMpO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlY1Bvcy5taW5pbXVtVmFsdWUgPSAnMC4wMCc7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMyZGVjTmVnID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlYyk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMyZGVjTmVnLm1heGltdW1WYWx1ZSA9ICcwLjAwJztcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzJkZWNOZWcubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDtcblxuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTM2RlYyA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzJkZWMpO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTM2RlYy5tYXhpbXVtVmFsdWUgPSBgJHtBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnN9OWA7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMzZGVjLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IDM7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMzZGVjUG9zID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTMmRlY1Bvcyk7XG5BdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMzZGVjUG9zLm1heGltdW1WYWx1ZSA9IGAke0F1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnRlblRyaWxsaW9uc305YDtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzNkZWNQb3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gMztcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzNkZWNOZWcgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChBdXRvTnVtZXJpYy5wcmVkZWZpbmVkT3B0aW9ucy5wZXJjZW50YWdlVVMyZGVjTmVnKTtcbkF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zLnBlcmNlbnRhZ2VVUzNkZWNOZWcubWF4aW11bVZhbHVlID0gYCR7QXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUudGVuVHJpbGxpb25zfTlgO1xuQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMucGVyY2VudGFnZVVTM2RlY05lZy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0F1dG9OdW1lcmljUHJlZGVmaW5lZE9wdGlvbnMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericEvents = __webpack_require__(6);\n\nvar _AutoNumericEvents2 = _interopRequireDefault(_AutoNumericEvents);\n\nvar _AutoNumericOptions = __webpack_require__(4);\n\nvar _AutoNumericOptions2 = _interopRequireDefault(_AutoNumericOptions);\n\nvar _AutoNumericDefaultSettings = __webpack_require__(5);\n\nvar _AutoNumericDefaultSettings2 = _interopRequireDefault(_AutoNumericDefaultSettings);\n\nvar _AutoNumericPredefinedOptions = __webpack_require__(7);\n\nvar _AutoNumericPredefinedOptions2 = _interopRequireDefault(_AutoNumericPredefinedOptions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\n/**\n * This file serve as the main entry point to the library.\n * cf. workaround detailed here http://stackoverflow.com/a/33683495/2834898\n *\n * @type {AutoNumeric}\n */\nmodule.exports = _AutoNumeric2.default;\n//TODO Also export the AutoNumericEnum module\n/**\n * Babel + Webpack workaround for autoNumeric\n *\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2017 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBZ0NBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOztBQUVBOzs7Ozs7QUFNQUEsT0FBT0MsT0FBUDtBQUNBO0FBL0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEsbUIiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFiZWwgKyBXZWJwYWNrIHdvcmthcm91bmQgZm9yIGF1dG9OdW1lcmljXG4gKlxuICogQGF1dGhvciBBbGV4YW5kcmUgQm9ubmVhdSA8YWxleGFuZHJlLmJvbm5lYXVAbGludXhmci5ldT5cbiAqIEBjb3B5cmlnaHQgwqkgMjAxNyBBbGV4YW5kcmUgQm9ubmVhdVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZ2xvYmFsIG1vZHVsZSAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWMgZnJvbSAnLi9BdXRvTnVtZXJpYyc7XG5pbXBvcnQgQXV0b051bWVyaWNFdmVudHMgZnJvbSAnLi9BdXRvTnVtZXJpY0V2ZW50cyc7XG5pbXBvcnQgQXV0b051bWVyaWNPcHRpb25zIGZyb20gJy4vQXV0b051bWVyaWNPcHRpb25zJztcbmltcG9ydCBBdXRvTnVtZXJpY0RlZmF1bHRTZXR0aW5ncyBmcm9tICcuL0F1dG9OdW1lcmljRGVmYXVsdFNldHRpbmdzJztcbmltcG9ydCBBdXRvTnVtZXJpY1ByZWRlZmluZWRPcHRpb25zIGZyb20gJy4vQXV0b051bWVyaWNQcmVkZWZpbmVkT3B0aW9ucyc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogMCAqL1xuXG4vKipcbiAqIFRoaXMgZmlsZSBzZXJ2ZSBhcyB0aGUgbWFpbiBlbnRyeSBwb2ludCB0byB0aGUgbGlicmFyeS5cbiAqIGNmLiB3b3JrYXJvdW5kIGRldGFpbGVkIGhlcmUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzM2ODM0OTUvMjgzNDg5OFxuICpcbiAqIEB0eXBlIHtBdXRvTnVtZXJpY31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBdXRvTnVtZXJpYztcbi8vVE9ETyBBbHNvIGV4cG9ydCB0aGUgQXV0b051bWVyaWNFbnVtIG1vZHVsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;